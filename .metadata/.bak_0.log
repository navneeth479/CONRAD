!SESSION 2021-10-31 00:31:30.886 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-31 00:31:52.678
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-31 00:31:52.678
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4f7ba0af,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5b23c1f6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-31 00:31:55.667
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\navne'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-31 00:50:59.967 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-31 00:51:18.070
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-31 00:51:18.070
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2ebf524,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@41bdaa81,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-31 00:51:21.627
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\navne'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui.ide 4 4 2021-10-31 11:50:27.634
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:498)
	at org.eclipse.help.ui.internal.views.EngineResultSection.getGrayedImage(EngineResultSection.java:331)
	at org.eclipse.help.ui.internal.views.EngineResultSection.createFormText(EngineResultSection.java:158)
	at org.eclipse.help.ui.internal.views.EngineResultSection.createControl(EngineResultSection.java:125)
	at org.eclipse.help.ui.internal.views.SearchResultsPart.add(SearchResultsPart.java:359)
	at org.eclipse.help.ui.internal.views.SearchResultsPart.startNewSearch(SearchResultsPart.java:243)
	at org.eclipse.help.ui.internal.views.SearchPart.doSearch(SearchPart.java:647)
	at org.eclipse.help.ui.internal.views.SearchPart.doSearch(SearchPart.java:558)
	at org.eclipse.help.ui.internal.views.SearchPart.startSearch(SearchPart.java:508)
	at org.eclipse.help.ui.internal.views.ReusableHelpPart.startSearch(ReusableHelpPart.java:1058)
	at org.eclipse.help.ui.internal.views.HelpView.startSearch(HelpView.java:343)
	at org.eclipse.help.ui.internal.DefaultHelpUI.search(DefaultHelpUI.java:214)
	at org.eclipse.ui.internal.help.WorkbenchHelpSystem.search(WorkbenchHelpSystem.java:730)
	at org.eclipse.ui.internal.quickaccess.providers.HelpSearchElement.execute(HelpSearchElement.java:50)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4029)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui.ide 4 4 2021-10-31 11:50:27.637
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:498)
	at org.eclipse.help.ui.internal.views.EngineResultSection.getGrayedImage(EngineResultSection.java:331)
	at org.eclipse.help.ui.internal.views.EngineResultSection.createFormText(EngineResultSection.java:158)
	at org.eclipse.help.ui.internal.views.EngineResultSection.createControl(EngineResultSection.java:125)
	at org.eclipse.help.ui.internal.views.SearchResultsPart.add(SearchResultsPart.java:359)
	at org.eclipse.help.ui.internal.views.SearchResultsPart.startNewSearch(SearchResultsPart.java:243)
	at org.eclipse.help.ui.internal.views.SearchPart.doSearch(SearchPart.java:647)
	at org.eclipse.help.ui.internal.views.SearchPart.doSearch(SearchPart.java:558)
	at org.eclipse.help.ui.internal.views.SearchPart.refresh(SearchPart.java:734)
	at org.eclipse.ui.forms.ManagedForm.doRefresh(ManagedForm.java:181)
	at org.eclipse.ui.forms.ManagedForm.refresh(ManagedForm.java:171)
	at org.eclipse.help.ui.internal.views.ReusableHelpPart.flipPages(ReusableHelpPart.java:1093)
	at org.eclipse.help.ui.internal.views.ReusableHelpPart.showPage(ReusableHelpPart.java:1041)
	at org.eclipse.help.ui.internal.views.HelpView.createPartControl(HelpView.java:67)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:158)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityView.createPartControl(CompatibilityView.java:155)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:365)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:403)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:330)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:994)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:658)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$1.run(PartRenderingEngine.java:543)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:527)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.createWidget(ElementReferenceRenderer.java:73)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:994)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:658)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:762)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:727)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:711)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:109)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4770)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:228)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:121)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:676)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:762)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:727)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:711)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.subscribeTopicToBeRendered(PartRenderingEngine.java:161)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.di.internal.extensions.EventObjectSupplier$DIEventHandler.handleEvent(EventObjectSupplier.java:92)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:228)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setToBeRendered(UIElementImpl.java:314)
	at org.eclipse.e4.ui.workbench.addons.cleanupaddon.CleanupAddon.subscribeRenderingChanged(CleanupAddon.java:334)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4770)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:228)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setToBeRendered(UIElementImpl.java:314)
	at org.eclipse.e4.ui.internal.workbench.ModelServiceImpl.showElementInWindow(ModelServiceImpl.java:655)
	at org.eclipse.e4.ui.internal.workbench.ModelServiceImpl.bringToTop(ModelServiceImpl.java:624)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.delegateBringToTop(PartServiceImpl.java:786)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.activate(PartServiceImpl.java:757)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.activate(PartServiceImpl.java:679)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.activate(PartServiceImpl.java:674)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.showPart(PartServiceImpl.java:1251)
	at org.eclipse.ui.internal.WorkbenchPage.showPart(WorkbenchPage.java:1252)
	at org.eclipse.ui.internal.WorkbenchPage.busyShowView(WorkbenchPage.java:1240)
	at org.eclipse.ui.internal.WorkbenchPage.lambda$11(WorkbenchPage.java:4249)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchPage.showView(WorkbenchPage.java:4247)
	at org.eclipse.ui.internal.WorkbenchPage.showView(WorkbenchPage.java:4229)
	at org.eclipse.help.ui.internal.DefaultHelpUI.search(DefaultHelpUI.java:211)
	at org.eclipse.ui.internal.help.WorkbenchHelpSystem.search(WorkbenchHelpSystem.java:730)
	at org.eclipse.ui.internal.quickaccess.providers.HelpSearchElement.execute(HelpSearchElement.java:50)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4029)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui.ide 4 4 2021-10-31 18:10:41.484
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:498)
	at org.eclipse.help.ui.internal.views.EngineResultSection.getGrayedImage(EngineResultSection.java:331)
	at org.eclipse.help.ui.internal.views.EngineResultSection.createFormText(EngineResultSection.java:158)
	at org.eclipse.help.ui.internal.views.EngineResultSection.createControl(EngineResultSection.java:125)
	at org.eclipse.help.ui.internal.views.SearchResultsPart.add(SearchResultsPart.java:359)
	at org.eclipse.help.ui.internal.views.SearchResultsPart.startNewSearch(SearchResultsPart.java:243)
	at org.eclipse.help.ui.internal.views.SearchPart.doSearch(SearchPart.java:647)
	at org.eclipse.help.ui.internal.views.SearchPart.doSearch(SearchPart.java:558)
	at org.eclipse.help.ui.internal.views.SearchPart.startSearch(SearchPart.java:508)
	at org.eclipse.help.ui.internal.views.ReusableHelpPart.startSearch(ReusableHelpPart.java:1058)
	at org.eclipse.help.ui.internal.views.HelpView.startSearch(HelpView.java:343)
	at org.eclipse.help.ui.internal.DefaultHelpUI.search(DefaultHelpUI.java:214)
	at org.eclipse.ui.internal.help.WorkbenchHelpSystem.search(WorkbenchHelpSystem.java:730)
	at org.eclipse.ui.internal.quickaccess.providers.HelpSearchElement.execute(HelpSearchElement.java:50)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4029)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui.ide 4 4 2021-10-31 18:10:41.486
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:498)
	at org.eclipse.help.ui.internal.views.EngineResultSection.getGrayedImage(EngineResultSection.java:331)
	at org.eclipse.help.ui.internal.views.EngineResultSection.createFormText(EngineResultSection.java:158)
	at org.eclipse.help.ui.internal.views.EngineResultSection.createControl(EngineResultSection.java:125)
	at org.eclipse.help.ui.internal.views.SearchResultsPart.add(SearchResultsPart.java:359)
	at org.eclipse.help.ui.internal.views.SearchResultsPart.startNewSearch(SearchResultsPart.java:243)
	at org.eclipse.help.ui.internal.views.SearchPart.doSearch(SearchPart.java:647)
	at org.eclipse.help.ui.internal.views.SearchPart.doSearch(SearchPart.java:558)
	at org.eclipse.help.ui.internal.views.SearchPart.refresh(SearchPart.java:734)
	at org.eclipse.ui.forms.ManagedForm.doRefresh(ManagedForm.java:181)
	at org.eclipse.ui.forms.ManagedForm.refresh(ManagedForm.java:171)
	at org.eclipse.help.ui.internal.views.ReusableHelpPart.flipPages(ReusableHelpPart.java:1093)
	at org.eclipse.help.ui.internal.views.ReusableHelpPart.showPage(ReusableHelpPart.java:1041)
	at org.eclipse.help.ui.internal.views.HelpView.createPartControl(HelpView.java:67)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:158)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityView.createPartControl(CompatibilityView.java:155)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:365)
	at jdk.internal.reflect.GeneratedMethodAccessor70.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:403)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:330)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:994)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:658)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$1.run(PartRenderingEngine.java:543)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:527)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.createWidget(ElementReferenceRenderer.java:73)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:994)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:658)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:762)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:727)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:711)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:109)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4770)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:228)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:121)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:676)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:762)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:727)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:711)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.subscribeTopicToBeRendered(PartRenderingEngine.java:161)
	at jdk.internal.reflect.GeneratedMethodAccessor65.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.di.internal.extensions.EventObjectSupplier$DIEventHandler.handleEvent(EventObjectSupplier.java:92)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:228)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setToBeRendered(UIElementImpl.java:314)
	at org.eclipse.e4.ui.workbench.addons.cleanupaddon.CleanupAddon.subscribeRenderingChanged(CleanupAddon.java:334)
	at jdk.internal.reflect.GeneratedMethodAccessor64.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4770)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:228)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setToBeRendered(UIElementImpl.java:314)
	at org.eclipse.e4.ui.internal.workbench.ModelServiceImpl.showElementInWindow(ModelServiceImpl.java:655)
	at org.eclipse.e4.ui.internal.workbench.ModelServiceImpl.bringToTop(ModelServiceImpl.java:624)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.delegateBringToTop(PartServiceImpl.java:786)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.activate(PartServiceImpl.java:757)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.activate(PartServiceImpl.java:679)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.activate(PartServiceImpl.java:674)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.showPart(PartServiceImpl.java:1251)
	at org.eclipse.ui.internal.WorkbenchPage.showPart(WorkbenchPage.java:1252)
	at org.eclipse.ui.internal.WorkbenchPage.busyShowView(WorkbenchPage.java:1240)
	at org.eclipse.ui.internal.WorkbenchPage.lambda$11(WorkbenchPage.java:4249)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchPage.showView(WorkbenchPage.java:4247)
	at org.eclipse.ui.internal.WorkbenchPage.showView(WorkbenchPage.java:4229)
	at org.eclipse.help.ui.internal.DefaultHelpUI.search(DefaultHelpUI.java:211)
	at org.eclipse.ui.internal.help.WorkbenchHelpSystem.search(WorkbenchHelpSystem.java:730)
	at org.eclipse.ui.internal.quickaccess.providers.HelpSearchElement.execute(HelpSearchElement.java:50)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4029)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui 4 0 2021-10-31 18:16:35.087
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.List.size()" because "proposals" is null
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.handleSetData(CompletionProposalPopup.java:866)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Table.checkData(Table.java:1157)
	at org.eclipse.swt.widgets.Table.wmNotifyChild(Table.java:6604)
	at org.eclipse.swt.widgets.Control.wmNotify(Control.java:5807)
	at org.eclipse.swt.widgets.Composite.wmNotify(Composite.java:1961)
	at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:5375)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4809)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2264)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4966)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:588)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:454)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4854)
	at org.eclipse.swt.widgets.Table.windowProc(Table.java:5815)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4966)
	at org.eclipse.swt.internal.ole.win32.COM.VtblCall(Native Method)
	at org.eclipse.swt.internal.ole.win32.IOleInPlaceObject.InPlaceDeactivate(IOleInPlaceObject.java:24)
	at org.eclipse.swt.ole.win32.OleClientSite.deactivateInPlaceClient(OleClientSite.java:595)
	at org.eclipse.swt.ole.win32.OleClientSite.onDispose(OleClientSite.java:941)
	at org.eclipse.swt.ole.win32.OleClientSite$1.handleEvent(OleClientSite.java:130)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:809)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:713)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1356)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:423)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.AbstractInformationControl.dispose(AbstractInformationControl.java:500)
	at org.eclipse.jface.text.AbstractInformationControlManager.disposeInformationControl(AbstractInformationControlManager.java:1278)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController.disposeInformationControl(AdditionalInfoController.java:501)
	at org.eclipse.jface.text.AbstractInformationControlManager.handleSubjectControlDisposed(AbstractInformationControlManager.java:647)
	at org.eclipse.jface.text.AbstractInformationControlManager.lambda$0(AbstractInformationControlManager.java:682)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:127)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:809)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:423)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeProposals(AsyncCompletionProposalPopup.java:304)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeFilteredProposals(CompletionProposalPopup.java:1515)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeFilteredProposals(AsyncCompletionProposalPopup.java:328)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$1.run(CompletionProposalPopup.java:367)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.getSelectedProposal(CompletionProposalPopup.java:927)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.verifyKey(CompletionProposalPopup.java:1387)
	at org.eclipse.jface.text.contentassist.ContentAssistant$InternalListener.verifyKey(ContentAssistant.java:802)
	at org.eclipse.jface.text.TextViewer$VerifyKeyListenersManager.verifyKey(TextViewer.java:481)
	at org.eclipse.swt.custom.StyledTextListener.handleEvent(StyledTextListener.java:70)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:773)
	at org.eclipse.swt.custom.StyledText.handleKeyDown(StyledText.java:6248)
	at org.eclipse.swt.custom.StyledText.lambda$28(StyledText.java:5932)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1111)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1107)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1536)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4875)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4753)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4958)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui 4 0 2021-10-31 18:16:35.091
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.List.size()" because "proposals" is null
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.handleSetData(CompletionProposalPopup.java:866)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Table.checkData(Table.java:1157)
	at org.eclipse.swt.widgets.Table.wmNotifyChild(Table.java:6604)
	at org.eclipse.swt.widgets.Control.wmNotify(Control.java:5807)
	at org.eclipse.swt.widgets.Composite.wmNotify(Composite.java:1961)
	at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:5375)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4809)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2264)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4966)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:588)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:454)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4854)
	at org.eclipse.swt.widgets.Table.windowProc(Table.java:5815)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4966)
	at org.eclipse.swt.internal.ole.win32.COM.VtblCall(Native Method)
	at org.eclipse.swt.internal.ole.win32.IOleInPlaceObject.InPlaceDeactivate(IOleInPlaceObject.java:24)
	at org.eclipse.swt.ole.win32.OleClientSite.deactivateInPlaceClient(OleClientSite.java:595)
	at org.eclipse.swt.ole.win32.OleClientSite.onDispose(OleClientSite.java:941)
	at org.eclipse.swt.ole.win32.OleClientSite$1.handleEvent(OleClientSite.java:130)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:809)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:713)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1356)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:423)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.AbstractInformationControl.dispose(AbstractInformationControl.java:500)
	at org.eclipse.jface.text.AbstractInformationControlManager.disposeInformationControl(AbstractInformationControlManager.java:1278)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController.disposeInformationControl(AdditionalInfoController.java:501)
	at org.eclipse.jface.text.AbstractInformationControlManager.handleSubjectControlDisposed(AbstractInformationControlManager.java:647)
	at org.eclipse.jface.text.AbstractInformationControlManager.lambda$0(AbstractInformationControlManager.java:682)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:127)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:809)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:423)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeProposals(AsyncCompletionProposalPopup.java:304)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeFilteredProposals(CompletionProposalPopup.java:1515)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeFilteredProposals(AsyncCompletionProposalPopup.java:328)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$1.run(CompletionProposalPopup.java:367)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.getSelectedProposal(CompletionProposalPopup.java:927)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.verifyKey(CompletionProposalPopup.java:1387)
	at org.eclipse.jface.text.contentassist.ContentAssistant$InternalListener.verifyKey(ContentAssistant.java:802)
	at org.eclipse.jface.text.TextViewer$VerifyKeyListenersManager.verifyKey(TextViewer.java:481)
	at org.eclipse.swt.custom.StyledTextListener.handleEvent(StyledTextListener.java:70)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:773)
	at org.eclipse.swt.custom.StyledText.handleKeyDown(StyledText.java:6248)
	at org.eclipse.swt.custom.StyledText.lambda$28(StyledText.java:5932)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1111)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1107)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1536)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4875)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4753)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4958)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui 4 0 2021-10-31 18:16:35.094
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.List.size()" because "proposals" is null
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.handleSetData(CompletionProposalPopup.java:866)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Table.checkData(Table.java:1157)
	at org.eclipse.swt.widgets.Table.wmNotifyChild(Table.java:6604)
	at org.eclipse.swt.widgets.Control.wmNotify(Control.java:5807)
	at org.eclipse.swt.widgets.Composite.wmNotify(Composite.java:1961)
	at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:5375)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4809)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2264)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4966)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:588)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:454)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4854)
	at org.eclipse.swt.widgets.Table.windowProc(Table.java:5815)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4966)
	at org.eclipse.swt.internal.ole.win32.COM.VtblCall(Native Method)
	at org.eclipse.swt.internal.ole.win32.IOleInPlaceObject.InPlaceDeactivate(IOleInPlaceObject.java:24)
	at org.eclipse.swt.ole.win32.OleClientSite.deactivateInPlaceClient(OleClientSite.java:595)
	at org.eclipse.swt.ole.win32.OleClientSite.onDispose(OleClientSite.java:941)
	at org.eclipse.swt.ole.win32.OleClientSite$1.handleEvent(OleClientSite.java:130)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:809)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:713)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1356)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:423)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.AbstractInformationControl.dispose(AbstractInformationControl.java:500)
	at org.eclipse.jface.text.AbstractInformationControlManager.disposeInformationControl(AbstractInformationControlManager.java:1278)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController.disposeInformationControl(AdditionalInfoController.java:501)
	at org.eclipse.jface.text.AbstractInformationControlManager.handleSubjectControlDisposed(AbstractInformationControlManager.java:647)
	at org.eclipse.jface.text.AbstractInformationControlManager.lambda$0(AbstractInformationControlManager.java:682)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:127)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:809)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:423)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeProposals(AsyncCompletionProposalPopup.java:304)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeFilteredProposals(CompletionProposalPopup.java:1515)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeFilteredProposals(AsyncCompletionProposalPopup.java:328)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$1.run(CompletionProposalPopup.java:367)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.getSelectedProposal(CompletionProposalPopup.java:927)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.verifyKey(CompletionProposalPopup.java:1387)
	at org.eclipse.jface.text.contentassist.ContentAssistant$InternalListener.verifyKey(ContentAssistant.java:802)
	at org.eclipse.jface.text.TextViewer$VerifyKeyListenersManager.verifyKey(TextViewer.java:481)
	at org.eclipse.swt.custom.StyledTextListener.handleEvent(StyledTextListener.java:70)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:773)
	at org.eclipse.swt.custom.StyledText.handleKeyDown(StyledText.java:6248)
	at org.eclipse.swt.custom.StyledText.lambda$28(StyledText.java:5932)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1111)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1107)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1536)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4875)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4753)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4958)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui 4 0 2021-10-31 18:16:35.098
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.List.size()" because "proposals" is null
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.handleSetData(CompletionProposalPopup.java:866)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Table.checkData(Table.java:1157)
	at org.eclipse.swt.widgets.Table.wmNotifyChild(Table.java:6604)
	at org.eclipse.swt.widgets.Control.wmNotify(Control.java:5807)
	at org.eclipse.swt.widgets.Composite.wmNotify(Composite.java:1961)
	at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:5375)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4809)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2264)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4966)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:588)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:454)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4854)
	at org.eclipse.swt.widgets.Table.windowProc(Table.java:5815)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4966)
	at org.eclipse.swt.internal.ole.win32.COM.VtblCall(Native Method)
	at org.eclipse.swt.internal.ole.win32.IOleInPlaceObject.InPlaceDeactivate(IOleInPlaceObject.java:24)
	at org.eclipse.swt.ole.win32.OleClientSite.deactivateInPlaceClient(OleClientSite.java:595)
	at org.eclipse.swt.ole.win32.OleClientSite.onDispose(OleClientSite.java:941)
	at org.eclipse.swt.ole.win32.OleClientSite$1.handleEvent(OleClientSite.java:130)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:809)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:713)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1356)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:423)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.AbstractInformationControl.dispose(AbstractInformationControl.java:500)
	at org.eclipse.jface.text.AbstractInformationControlManager.disposeInformationControl(AbstractInformationControlManager.java:1278)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController.disposeInformationControl(AdditionalInfoController.java:501)
	at org.eclipse.jface.text.AbstractInformationControlManager.handleSubjectControlDisposed(AbstractInformationControlManager.java:647)
	at org.eclipse.jface.text.AbstractInformationControlManager.lambda$0(AbstractInformationControlManager.java:682)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:127)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:809)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:423)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeProposals(AsyncCompletionProposalPopup.java:304)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeFilteredProposals(CompletionProposalPopup.java:1515)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeFilteredProposals(AsyncCompletionProposalPopup.java:328)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$1.run(CompletionProposalPopup.java:367)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.getSelectedProposal(CompletionProposalPopup.java:927)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.verifyKey(CompletionProposalPopup.java:1387)
	at org.eclipse.jface.text.contentassist.ContentAssistant$InternalListener.verifyKey(ContentAssistant.java:802)
	at org.eclipse.jface.text.TextViewer$VerifyKeyListenersManager.verifyKey(TextViewer.java:481)
	at org.eclipse.swt.custom.StyledTextListener.handleEvent(StyledTextListener.java:70)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:773)
	at org.eclipse.swt.custom.StyledText.handleKeyDown(StyledText.java:6248)
	at org.eclipse.swt.custom.StyledText.lambda$28(StyledText.java:5932)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1111)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1107)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1536)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4875)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4753)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4958)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui 4 0 2021-10-31 18:16:35.101
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.List.size()" because "proposals" is null
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.handleSetData(CompletionProposalPopup.java:866)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Table.checkData(Table.java:1157)
	at org.eclipse.swt.widgets.Table.wmNotifyChild(Table.java:6604)
	at org.eclipse.swt.widgets.Control.wmNotify(Control.java:5807)
	at org.eclipse.swt.widgets.Composite.wmNotify(Composite.java:1961)
	at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:5375)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4809)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2264)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4966)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:588)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:454)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4854)
	at org.eclipse.swt.widgets.Table.windowProc(Table.java:5815)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4966)
	at org.eclipse.swt.internal.ole.win32.COM.VtblCall(Native Method)
	at org.eclipse.swt.internal.ole.win32.IOleInPlaceObject.InPlaceDeactivate(IOleInPlaceObject.java:24)
	at org.eclipse.swt.ole.win32.OleClientSite.deactivateInPlaceClient(OleClientSite.java:595)
	at org.eclipse.swt.ole.win32.OleClientSite.onDispose(OleClientSite.java:941)
	at org.eclipse.swt.ole.win32.OleClientSite$1.handleEvent(OleClientSite.java:130)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:809)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:713)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1356)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:423)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.AbstractInformationControl.dispose(AbstractInformationControl.java:500)
	at org.eclipse.jface.text.AbstractInformationControlManager.disposeInformationControl(AbstractInformationControlManager.java:1278)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController.disposeInformationControl(AdditionalInfoController.java:501)
	at org.eclipse.jface.text.AbstractInformationControlManager.handleSubjectControlDisposed(AbstractInformationControlManager.java:647)
	at org.eclipse.jface.text.AbstractInformationControlManager.lambda$0(AbstractInformationControlManager.java:682)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:127)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:809)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:423)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeProposals(AsyncCompletionProposalPopup.java:304)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeFilteredProposals(CompletionProposalPopup.java:1515)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeFilteredProposals(AsyncCompletionProposalPopup.java:328)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$1.run(CompletionProposalPopup.java:367)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.getSelectedProposal(CompletionProposalPopup.java:927)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.verifyKey(CompletionProposalPopup.java:1387)
	at org.eclipse.jface.text.contentassist.ContentAssistant$InternalListener.verifyKey(ContentAssistant.java:802)
	at org.eclipse.jface.text.TextViewer$VerifyKeyListenersManager.verifyKey(TextViewer.java:481)
	at org.eclipse.swt.custom.StyledTextListener.handleEvent(StyledTextListener.java:70)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:773)
	at org.eclipse.swt.custom.StyledText.handleKeyDown(StyledText.java:6248)
	at org.eclipse.swt.custom.StyledText.lambda$28(StyledText.java:5932)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1111)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1107)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1536)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4875)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4753)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4958)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui 4 0 2021-10-31 18:16:35.105
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.List.size()" because "proposals" is null
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.handleSetData(CompletionProposalPopup.java:866)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Table.checkData(Table.java:1157)
	at org.eclipse.swt.widgets.Table.wmNotifyChild(Table.java:6604)
	at org.eclipse.swt.widgets.Control.wmNotify(Control.java:5807)
	at org.eclipse.swt.widgets.Composite.wmNotify(Composite.java:1961)
	at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:5375)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4809)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2264)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4966)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:588)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:454)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4854)
	at org.eclipse.swt.widgets.Table.windowProc(Table.java:5815)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4966)
	at org.eclipse.swt.internal.ole.win32.COM.VtblCall(Native Method)
	at org.eclipse.swt.internal.ole.win32.IOleInPlaceObject.InPlaceDeactivate(IOleInPlaceObject.java:24)
	at org.eclipse.swt.ole.win32.OleClientSite.deactivateInPlaceClient(OleClientSite.java:595)
	at org.eclipse.swt.ole.win32.OleClientSite.onDispose(OleClientSite.java:941)
	at org.eclipse.swt.ole.win32.OleClientSite$1.handleEvent(OleClientSite.java:130)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:809)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:713)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1356)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:423)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.AbstractInformationControl.dispose(AbstractInformationControl.java:500)
	at org.eclipse.jface.text.AbstractInformationControlManager.disposeInformationControl(AbstractInformationControlManager.java:1278)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController.disposeInformationControl(AdditionalInfoController.java:501)
	at org.eclipse.jface.text.AbstractInformationControlManager.handleSubjectControlDisposed(AbstractInformationControlManager.java:647)
	at org.eclipse.jface.text.AbstractInformationControlManager.lambda$0(AbstractInformationControlManager.java:682)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:127)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:809)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:423)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeProposals(AsyncCompletionProposalPopup.java:304)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeFilteredProposals(CompletionProposalPopup.java:1515)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeFilteredProposals(AsyncCompletionProposalPopup.java:328)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$1.run(CompletionProposalPopup.java:367)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.getSelectedProposal(CompletionProposalPopup.java:927)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.verifyKey(CompletionProposalPopup.java:1387)
	at org.eclipse.jface.text.contentassist.ContentAssistant$InternalListener.verifyKey(ContentAssistant.java:802)
	at org.eclipse.jface.text.TextViewer$VerifyKeyListenersManager.verifyKey(TextViewer.java:481)
	at org.eclipse.swt.custom.StyledTextListener.handleEvent(StyledTextListener.java:70)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:773)
	at org.eclipse.swt.custom.StyledText.handleKeyDown(StyledText.java:6248)
	at org.eclipse.swt.custom.StyledText.lambda$28(StyledText.java:5932)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1111)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1107)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1536)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4875)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4753)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4958)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui 4 0 2021-10-31 18:16:35.108
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.List.size()" because "proposals" is null
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.handleSetData(CompletionProposalPopup.java:866)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Table.checkData(Table.java:1157)
	at org.eclipse.swt.widgets.Table.wmNotifyChild(Table.java:6604)
	at org.eclipse.swt.widgets.Control.wmNotify(Control.java:5807)
	at org.eclipse.swt.widgets.Composite.wmNotify(Composite.java:1961)
	at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:5375)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4809)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2264)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4966)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:588)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:454)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4854)
	at org.eclipse.swt.widgets.Table.windowProc(Table.java:5815)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4966)
	at org.eclipse.swt.internal.ole.win32.COM.VtblCall(Native Method)
	at org.eclipse.swt.internal.ole.win32.IOleInPlaceObject.InPlaceDeactivate(IOleInPlaceObject.java:24)
	at org.eclipse.swt.ole.win32.OleClientSite.deactivateInPlaceClient(OleClientSite.java:595)
	at org.eclipse.swt.ole.win32.OleClientSite.onDispose(OleClientSite.java:941)
	at org.eclipse.swt.ole.win32.OleClientSite$1.handleEvent(OleClientSite.java:130)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:809)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:713)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1356)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:423)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.AbstractInformationControl.dispose(AbstractInformationControl.java:500)
	at org.eclipse.jface.text.AbstractInformationControlManager.disposeInformationControl(AbstractInformationControlManager.java:1278)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController.disposeInformationControl(AdditionalInfoController.java:501)
	at org.eclipse.jface.text.AbstractInformationControlManager.handleSubjectControlDisposed(AbstractInformationControlManager.java:647)
	at org.eclipse.jface.text.AbstractInformationControlManager.lambda$0(AbstractInformationControlManager.java:682)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:127)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:809)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:423)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeProposals(AsyncCompletionProposalPopup.java:304)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeFilteredProposals(CompletionProposalPopup.java:1515)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeFilteredProposals(AsyncCompletionProposalPopup.java:328)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$1.run(CompletionProposalPopup.java:367)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.getSelectedProposal(CompletionProposalPopup.java:927)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.verifyKey(CompletionProposalPopup.java:1387)
	at org.eclipse.jface.text.contentassist.ContentAssistant$InternalListener.verifyKey(ContentAssistant.java:802)
	at org.eclipse.jface.text.TextViewer$VerifyKeyListenersManager.verifyKey(TextViewer.java:481)
	at org.eclipse.swt.custom.StyledTextListener.handleEvent(StyledTextListener.java:70)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:773)
	at org.eclipse.swt.custom.StyledText.handleKeyDown(StyledText.java:6248)
	at org.eclipse.swt.custom.StyledText.lambda$28(StyledText.java:5932)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1111)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1107)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1536)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4875)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4753)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4958)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui 4 0 2021-10-31 18:16:35.112
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.List.size()" because "proposals" is null
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.handleSetData(CompletionProposalPopup.java:866)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Table.checkData(Table.java:1157)
	at org.eclipse.swt.widgets.Table.wmNotifyChild(Table.java:6604)
	at org.eclipse.swt.widgets.Control.wmNotify(Control.java:5807)
	at org.eclipse.swt.widgets.Composite.wmNotify(Composite.java:1961)
	at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:5375)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4809)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2264)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4966)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:588)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:454)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4854)
	at org.eclipse.swt.widgets.Table.windowProc(Table.java:5815)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4966)
	at org.eclipse.swt.internal.ole.win32.COM.VtblCall(Native Method)
	at org.eclipse.swt.internal.ole.win32.IOleInPlaceObject.InPlaceDeactivate(IOleInPlaceObject.java:24)
	at org.eclipse.swt.ole.win32.OleClientSite.deactivateInPlaceClient(OleClientSite.java:595)
	at org.eclipse.swt.ole.win32.OleClientSite.onDispose(OleClientSite.java:941)
	at org.eclipse.swt.ole.win32.OleClientSite$1.handleEvent(OleClientSite.java:130)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:809)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:713)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1356)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:423)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.AbstractInformationControl.dispose(AbstractInformationControl.java:500)
	at org.eclipse.jface.text.AbstractInformationControlManager.disposeInformationControl(AbstractInformationControlManager.java:1278)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController.disposeInformationControl(AdditionalInfoController.java:501)
	at org.eclipse.jface.text.AbstractInformationControlManager.handleSubjectControlDisposed(AbstractInformationControlManager.java:647)
	at org.eclipse.jface.text.AbstractInformationControlManager.lambda$0(AbstractInformationControlManager.java:682)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:127)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:809)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:423)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeProposals(AsyncCompletionProposalPopup.java:304)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeFilteredProposals(CompletionProposalPopup.java:1515)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeFilteredProposals(AsyncCompletionProposalPopup.java:328)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$1.run(CompletionProposalPopup.java:367)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.getSelectedProposal(CompletionProposalPopup.java:927)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.verifyKey(CompletionProposalPopup.java:1387)
	at org.eclipse.jface.text.contentassist.ContentAssistant$InternalListener.verifyKey(ContentAssistant.java:802)
	at org.eclipse.jface.text.TextViewer$VerifyKeyListenersManager.verifyKey(TextViewer.java:481)
	at org.eclipse.swt.custom.StyledTextListener.handleEvent(StyledTextListener.java:70)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:773)
	at org.eclipse.swt.custom.StyledText.handleKeyDown(StyledText.java:6248)
	at org.eclipse.swt.custom.StyledText.lambda$28(StyledText.java:5932)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1111)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1107)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1536)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4875)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4753)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4958)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui 4 0 2021-10-31 18:16:35.116
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.List.size()" because "proposals" is null
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.handleSetData(CompletionProposalPopup.java:866)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Table.checkData(Table.java:1157)
	at org.eclipse.swt.widgets.Table.wmNotifyChild(Table.java:6604)
	at org.eclipse.swt.widgets.Control.wmNotify(Control.java:5807)
	at org.eclipse.swt.widgets.Composite.wmNotify(Composite.java:1961)
	at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:5375)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4809)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2264)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4966)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:588)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:454)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4854)
	at org.eclipse.swt.widgets.Table.windowProc(Table.java:5815)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4966)
	at org.eclipse.swt.internal.ole.win32.COM.VtblCall(Native Method)
	at org.eclipse.swt.internal.ole.win32.IOleInPlaceObject.InPlaceDeactivate(IOleInPlaceObject.java:24)
	at org.eclipse.swt.ole.win32.OleClientSite.deactivateInPlaceClient(OleClientSite.java:595)
	at org.eclipse.swt.ole.win32.OleClientSite.onDispose(OleClientSite.java:941)
	at org.eclipse.swt.ole.win32.OleClientSite$1.handleEvent(OleClientSite.java:130)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:809)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:713)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1356)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:423)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.AbstractInformationControl.dispose(AbstractInformationControl.java:500)
	at org.eclipse.jface.text.AbstractInformationControlManager.disposeInformationControl(AbstractInformationControlManager.java:1278)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController.disposeInformationControl(AdditionalInfoController.java:501)
	at org.eclipse.jface.text.AbstractInformationControlManager.handleSubjectControlDisposed(AbstractInformationControlManager.java:647)
	at org.eclipse.jface.text.AbstractInformationControlManager.lambda$0(AbstractInformationControlManager.java:682)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:127)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:809)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:423)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeProposals(AsyncCompletionProposalPopup.java:304)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeFilteredProposals(CompletionProposalPopup.java:1515)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeFilteredProposals(AsyncCompletionProposalPopup.java:328)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$1.run(CompletionProposalPopup.java:367)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.getSelectedProposal(CompletionProposalPopup.java:927)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.verifyKey(CompletionProposalPopup.java:1387)
	at org.eclipse.jface.text.contentassist.ContentAssistant$InternalListener.verifyKey(ContentAssistant.java:802)
	at org.eclipse.jface.text.TextViewer$VerifyKeyListenersManager.verifyKey(TextViewer.java:481)
	at org.eclipse.swt.custom.StyledTextListener.handleEvent(StyledTextListener.java:70)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:773)
	at org.eclipse.swt.custom.StyledText.handleKeyDown(StyledText.java:6248)
	at org.eclipse.swt.custom.StyledText.lambda$28(StyledText.java:5932)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1111)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1107)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1536)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4875)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4753)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4958)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui 4 0 2021-10-31 18:16:35.119
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.List.size()" because "proposals" is null
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.handleSetData(CompletionProposalPopup.java:866)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Table.checkData(Table.java:1157)
	at org.eclipse.swt.widgets.Table.wmNotifyChild(Table.java:6604)
	at org.eclipse.swt.widgets.Control.wmNotify(Control.java:5807)
	at org.eclipse.swt.widgets.Composite.wmNotify(Composite.java:1961)
	at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:5375)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4809)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2264)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4966)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:588)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:454)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4854)
	at org.eclipse.swt.widgets.Table.windowProc(Table.java:5815)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4966)
	at org.eclipse.swt.internal.ole.win32.COM.VtblCall(Native Method)
	at org.eclipse.swt.internal.ole.win32.IOleInPlaceObject.InPlaceDeactivate(IOleInPlaceObject.java:24)
	at org.eclipse.swt.ole.win32.OleClientSite.deactivateInPlaceClient(OleClientSite.java:595)
	at org.eclipse.swt.ole.win32.OleClientSite.onDispose(OleClientSite.java:941)
	at org.eclipse.swt.ole.win32.OleClientSite$1.handleEvent(OleClientSite.java:130)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:809)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:925)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:713)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1356)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:423)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.AbstractInformationControl.dispose(AbstractInformationControl.java:500)
	at org.eclipse.jface.text.AbstractInformationControlManager.disposeInformationControl(AbstractInformationControlManager.java:1278)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController.disposeInformationControl(AdditionalInfoController.java:501)
	at org.eclipse.jface.text.AbstractInformationControlManager.handleSubjectControlDisposed(AbstractInformationControlManager.java:647)
	at org.eclipse.jface.text.AbstractInformationControlManager.lambda$0(AbstractInformationControlManager.java:682)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:127)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:809)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:423)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeProposals(AsyncCompletionProposalPopup.java:304)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeFilteredProposals(CompletionProposalPopup.java:1515)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeFilteredProposals(AsyncCompletionProposalPopup.java:328)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$1.run(CompletionProposalPopup.java:367)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.getSelectedProposal(CompletionProposalPopup.java:927)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.verifyKey(CompletionProposalPopup.java:1387)
	at org.eclipse.jface.text.contentassist.ContentAssistant$InternalListener.verifyKey(ContentAssistant.java:802)
	at org.eclipse.jface.text.TextViewer$VerifyKeyListenersManager.verifyKey(TextViewer.java:481)
	at org.eclipse.swt.custom.StyledTextListener.handleEvent(StyledTextListener.java:70)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:773)
	at org.eclipse.swt.custom.StyledText.handleKeyDown(StyledText.java:6248)
	at org.eclipse.swt.custom.StyledText.lambda$28(StyledText.java:5932)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1111)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1107)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1536)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4875)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4753)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4958)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui.ide 4 4 2021-10-31 20:00:36.938
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:498)
	at org.eclipse.help.ui.internal.views.EngineResultSection.getGrayedImage(EngineResultSection.java:331)
	at org.eclipse.help.ui.internal.views.EngineResultSection.createFormText(EngineResultSection.java:158)
	at org.eclipse.help.ui.internal.views.EngineResultSection.createControl(EngineResultSection.java:125)
	at org.eclipse.help.ui.internal.views.SearchResultsPart.add(SearchResultsPart.java:359)
	at org.eclipse.help.ui.internal.views.SearchResultsPart.startNewSearch(SearchResultsPart.java:243)
	at org.eclipse.help.ui.internal.views.SearchPart.doSearch(SearchPart.java:647)
	at org.eclipse.help.ui.internal.views.SearchPart.doSearch(SearchPart.java:558)
	at org.eclipse.help.ui.internal.views.SearchPart.startSearch(SearchPart.java:508)
	at org.eclipse.help.ui.internal.views.ReusableHelpPart.startSearch(ReusableHelpPart.java:1058)
	at org.eclipse.help.ui.internal.views.HelpView.startSearch(HelpView.java:343)
	at org.eclipse.help.ui.internal.DefaultHelpUI.search(DefaultHelpUI.java:214)
	at org.eclipse.ui.internal.help.WorkbenchHelpSystem.search(WorkbenchHelpSystem.java:730)
	at org.eclipse.ui.internal.quickaccess.providers.HelpSearchElement.execute(HelpSearchElement.java:50)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4029)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SESSION 2021-11-01 15:41:15.638 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-01 15:41:21.500
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-01 15:41:21.500
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@31433df9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2d4a0671,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-01 15:41:25.589
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\navne'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-11 01:42:03.524 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-11 01:42:11.159
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-11 01:42:11.159
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3bcedb06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6f9a3325,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-11 01:42:15.848
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\navne'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-30 00:50:12.534 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-30 00:50:23.335
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-30 00:50:23.335
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@28bc9749,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@54a5496f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-30 00:50:29.063
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\navne'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui.ide 4 4 2021-11-30 01:06:31.017
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:498)
	at org.eclipse.help.ui.internal.views.EngineResultSection.getGrayedImage(EngineResultSection.java:331)
	at org.eclipse.help.ui.internal.views.EngineResultSection.createFormText(EngineResultSection.java:158)
	at org.eclipse.help.ui.internal.views.EngineResultSection.createControl(EngineResultSection.java:125)
	at org.eclipse.help.ui.internal.views.SearchResultsPart.add(SearchResultsPart.java:359)
	at org.eclipse.help.ui.internal.views.SearchResultsPart.startNewSearch(SearchResultsPart.java:243)
	at org.eclipse.help.ui.internal.views.SearchPart.doSearch(SearchPart.java:647)
	at org.eclipse.help.ui.internal.views.SearchPart.doSearch(SearchPart.java:558)
	at org.eclipse.help.ui.internal.views.SearchPart.refresh(SearchPart.java:734)
	at org.eclipse.ui.forms.ManagedForm.doRefresh(ManagedForm.java:181)
	at org.eclipse.ui.forms.ManagedForm.refresh(ManagedForm.java:171)
	at org.eclipse.help.ui.internal.views.ReusableHelpPart.flipPages(ReusableHelpPart.java:1093)
	at org.eclipse.help.ui.internal.views.ReusableHelpPart.showPage(ReusableHelpPart.java:1041)
	at org.eclipse.help.ui.internal.views.HelpView.createPartControl(HelpView.java:67)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:158)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityView.createPartControl(CompatibilityView.java:155)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:365)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:403)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:330)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:994)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:658)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$1.run(PartRenderingEngine.java:543)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:527)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.createWidget(ElementReferenceRenderer.java:73)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:994)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:658)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:762)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:727)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:711)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:109)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4770)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:228)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:121)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:676)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:762)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:727)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:711)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.subscribeTopicToBeRendered(PartRenderingEngine.java:161)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.di.internal.extensions.EventObjectSupplier$DIEventHandler.handleEvent(EventObjectSupplier.java:92)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:228)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setToBeRendered(UIElementImpl.java:314)
	at org.eclipse.e4.ui.workbench.addons.cleanupaddon.CleanupAddon.subscribeRenderingChanged(CleanupAddon.java:334)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4770)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:228)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setToBeRendered(UIElementImpl.java:314)
	at org.eclipse.e4.ui.internal.workbench.ModelServiceImpl.showElementInWindow(ModelServiceImpl.java:655)
	at org.eclipse.e4.ui.internal.workbench.ModelServiceImpl.bringToTop(ModelServiceImpl.java:624)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.delegateBringToTop(PartServiceImpl.java:786)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.activate(PartServiceImpl.java:757)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.activate(PartServiceImpl.java:679)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.activate(PartServiceImpl.java:674)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.showPart(PartServiceImpl.java:1251)
	at org.eclipse.ui.internal.WorkbenchPage.showPart(WorkbenchPage.java:1252)
	at org.eclipse.ui.internal.WorkbenchPage.busyShowView(WorkbenchPage.java:1240)
	at org.eclipse.ui.internal.WorkbenchPage.lambda$11(WorkbenchPage.java:4249)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchPage.showView(WorkbenchPage.java:4247)
	at org.eclipse.ui.internal.WorkbenchPage.showView(WorkbenchPage.java:4229)
	at org.eclipse.help.ui.internal.DefaultHelpUI.search(DefaultHelpUI.java:211)
	at org.eclipse.ui.internal.help.WorkbenchHelpSystem.search(WorkbenchHelpSystem.java:730)
	at org.eclipse.ui.internal.quickaccess.providers.HelpSearchElement.execute(HelpSearchElement.java:50)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4029)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui.ide 4 4 2021-11-30 01:10:45.621
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:498)
	at org.eclipse.help.ui.internal.views.EngineResultSection.getGrayedImage(EngineResultSection.java:331)
	at org.eclipse.help.ui.internal.views.EngineResultSection.createFormText(EngineResultSection.java:158)
	at org.eclipse.help.ui.internal.views.EngineResultSection.createControl(EngineResultSection.java:125)
	at org.eclipse.help.ui.internal.views.SearchResultsPart.add(SearchResultsPart.java:359)
	at org.eclipse.help.ui.internal.views.SearchResultsPart.startNewSearch(SearchResultsPart.java:243)
	at org.eclipse.help.ui.internal.views.SearchPart.doSearch(SearchPart.java:647)
	at org.eclipse.help.ui.internal.views.SearchPart.doSearch(SearchPart.java:558)
	at org.eclipse.help.ui.internal.views.SearchPart.startSearch(SearchPart.java:508)
	at org.eclipse.help.ui.internal.views.ReusableHelpPart.startSearch(ReusableHelpPart.java:1058)
	at org.eclipse.help.ui.internal.views.HelpView.startSearch(HelpView.java:343)
	at org.eclipse.help.ui.internal.DefaultHelpUI.search(DefaultHelpUI.java:214)
	at org.eclipse.ui.internal.help.WorkbenchHelpSystem.search(WorkbenchHelpSystem.java:730)
	at org.eclipse.ui.internal.quickaccess.providers.HelpSearchElement.execute(HelpSearchElement.java:50)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4029)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SESSION 2021-12-04 15:57:16.714 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-04 15:57:55.119
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-04 15:57:55.119
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@93fb44,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@321c2a7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-04 15:58:01.193
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\navne'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui.ide 4 4 2021-12-07 03:00:02.246
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:498)
	at org.eclipse.help.ui.internal.views.EngineResultSection.getGrayedImage(EngineResultSection.java:331)
	at org.eclipse.help.ui.internal.views.EngineResultSection.createFormText(EngineResultSection.java:158)
	at org.eclipse.help.ui.internal.views.EngineResultSection.createControl(EngineResultSection.java:125)
	at org.eclipse.help.ui.internal.views.SearchResultsPart.add(SearchResultsPart.java:359)
	at org.eclipse.help.ui.internal.views.SearchResultsPart.startNewSearch(SearchResultsPart.java:243)
	at org.eclipse.help.ui.internal.views.SearchPart.doSearch(SearchPart.java:647)
	at org.eclipse.help.ui.internal.views.SearchPart.doSearch(SearchPart.java:558)
	at org.eclipse.help.ui.internal.views.SearchPart.handleButtonPressed(SearchPart.java:550)
	at org.eclipse.help.ui.internal.views.SearchPart$1.widgetSelected(SearchPart.java:228)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4054)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui.ide 4 4 2021-12-07 03:00:02.249
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:498)
	at org.eclipse.help.ui.internal.views.EngineResultSection.getGrayedImage(EngineResultSection.java:331)
	at org.eclipse.help.ui.internal.views.EngineResultSection.createFormText(EngineResultSection.java:158)
	at org.eclipse.help.ui.internal.views.EngineResultSection.createControl(EngineResultSection.java:125)
	at org.eclipse.help.ui.internal.views.SearchResultsPart.add(SearchResultsPart.java:359)
	at org.eclipse.help.ui.internal.views.SearchResultsPart.startNewSearch(SearchResultsPart.java:243)
	at org.eclipse.help.ui.internal.views.SearchPart.doSearch(SearchPart.java:647)
	at org.eclipse.help.ui.internal.views.SearchPart.doSearch(SearchPart.java:558)
	at org.eclipse.help.ui.internal.views.SearchPart.startSearch(SearchPart.java:508)
	at org.eclipse.help.ui.internal.views.ReusableHelpPart.startSearch(ReusableHelpPart.java:1058)
	at org.eclipse.help.ui.internal.views.HelpView.startSearch(HelpView.java:343)
	at org.eclipse.help.ui.internal.DefaultHelpUI.search(DefaultHelpUI.java:214)
	at org.eclipse.ui.internal.help.WorkbenchHelpSystem.search(WorkbenchHelpSystem.java:730)
	at org.eclipse.ui.internal.quickaccess.providers.HelpSearchElement.execute(HelpSearchElement.java:50)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4029)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui.ide 4 4 2021-12-07 03:00:02.252
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:498)
	at org.eclipse.help.ui.internal.views.EngineResultSection.getGrayedImage(EngineResultSection.java:331)
	at org.eclipse.help.ui.internal.views.EngineResultSection.createFormText(EngineResultSection.java:158)
	at org.eclipse.help.ui.internal.views.EngineResultSection.createControl(EngineResultSection.java:125)
	at org.eclipse.help.ui.internal.views.SearchResultsPart.add(SearchResultsPart.java:359)
	at org.eclipse.help.ui.internal.views.SearchResultsPart.startNewSearch(SearchResultsPart.java:243)
	at org.eclipse.help.ui.internal.views.SearchPart.doSearch(SearchPart.java:647)
	at org.eclipse.help.ui.internal.views.SearchPart.doSearch(SearchPart.java:558)
	at org.eclipse.help.ui.internal.views.SearchPart.refresh(SearchPart.java:734)
	at org.eclipse.ui.forms.ManagedForm.doRefresh(ManagedForm.java:181)
	at org.eclipse.ui.forms.ManagedForm.refresh(ManagedForm.java:171)
	at org.eclipse.help.ui.internal.views.ReusableHelpPart.flipPages(ReusableHelpPart.java:1093)
	at org.eclipse.help.ui.internal.views.ReusableHelpPart.showPage(ReusableHelpPart.java:1041)
	at org.eclipse.help.ui.internal.views.HelpView.createPartControl(HelpView.java:67)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:158)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityView.createPartControl(CompatibilityView.java:155)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:365)
	at jdk.internal.reflect.GeneratedMethodAccessor77.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:403)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:330)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:994)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:658)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$1.run(PartRenderingEngine.java:543)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:527)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.createWidget(ElementReferenceRenderer.java:73)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:994)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:658)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:762)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:727)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:711)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:109)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4770)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:228)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:121)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:676)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:762)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:727)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:711)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.subscribeTopicToBeRendered(PartRenderingEngine.java:161)
	at jdk.internal.reflect.GeneratedMethodAccessor75.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.di.internal.extensions.EventObjectSupplier$DIEventHandler.handleEvent(EventObjectSupplier.java:92)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:228)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setToBeRendered(UIElementImpl.java:314)
	at org.eclipse.e4.ui.workbench.addons.cleanupaddon.CleanupAddon.subscribeRenderingChanged(CleanupAddon.java:334)
	at jdk.internal.reflect.GeneratedMethodAccessor74.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4770)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:228)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setToBeRendered(UIElementImpl.java:314)
	at org.eclipse.e4.ui.internal.workbench.ModelServiceImpl.showElementInWindow(ModelServiceImpl.java:655)
	at org.eclipse.e4.ui.internal.workbench.ModelServiceImpl.bringToTop(ModelServiceImpl.java:624)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.delegateBringToTop(PartServiceImpl.java:786)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.activate(PartServiceImpl.java:757)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.activate(PartServiceImpl.java:679)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.activate(PartServiceImpl.java:674)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.showPart(PartServiceImpl.java:1251)
	at org.eclipse.ui.internal.WorkbenchPage.showPart(WorkbenchPage.java:1252)
	at org.eclipse.ui.internal.WorkbenchPage.busyShowView(WorkbenchPage.java:1240)
	at org.eclipse.ui.internal.WorkbenchPage.lambda$11(WorkbenchPage.java:4249)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchPage.showView(WorkbenchPage.java:4247)
	at org.eclipse.ui.internal.WorkbenchPage.showView(WorkbenchPage.java:4229)
	at org.eclipse.help.ui.internal.DefaultHelpUI.search(DefaultHelpUI.java:211)
	at org.eclipse.ui.internal.help.WorkbenchHelpSystem.search(WorkbenchHelpSystem.java:730)
	at org.eclipse.ui.internal.quickaccess.providers.HelpSearchElement.execute(HelpSearchElement.java:50)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4029)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SESSION 2021-12-13 01:13:06.514 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-13 01:13:15.640
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-13 01:13:15.640
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1bea7b0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@31433df9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-13 01:13:21.587
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\navne'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-15 16:02:27.474 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-15 16:02:37.047
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-15 16:02:37.047
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@93fb44,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@321c2a7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-15 16:02:41.507
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\navne'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2021-12-15 23:55:24.207
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package edu.stanford.rsl.tutorial.mipda;

import edu.stanford.rsl.conrad.data.numeric.Grid2D;
import edu.stanford.rsl.conrad.data.numeric.NumericPointwiseOperators;
import edu.stanford.rsl.conrad.utils.ImageUtil;
//import edu.stanford.rsl.conrad.utils.VisualizationUtil;
import ij.IJ;
import ij.ImageJ;
import edu.stanford.rsl.conrad.data.numeric.InterpolationOperators;
//import edu.stanford.rsl.conrad.data.numeric.NumericGridOperator;
import edu.stanford.rsl.conrad.numerics.SimpleMatrix;
import edu.stanford.rsl.conrad.numerics.SimpleOperators;
import edu.stanford.rsl.conrad.numerics.SimpleVector;
import edu.stanford.rsl.conrad.numerics.DecompositionSVD;

/**
 * Geometric Undistortion
 * Programming exercise 1 for module "Defect Pixel Interpolation"
 * of the course "Medical Image Processing for Diagnostic Applications (MIPDA)"
 * @author Frank Schebesch, Ashwini Jadhav, Anna Gebhard, Mena Abdelmalek
 *
 */

public class ExerciseGeoU {

	final static int caseNo = 1; // choose 0, 1, or 2 for different test images

	final static float a = 0.6f; // a: spread among x-direction
	final static float b = 0.3f; // b: spread among y-direction
	final static float d = 5.0f; // d: d/2 value of distortion field at level set for (X/a)^2+(Y/b)^2=1
	
	String filename; // do not edit, choose a number in the main method instead
	Grid2D originalImage; // do not edit, read from filename when instantiating the object
	Grid2D distortedImage; // do not edit, generated in the main method
	Grid2D undistortedImage; // do not edit, member variable for the output image
	
	// number of lattice points
	final int nx = 8;//TODO: define the number of lattice point: nx (Positive number and less than 20)
	final int ny = 8;//TODO: define the number of lattice point: ny (Positive number and less than 20)
	
	float fx;
	float fy;
	SimpleMatrix Xu; 
	SimpleMatrix Yu;
	SimpleMatrix Xd;
	SimpleMatrix Yd;
	int numCoeff; 
	int numCorresp; 
	SimpleMatrix A;
	DecompositionSVD svd;
	SimpleMatrix A_pseudoinverse;
	SimpleVector u_vec;
	SimpleVector v_vec;
	SimpleVector XuVector;
	SimpleVector YuVector;
	SimpleVector XdVector;
	SimpleVector YdVector;
	Grid2D xDist;  
	Grid2D yDist;
	Grid2D xprime; // x-coordinates of point correspondences in the undistorted image
	Grid2D yprime; // y-coordinates of point correspondences in the undistorted image
	Grid2D x; // x-coordinates of point correspondences in the distorted image
	Grid2D y; // y-coordinates of point correspondences in the distorted image
	
	
	/** 
	 * main method
	 * Here you can choose the image, and set the distortion parameters
	 */
	public static void main(String[] args) {
		
		new ImageJ();
		
		// generate distorted image
		ExerciseGeoU exObj = new ExerciseGeoU(caseNo);
		exObj.init(a,b,d);
		
		// TASK: go to the method doImageUndistortion(...) and complete it 
		exObj.undistortedImage = exObj.doImageUndistortion(exObj.distortedImage);
		
		exObj.originalImage.show("Original Image");
		exObj.distortedImage.show("Distorted Image");
		exObj.undistortedImage.show("Undistorted Image");
		
		Grid2D differenceImage = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.originalImage, exObj.undistortedImage);
		
		differenceImage.show("Difference Original vs. Undistorted");
		
		Grid2D distortedVSundistorted = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.undistortedImage, exObj.distortedImage);
		
		distortedVSundistorted.show("Difference Undistorted vs. Distorted");
	}
	
	public Grid2D doImageUndistortion(Grid2D distortedImage){
		
		Grid2D grid = new Grid2D(distortedImage);
		
		// check if image distortion routine has been run
		if (distortedImage == null || undistortedImage == null
				|| xprime == null || yprime == null
				|| x == null || y == null) {
			
			System.err.println("Error in doImageUndistortion(): called before initialization of members.");
			return grid;
		}
		
		
		getLatticePoints(distortedImage);// There are TODOs here 
		
		
		int degree = 5; // polynomial's degree: 2,...,10
		calcPolynomial(degree, Xd);// There are TODOs here
		
		
		
		computeMatrixA(degree, numCorresp, numCoeff);// There are TODOs here
		
		
		computeDistortionCoeff(A, XuVector, YuVector);// There are TODOs here
		
		
		grid = computeDistortedGrid(distortedImage, grid, degree);// There are TODOs here
		
		return grid;
	}
	
	
	
	/** 1. Number of lattice points (this only works for symmetric images):
	 *  nx, ny feature points: usually provided by tracking point
	 *  correspondences in the phantom during the calibration step.
	 *  Here, we use the distorted and undistorted coordinates generated
	 *  in the course of the distortion simulation.
	 */ 
	public void getLatticePoints (Grid2D distortedImage){
		
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		// step size
		// calculate the step size of the lattice points: fx and fy 
		fx = imageWidth/nx; //TODO
		fy = imageHeight/ny; //TODO
		
		// fill the distorted and undistorted lattice points 
		// with data from the given correspondences
		// matrix = number of rows (y) x number of columns (x)
		Xu = new SimpleMatrix(ny,nx);
		Yu = new SimpleMatrix(ny,nx);
		Xd = new SimpleMatrix(ny,nx);
		Yd = new SimpleMatrix(ny,nx);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){

				// sample the distorted and undistorted grid points at the lattice points
				  Xu.setElementValue(i, j, double(xprime.));//TODO: fill matrix Xu
				  Yu.setElementValue(i, j, fy);//TODO: fill matrix Yu
				  Xd.setElementValue(i, j, fx);//TODO: fill matrix Xd
				  Yd.setElementValue(i, j, fy)//TODO: fill matrix Yd
			}
		}
	}
	
	/** 2. Polynomial of degree d
	 * Polynomial of degree d -> (d-1): extrema (e.g., d=5: 4 extrema)
	 * d=0: constant (horizontal line with y-intercept a_0 -> f(x)=a_0)
	 * d=1: oblique line with y-intercept a_0 & slope a_1 -> f(x)=a_0 + a_1 x
	 * d=2: parabola
	 * d>=2: continuous non-linear curve
	 * ...
	 * d = 10 -> NumCoeff: 66 -> but only 64 lattice points are known (nx, ny = 8)
	 */
	
	public void calcPolynomial(int degree, SimpleMatrix Xd){
		
		// number of coefficients: numCoeff
		// (hint: this is NOT the total number of multiplications!)
		numCoeff = 0; //TODO
		
		// number of correspondences: numCorresp
		numCorresp =  0; //TODO
		
		// Printout of the used parameters
		System.out.println("Polynom of degree: " + degree);
		System.out.println("Number of Coefficients: " + numCoeff);
		System.out.println("Number of Correspondences: " + numCorresp);
		
	}
	
	/**
	 * 3. Create the matrix A
	 */
	
	public void computeMatrixA(int degree, int numCorresp, int numCoeff){
		
		A = new SimpleMatrix(numCorresp, numCoeff);
		if (numCorresp <= 0 && numCoeff <= 0)
			return;
		A.zeros();
		
		// Realign the grid matrix into a vector for easier access in the next step
		XuVector = new SimpleVector(numCorresp);
		YuVector = new SimpleVector(numCorresp);
		XdVector = new SimpleVector(numCorresp);
		YdVector = new SimpleVector(numCorresp);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){
				
				XuVector.setElementValue(i*ny + j, Xu.getElement(j, i));
				YuVector.setElementValue(i*ny + j, Yu.getElement(j, i));
				XdVector.setElementValue(i*ny + j, Xd.getElement(j, i));
				YdVector.setElementValue(i*ny + j, Yd.getElement(j, i));
			}
		}
		
		// Compute matrix A (coordinates from distorted image)
		for(int r = 0; r < numCorresp; r++){
			
			int cc = 0;
			
			for(int k = 0; k <= degree; k++){
				for(int l = 0; l <= (degree-k); l++){
					
					// TODO: fill matrix A
					cc++;
					
				}
			}
		}
	}
	
	public void computeDistortionCoeff(SimpleMatrix A, SimpleVector XuVector, SimpleVector YuVector){
		
		// Compute the pseudo-inverse of A with the help of the SVD (class: DecompositionSVD)
		svd = null; // TODO
	    A_pseudoinverse = null; // TODO
	  
		// Compute the distortion coefficients (solve for known corresponding undistorted points)
		u_vec = null;// TODO
		v_vec = null;// TODO
	}
	
	/**
	 * 4. Compute the distorted grid points (xDist, yDist) which are used to sample the
	 * distorted image to get the undistorted image
	 * (xprime,yprime) is the position in the undistorted image
	 * (xDist,yDist) is the position in the distorted (observed) X-ray image.
	 */
	public Grid2D computeDistortedGrid(Grid2D distortedImage, Grid2D grid_out, int degree){
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		xDist = new Grid2D(imageWidth,imageHeight);  
		yDist = new Grid2D(imageWidth,imageHeight); 
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float val1, val2; //variables Val1 and Val2 are used for intermediate computation of xDist and yDist respectively
				
				int cc = 0;
				
				for(int k = 0; k <= degree; k++){
					for(int l = 0; l <= degree - k; l++){
						
						val1 = 0;// TODO
						val2 = 0;// TODO
						
						// TODO: fill xDist
						// TODO: fill yDist
						
						cc++;
					}
				}
			}
		}
		
		float val; // variable for intermediate computations of undistorted image
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				// hint: consider the fact that the coordinate origin is in the center of the image
				val = 0;//TODO
				//TODO: fill grid_out
			}
		}
		
		return grid_out;
		
	}
	
	
	
	/**
	 * 
	 * end of the exercise
	 */	

	
	/**
	 * standard constructor
	 */
	public ExerciseGeoU(){
		
		this(0);
	}
		
	/**
	 * parameterized constructor for the ExerciseDPI object
	 * @param caseNo: select one of three images to test your undistortion method
	 */
	public ExerciseGeoU(int caseNo){
		
		switch (caseNo) {
		case 0:
			filename = "frame32.jpg";
			break;
		case 1:
			filename = "undistorted.jpg";
			break;
		case 2:
			filename = "frame90.jpg";
			break;
		default:
			filename = "frame32.jpg";
			break;
		}
		
		String imageDataLoc = System.getProperty("user.dir") + "/data/" + "/mipda/";
	
		originalImage = ImageUtil.wrapImagePlus(IJ.openImage(imageDataLoc + filename)).getSubGrid(0);
	}
	
	public void init(float a, float b, float d) {
		
		// Normalize intensity values to [0,1]
		float max = NumericPointwiseOperators.max(originalImage);
		float min = NumericPointwiseOperators.min(originalImage);
		
		for(int i = 0; i < originalImage.getWidth(); i++){
			for(int j = 0; j < originalImage.getHeight(); j++){
				
				float scaledValue = (originalImage.getAtIndex(i, j) - min) / (max-min);
				originalImage.setAtIndex(i, j, scaledValue);
			}
		}
		
		undistortedImage = new Grid2D(originalImage.getWidth(),originalImage.getHeight()); // initialization with zeros
		
		distortedImage = generateDistortedImage(originalImage,a,b,d);	
	}
	
	/**
	 * method to generate a distorted image
	 * An artificial distortion field is generated. With this field, 
	 * a distorted image is generated from the original image.
	 * Remark: coordinates of the latest distortion simulated are saved in class member variables
	 * @param inputImage: undistorted image on which distortion is simulated
	 * @param a: elliptic extent of the distortion in x-direction
	 * @param b: elliptic extent of the distortion in y-direction
	 * @param d: strength of the distortion
	 * @return: distorted image
	 */
    
	public Grid2D generateDistortedImage(Grid2D inputImage, float a, float b, float d){

		Grid2D grid = new Grid2D(inputImage);
		int imageWidth = grid.getWidth();
		int imageHeight = grid.getHeight();
		
		// generate grids to sample coordinates X and Y of the original image
		Grid2D X = new Grid2D(imageWidth,imageHeight); // x-coordinates with respect to origin in image center, spacing = 1 [unit]
		Grid2D Y = new Grid2D(imageWidth,imageHeight); // y-coordinates with respect to origin in image center, spacing = 1 [unit]
		
		float halfWidth = imageWidth / 2.0f;
		float halfHeight = imageHeight / 2.0f;
		
		for(int i = 0; i < X.getWidth(); i++){
			for(int j = 0; j < X.getHeight(); j++){
				
				X.setAtIndex(i, j, i - halfWidth + 0.5f); // assign pixel centers in x-direction
				Y.setAtIndex(i, j, j - halfHeight + 0.5f); // assign pixel center in y-direction
			}
		}
		
		// create an artificial elliptical distortion field R (additive field)
		Grid2D R = new Grid2D(imageWidth,imageHeight);

		for(int i = 0; i < R.getWidth(); i++){
			for(int j = 0; j < R.getHeight(); j++){
				
				// distortion gets stronger with the distance from the image center
				float r = d * (float)(Math.sqrt(
						Math.pow(X.getAtIndex(i, j)/(a*halfWidth),2)
						+ Math.pow(Y.getAtIndex(i, j)/(b*halfHeight),2)));
				R.setAtIndex(i, j, r);
			}
		}
		
		// shifting the positive range to half positive/half negative range
		float maxR = NumericPointwiseOperators.max(R);
		NumericPointwiseOperators.subtractBy(R, maxR * 0.5f);

		// create the distorted image coordinates:
		// distorted image coordinates = undistorted image points + artificial distortion field

		// distorted image coordinates Xd, Yd
		Grid2D Xd = new Grid2D(X);
		Grid2D Yd = new Grid2D(Y);
		
		NumericPointwiseOperators.addBy(Xd, R);
		NumericPointwiseOperators.addBy(Yd, R);
		
		// create the distorted image:
		// re-sample the original input image at the distorted image points (Xd,Yd) 
		// to create artificial distortion
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float distortedValue = InterpolationOperators.interpolateLinear(
						inputImage,
						Xd.getAtIndex(i, j) + halfWidth - 0.5f, // remember: coordinate origin was set to image center
						Yd.getAtIndex(i, j) + halfHeight - 0.5f);
				grid.setAtIndex(i, j, distortedValue);
			}
		}

		xprime = X;
		yprime = Y;
		x = Xd;
		y = Yd;
		
		return grid;	
	}	
	
	//getters for members
	// variables which are checked (DO NOT CHANGE!)
	
	public static int get_caseNo() {
		return caseNo;
	}
	
	public Grid2D get_originalImage() {
		return originalImage;
	}
	
	public Grid2D get_distortedImage() {
		return distortedImage;
	}
	
	public Grid2D get_undistortedImage() {
		return undistortedImage;
	}
	
	public int get_nx() {
		return nx;
	}
	
	public int get_ny() {
		return ny;
	}
	
	public float get_fx() {
		return fx;
	}
	
	public float get_fy() {
		return fy;
	}
	
	public SimpleMatrix get_Xu() {
		return Xu;
	}
	
	public SimpleMatrix get_Yu() {
		return Yu;
	}
	
	public SimpleMatrix get_Xd() {
		return Xd;
	}
	
	public SimpleMatrix get_Yd() {
		return Yd;
	}
	
	public int get_numCoeff() {
		return numCoeff;
	}
	
	public int get_numCorresp() {
		return numCorresp;
	}
	
	public SimpleMatrix get_A() {
		return A;
	}
	
	public DecompositionSVD get_svd() {
		return svd;
	}
	
	public SimpleMatrix get_A_pseudoinverse() {
		return A_pseudoinverse;
	}
	
	public SimpleVector get_u_vec() {
		return u_vec;
	}
	
	public SimpleVector get_v_vec() {
		return v_vec;
	}
	
	public SimpleVector get_XuVector() {
		return XuVector;
	}
	
	public SimpleVector get_YuVector() {
		return YuVector;
	}
	
	public SimpleVector get_XdVector() {
		return XdVector;
	}
	
	public SimpleVector get_YdVector() {
		return YdVector;
	}
	
	public Grid2D get_xDist() {
		return xDist;
	}
	
	public Grid2D get_yDist() {
		return yDist;
	}
	
	public Grid2D get_xprime() {
		return xprime;
	}
	
	public Grid2D get_yprime() {
		return yprime;
	}
	
	public Grid2D get_x() {
		return x;
	}
	
	public Grid2D get_y() {
		return y;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-15 23:55:24.209
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-15 23:55:24.210
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-15 23:55:24.241
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package edu.stanford.rsl.tutorial.mipda;

import edu.stanford.rsl.conrad.data.numeric.Grid2D;
import edu.stanford.rsl.conrad.data.numeric.NumericPointwiseOperators;
import edu.stanford.rsl.conrad.utils.ImageUtil;
//import edu.stanford.rsl.conrad.utils.VisualizationUtil;
import ij.IJ;
import ij.ImageJ;
import edu.stanford.rsl.conrad.data.numeric.InterpolationOperators;
//import edu.stanford.rsl.conrad.data.numeric.NumericGridOperator;
import edu.stanford.rsl.conrad.numerics.SimpleMatrix;
import edu.stanford.rsl.conrad.numerics.SimpleOperators;
import edu.stanford.rsl.conrad.numerics.SimpleVector;
import edu.stanford.rsl.conrad.numerics.DecompositionSVD;

/**
 * Geometric Undistortion
 * Programming exercise 1 for module "Defect Pixel Interpolation"
 * of the course "Medical Image Processing for Diagnostic Applications (MIPDA)"
 * @author Frank Schebesch, Ashwini Jadhav, Anna Gebhard, Mena Abdelmalek
 *
 */

public class ExerciseGeoU {

	final static int caseNo = 1; // choose 0, 1, or 2 for different test images

	final static float a = 0.6f; // a: spread among x-direction
	final static float b = 0.3f; // b: spread among y-direction
	final static float d = 5.0f; // d: d/2 value of distortion field at level set for (X/a)^2+(Y/b)^2=1
	
	String filename; // do not edit, choose a number in the main method instead
	Grid2D originalImage; // do not edit, read from filename when instantiating the object
	Grid2D distortedImage; // do not edit, generated in the main method
	Grid2D undistortedImage; // do not edit, member variable for the output image
	
	// number of lattice points
	final int nx = 8;//TODO: define the number of lattice point: nx (Positive number and less than 20)
	final int ny = 8;//TODO: define the number of lattice point: ny (Positive number and less than 20)
	
	float fx;
	float fy;
	SimpleMatrix Xu; 
	SimpleMatrix Yu;
	SimpleMatrix Xd;
	SimpleMatrix Yd;
	int numCoeff; 
	int numCorresp; 
	SimpleMatrix A;
	DecompositionSVD svd;
	SimpleMatrix A_pseudoinverse;
	SimpleVector u_vec;
	SimpleVector v_vec;
	SimpleVector XuVector;
	SimpleVector YuVector;
	SimpleVector XdVector;
	SimpleVector YdVector;
	Grid2D xDist;  
	Grid2D yDist;
	Grid2D xprime; // x-coordinates of point correspondences in the undistorted image
	Grid2D yprime; // y-coordinates of point correspondences in the undistorted image
	Grid2D x; // x-coordinates of point correspondences in the distorted image
	Grid2D y; // y-coordinates of point correspondences in the distorted image
	
	
	/** 
	 * main method
	 * Here you can choose the image, and set the distortion parameters
	 */
	public static void main(String[] args) {
		
		new ImageJ();
		
		// generate distorted image
		ExerciseGeoU exObj = new ExerciseGeoU(caseNo);
		exObj.init(a,b,d);
		
		// TASK: go to the method doImageUndistortion(...) and complete it 
		exObj.undistortedImage = exObj.doImageUndistortion(exObj.distortedImage);
		
		exObj.originalImage.show("Original Image");
		exObj.distortedImage.show("Distorted Image");
		exObj.undistortedImage.show("Undistorted Image");
		
		Grid2D differenceImage = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.originalImage, exObj.undistortedImage);
		
		differenceImage.show("Difference Original vs. Undistorted");
		
		Grid2D distortedVSundistorted = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.undistortedImage, exObj.distortedImage);
		
		distortedVSundistorted.show("Difference Undistorted vs. Distorted");
	}
	
	public Grid2D doImageUndistortion(Grid2D distortedImage){
		
		Grid2D grid = new Grid2D(distortedImage);
		
		// check if image distortion routine has been run
		if (distortedImage == null || undistortedImage == null
				|| xprime == null || yprime == null
				|| x == null || y == null) {
			
			System.err.println("Error in doImageUndistortion(): called before initialization of members.");
			return grid;
		}
		
		
		getLatticePoints(distortedImage);// There are TODOs here 
		
		
		int degree = 5; // polynomial's degree: 2,...,10
		calcPolynomial(degree, Xd);// There are TODOs here
		
		
		
		computeMatrixA(degree, numCorresp, numCoeff);// There are TODOs here
		
		
		computeDistortionCoeff(A, XuVector, YuVector);// There are TODOs here
		
		
		grid = computeDistortedGrid(distortedImage, grid, degree);// There are TODOs here
		
		return grid;
	}
	
	
	
	/** 1. Number of lattice points (this only works for symmetric images):
	 *  nx, ny feature points: usually provided by tracking point
	 *  correspondences in the phantom during the calibration step.
	 *  Here, we use the distorted and undistorted coordinates generated
	 *  in the course of the distortion simulation.
	 */ 
	public void getLatticePoints (Grid2D distortedImage){
		
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		// step size
		// calculate the step size of the lattice points: fx and fy 
		fx = imageWidth/nx; //TODO
		fy = imageHeight/ny; //TODO
		
		// fill the distorted and undistorted lattice points 
		// with data from the given correspondences
		// matrix = number of rows (y) x number of columns (x)
		Xu = new SimpleMatrix(ny,nx);
		Yu = new SimpleMatrix(ny,nx);
		Xd = new SimpleMatrix(ny,nx);
		Yd = new SimpleMatrix(ny,nx);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){

				// sample the distorted and undistorted grid points at the lattice points
				  Xu.setElementValue(i, j, double(xprime.));//TODO: fill matrix Xu
				  Yu.setElementValue(i, j, fy);//TODO: fill matrix Yu
				  Xd.setElementValue(i, j, fx);//TODO: fill matrix Xd
				  Yd.setElementValue(i, j, fy)//TODO: fill matrix Yd
			}
		}
	}
	
	/** 2. Polynomial of degree d
	 * Polynomial of degree d -> (d-1): extrema (e.g., d=5: 4 extrema)
	 * d=0: constant (horizontal line with y-intercept a_0 -> f(x)=a_0)
	 * d=1: oblique line with y-intercept a_0 & slope a_1 -> f(x)=a_0 + a_1 x
	 * d=2: parabola
	 * d>=2: continuous non-linear curve
	 * ...
	 * d = 10 -> NumCoeff: 66 -> but only 64 lattice points are known (nx, ny = 8)
	 */
	
	public void calcPolynomial(int degree, SimpleMatrix Xd){
		
		// number of coefficients: numCoeff
		// (hint: this is NOT the total number of multiplications!)
		numCoeff = 0; //TODO
		
		// number of correspondences: numCorresp
		numCorresp =  0; //TODO
		
		// Printout of the used parameters
		System.out.println("Polynom of degree: " + degree);
		System.out.println("Number of Coefficients: " + numCoeff);
		System.out.println("Number of Correspondences: " + numCorresp);
		
	}
	
	/**
	 * 3. Create the matrix A
	 */
	
	public void computeMatrixA(int degree, int numCorresp, int numCoeff){
		
		A = new SimpleMatrix(numCorresp, numCoeff);
		if (numCorresp <= 0 && numCoeff <= 0)
			return;
		A.zeros();
		
		// Realign the grid matrix into a vector for easier access in the next step
		XuVector = new SimpleVector(numCorresp);
		YuVector = new SimpleVector(numCorresp);
		XdVector = new SimpleVector(numCorresp);
		YdVector = new SimpleVector(numCorresp);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){
				
				XuVector.setElementValue(i*ny + j, Xu.getElement(j, i));
				YuVector.setElementValue(i*ny + j, Yu.getElement(j, i));
				XdVector.setElementValue(i*ny + j, Xd.getElement(j, i));
				YdVector.setElementValue(i*ny + j, Yd.getElement(j, i));
			}
		}
		
		// Compute matrix A (coordinates from distorted image)
		for(int r = 0; r < numCorresp; r++){
			
			int cc = 0;
			
			for(int k = 0; k <= degree; k++){
				for(int l = 0; l <= (degree-k); l++){
					
					// TODO: fill matrix A
					cc++;
					
				}
			}
		}
	}
	
	public void computeDistortionCoeff(SimpleMatrix A, SimpleVector XuVector, SimpleVector YuVector){
		
		// Compute the pseudo-inverse of A with the help of the SVD (class: DecompositionSVD)
		svd = null; // TODO
	    A_pseudoinverse = null; // TODO
	  
		// Compute the distortion coefficients (solve for known corresponding undistorted points)
		u_vec = null;// TODO
		v_vec = null;// TODO
	}
	
	/**
	 * 4. Compute the distorted grid points (xDist, yDist) which are used to sample the
	 * distorted image to get the undistorted image
	 * (xprime,yprime) is the position in the undistorted image
	 * (xDist,yDist) is the position in the distorted (observed) X-ray image.
	 */
	public Grid2D computeDistortedGrid(Grid2D distortedImage, Grid2D grid_out, int degree){
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		xDist = new Grid2D(imageWidth,imageHeight);  
		yDist = new Grid2D(imageWidth,imageHeight); 
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float val1, val2; //variables Val1 and Val2 are used for intermediate computation of xDist and yDist respectively
				
				int cc = 0;
				
				for(int k = 0; k <= degree; k++){
					for(int l = 0; l <= degree - k; l++){
						
						val1 = 0;// TODO
						val2 = 0;// TODO
						
						// TODO: fill xDist
						// TODO: fill yDist
						
						cc++;
					}
				}
			}
		}
		
		float val; // variable for intermediate computations of undistorted image
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				// hint: consider the fact that the coordinate origin is in the center of the image
				val = 0;//TODO
				//TODO: fill grid_out
			}
		}
		
		return grid_out;
		
	}
	
	
	
	/**
	 * 
	 * end of the exercise
	 */	

	
	/**
	 * standard constructor
	 */
	public ExerciseGeoU(){
		
		this(0);
	}
		
	/**
	 * parameterized constructor for the ExerciseDPI object
	 * @param caseNo: select one of three images to test your undistortion method
	 */
	public ExerciseGeoU(int caseNo){
		
		switch (caseNo) {
		case 0:
			filename = "frame32.jpg";
			break;
		case 1:
			filename = "undistorted.jpg";
			break;
		case 2:
			filename = "frame90.jpg";
			break;
		default:
			filename = "frame32.jpg";
			break;
		}
		
		String imageDataLoc = System.getProperty("user.dir") + "/data/" + "/mipda/";
	
		originalImage = ImageUtil.wrapImagePlus(IJ.openImage(imageDataLoc + filename)).getSubGrid(0);
	}
	
	public void init(float a, float b, float d) {
		
		// Normalize intensity values to [0,1]
		float max = NumericPointwiseOperators.max(originalImage);
		float min = NumericPointwiseOperators.min(originalImage);
		
		for(int i = 0; i < originalImage.getWidth(); i++){
			for(int j = 0; j < originalImage.getHeight(); j++){
				
				float scaledValue = (originalImage.getAtIndex(i, j) - min) / (max-min);
				originalImage.setAtIndex(i, j, scaledValue);
			}
		}
		
		undistortedImage = new Grid2D(originalImage.getWidth(),originalImage.getHeight()); // initialization with zeros
		
		distortedImage = generateDistortedImage(originalImage,a,b,d);	
	}
	
	/**
	 * method to generate a distorted image
	 * An artificial distortion field is generated. With this field, 
	 * a distorted image is generated from the original image.
	 * Remark: coordinates of the latest distortion simulated are saved in class member variables
	 * @param inputImage: undistorted image on which distortion is simulated
	 * @param a: elliptic extent of the distortion in x-direction
	 * @param b: elliptic extent of the distortion in y-direction
	 * @param d: strength of the distortion
	 * @return: distorted image
	 */
    
	public Grid2D generateDistortedImage(Grid2D inputImage, float a, float b, float d){

		Grid2D grid = new Grid2D(inputImage);
		int imageWidth = grid.getWidth();
		int imageHeight = grid.getHeight();
		
		// generate grids to sample coordinates X and Y of the original image
		Grid2D X = new Grid2D(imageWidth,imageHeight); // x-coordinates with respect to origin in image center, spacing = 1 [unit]
		Grid2D Y = new Grid2D(imageWidth,imageHeight); // y-coordinates with respect to origin in image center, spacing = 1 [unit]
		
		float halfWidth = imageWidth / 2.0f;
		float halfHeight = imageHeight / 2.0f;
		
		for(int i = 0; i < X.getWidth(); i++){
			for(int j = 0; j < X.getHeight(); j++){
				
				X.setAtIndex(i, j, i - halfWidth + 0.5f); // assign pixel centers in x-direction
				Y.setAtIndex(i, j, j - halfHeight + 0.5f); // assign pixel center in y-direction
			}
		}
		
		// create an artificial elliptical distortion field R (additive field)
		Grid2D R = new Grid2D(imageWidth,imageHeight);

		for(int i = 0; i < R.getWidth(); i++){
			for(int j = 0; j < R.getHeight(); j++){
				
				// distortion gets stronger with the distance from the image center
				float r = d * (float)(Math.sqrt(
						Math.pow(X.getAtIndex(i, j)/(a*halfWidth),2)
						+ Math.pow(Y.getAtIndex(i, j)/(b*halfHeight),2)));
				R.setAtIndex(i, j, r);
			}
		}
		
		// shifting the positive range to half positive/half negative range
		float maxR = NumericPointwiseOperators.max(R);
		NumericPointwiseOperators.subtractBy(R, maxR * 0.5f);

		// create the distorted image coordinates:
		// distorted image coordinates = undistorted image points + artificial distortion field

		// distorted image coordinates Xd, Yd
		Grid2D Xd = new Grid2D(X);
		Grid2D Yd = new Grid2D(Y);
		
		NumericPointwiseOperators.addBy(Xd, R);
		NumericPointwiseOperators.addBy(Yd, R);
		
		// create the distorted image:
		// re-sample the original input image at the distorted image points (Xd,Yd) 
		// to create artificial distortion
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float distortedValue = InterpolationOperators.interpolateLinear(
						inputImage,
						Xd.getAtIndex(i, j) + halfWidth - 0.5f, // remember: coordinate origin was set to image center
						Yd.getAtIndex(i, j) + halfHeight - 0.5f);
				grid.setAtIndex(i, j, distortedValue);
			}
		}

		xprime = X;
		yprime = Y;
		x = Xd;
		y = Yd;
		
		return grid;	
	}	
	
	//getters for members
	// variables which are checked (DO NOT CHANGE!)
	
	public static int get_caseNo() {
		return caseNo;
	}
	
	public Grid2D get_originalImage() {
		return originalImage;
	}
	
	public Grid2D get_distortedImage() {
		return distortedImage;
	}
	
	public Grid2D get_undistortedImage() {
		return undistortedImage;
	}
	
	public int get_nx() {
		return nx;
	}
	
	public int get_ny() {
		return ny;
	}
	
	public float get_fx() {
		return fx;
	}
	
	public float get_fy() {
		return fy;
	}
	
	public SimpleMatrix get_Xu() {
		return Xu;
	}
	
	public SimpleMatrix get_Yu() {
		return Yu;
	}
	
	public SimpleMatrix get_Xd() {
		return Xd;
	}
	
	public SimpleMatrix get_Yd() {
		return Yd;
	}
	
	public int get_numCoeff() {
		return numCoeff;
	}
	
	public int get_numCorresp() {
		return numCorresp;
	}
	
	public SimpleMatrix get_A() {
		return A;
	}
	
	public DecompositionSVD get_svd() {
		return svd;
	}
	
	public SimpleMatrix get_A_pseudoinverse() {
		return A_pseudoinverse;
	}
	
	public SimpleVector get_u_vec() {
		return u_vec;
	}
	
	public SimpleVector get_v_vec() {
		return v_vec;
	}
	
	public SimpleVector get_XuVector() {
		return XuVector;
	}
	
	public SimpleVector get_YuVector() {
		return YuVector;
	}
	
	public SimpleVector get_XdVector() {
		return XdVector;
	}
	
	public SimpleVector get_YdVector() {
		return YdVector;
	}
	
	public Grid2D get_xDist() {
		return xDist;
	}
	
	public Grid2D get_yDist() {
		return yDist;
	}
	
	public Grid2D get_xprime() {
		return xprime;
	}
	
	public Grid2D get_yprime() {
		return yprime;
	}
	
	public Grid2D get_x() {
		return x;
	}
	
	public Grid2D get_y() {
		return y;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-15 23:55:24.242
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-15 23:55:24.243
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-15 23:55:39.788
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package edu.stanford.rsl.tutorial.mipda;

import edu.stanford.rsl.conrad.data.numeric.Grid2D;
import edu.stanford.rsl.conrad.data.numeric.NumericPointwiseOperators;
import edu.stanford.rsl.conrad.utils.ImageUtil;
//import edu.stanford.rsl.conrad.utils.VisualizationUtil;
import ij.IJ;
import ij.ImageJ;
import edu.stanford.rsl.conrad.data.numeric.InterpolationOperators;
//import edu.stanford.rsl.conrad.data.numeric.NumericGridOperator;
import edu.stanford.rsl.conrad.numerics.SimpleMatrix;
import edu.stanford.rsl.conrad.numerics.SimpleOperators;
import edu.stanford.rsl.conrad.numerics.SimpleVector;
import edu.stanford.rsl.conrad.numerics.DecompositionSVD;

/**
 * Geometric Undistortion
 * Programming exercise 1 for module "Defect Pixel Interpolation"
 * of the course "Medical Image Processing for Diagnostic Applications (MIPDA)"
 * @author Frank Schebesch, Ashwini Jadhav, Anna Gebhard, Mena Abdelmalek
 *
 */

public class ExerciseGeoU {

	final static int caseNo = 1; // choose 0, 1, or 2 for different test images

	final static float a = 0.6f; // a: spread among x-direction
	final static float b = 0.3f; // b: spread among y-direction
	final static float d = 5.0f; // d: d/2 value of distortion field at level set for (X/a)^2+(Y/b)^2=1
	
	String filename; // do not edit, choose a number in the main method instead
	Grid2D originalImage; // do not edit, read from filename when instantiating the object
	Grid2D distortedImage; // do not edit, generated in the main method
	Grid2D undistortedImage; // do not edit, member variable for the output image
	
	// number of lattice points
	final int nx = 8;//TODO: define the number of lattice point: nx (Positive number and less than 20)
	final int ny = 8;//TODO: define the number of lattice point: ny (Positive number and less than 20)
	
	float fx;
	float fy;
	SimpleMatrix Xu; 
	SimpleMatrix Yu;
	SimpleMatrix Xd;
	SimpleMatrix Yd;
	int numCoeff; 
	int numCorresp; 
	SimpleMatrix A;
	DecompositionSVD svd;
	SimpleMatrix A_pseudoinverse;
	SimpleVector u_vec;
	SimpleVector v_vec;
	SimpleVector XuVector;
	SimpleVector YuVector;
	SimpleVector XdVector;
	SimpleVector YdVector;
	Grid2D xDist;  
	Grid2D yDist;
	Grid2D xprime; // x-coordinates of point correspondences in the undistorted image
	Grid2D yprime; // y-coordinates of point correspondences in the undistorted image
	Grid2D x; // x-coordinates of point correspondences in the distorted image
	Grid2D y; // y-coordinates of point correspondences in the distorted image
	
	
	/** 
	 * main method
	 * Here you can choose the image, and set the distortion parameters
	 */
	public static void main(String[] args) {
		
		new ImageJ();
		
		// generate distorted image
		ExerciseGeoU exObj = new ExerciseGeoU(caseNo);
		exObj.init(a,b,d);
		
		// TASK: go to the method doImageUndistortion(...) and complete it 
		exObj.undistortedImage = exObj.doImageUndistortion(exObj.distortedImage);
		
		exObj.originalImage.show("Original Image");
		exObj.distortedImage.show("Distorted Image");
		exObj.undistortedImage.show("Undistorted Image");
		
		Grid2D differenceImage = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.originalImage, exObj.undistortedImage);
		
		differenceImage.show("Difference Original vs. Undistorted");
		
		Grid2D distortedVSundistorted = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.undistortedImage, exObj.distortedImage);
		
		distortedVSundistorted.show("Difference Undistorted vs. Distorted");
	}
	
	public Grid2D doImageUndistortion(Grid2D distortedImage){
		
		Grid2D grid = new Grid2D(distortedImage);
		
		// check if image distortion routine has been run
		if (distortedImage == null || undistortedImage == null
				|| xprime == null || yprime == null
				|| x == null || y == null) {
			
			System.err.println("Error in doImageUndistortion(): called before initialization of members.");
			return grid;
		}
		
		
		getLatticePoints(distortedImage);// There are TODOs here 
		
		
		int degree = 5; // polynomial's degree: 2,...,10
		calcPolynomial(degree, Xd);// There are TODOs here
		
		
		
		computeMatrixA(degree, numCorresp, numCoeff);// There are TODOs here
		
		
		computeDistortionCoeff(A, XuVector, YuVector);// There are TODOs here
		
		
		grid = computeDistortedGrid(distortedImage, grid, degree);// There are TODOs here
		
		return grid;
	}
	
	
	
	/** 1. Number of lattice points (this only works for symmetric images):
	 *  nx, ny feature points: usually provided by tracking point
	 *  correspondences in the phantom during the calibration step.
	 *  Here, we use the distorted and undistorted coordinates generated
	 *  in the course of the distortion simulation.
	 */ 
	public void getLatticePoints (Grid2D distortedImage){
		
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		// step size
		// calculate the step size of the lattice points: fx and fy 
		fx = imageWidth/nx; //TODO
		fy = imageHeight/ny; //TODO
		
		// fill the distorted and undistorted lattice points 
		// with data from the given correspondences
		// matrix = number of rows (y) x number of columns (x)
		Xu = new SimpleMatrix(ny,nx);
		Yu = new SimpleMatrix(ny,nx);
		Xd = new SimpleMatrix(ny,nx);
		Yd = new SimpleMatrix(ny,nx);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){

				// sample the distorted and undistorted grid points at the lattice points
				  Xu.setElementValue(i, j, double(xprime.getAtIndex(i + , j)));//TODO: fill matrix Xu
				  Yu.setElementValue(i, j, fy);//TODO: fill matrix Yu
				  Xd.setElementValue(i, j, fx);//TODO: fill matrix Xd
				  Yd.setElementValue(i, j, fy)//TODO: fill matrix Yd
			}
		}
	}
	
	/** 2. Polynomial of degree d
	 * Polynomial of degree d -> (d-1): extrema (e.g., d=5: 4 extrema)
	 * d=0: constant (horizontal line with y-intercept a_0 -> f(x)=a_0)
	 * d=1: oblique line with y-intercept a_0 & slope a_1 -> f(x)=a_0 + a_1 x
	 * d=2: parabola
	 * d>=2: continuous non-linear curve
	 * ...
	 * d = 10 -> NumCoeff: 66 -> but only 64 lattice points are known (nx, ny = 8)
	 */
	
	public void calcPolynomial(int degree, SimpleMatrix Xd){
		
		// number of coefficients: numCoeff
		// (hint: this is NOT the total number of multiplications!)
		numCoeff = 0; //TODO
		
		// number of correspondences: numCorresp
		numCorresp =  0; //TODO
		
		// Printout of the used parameters
		System.out.println("Polynom of degree: " + degree);
		System.out.println("Number of Coefficients: " + numCoeff);
		System.out.println("Number of Correspondences: " + numCorresp);
		
	}
	
	/**
	 * 3. Create the matrix A
	 */
	
	public void computeMatrixA(int degree, int numCorresp, int numCoeff){
		
		A = new SimpleMatrix(numCorresp, numCoeff);
		if (numCorresp <= 0 && numCoeff <= 0)
			return;
		A.zeros();
		
		// Realign the grid matrix into a vector for easier access in the next step
		XuVector = new SimpleVector(numCorresp);
		YuVector = new SimpleVector(numCorresp);
		XdVector = new SimpleVector(numCorresp);
		YdVector = new SimpleVector(numCorresp);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){
				
				XuVector.setElementValue(i*ny + j, Xu.getElement(j, i));
				YuVector.setElementValue(i*ny + j, Yu.getElement(j, i));
				XdVector.setElementValue(i*ny + j, Xd.getElement(j, i));
				YdVector.setElementValue(i*ny + j, Yd.getElement(j, i));
			}
		}
		
		// Compute matrix A (coordinates from distorted image)
		for(int r = 0; r < numCorresp; r++){
			
			int cc = 0;
			
			for(int k = 0; k <= degree; k++){
				for(int l = 0; l <= (degree-k); l++){
					
					// TODO: fill matrix A
					cc++;
					
				}
			}
		}
	}
	
	public void computeDistortionCoeff(SimpleMatrix A, SimpleVector XuVector, SimpleVector YuVector){
		
		// Compute the pseudo-inverse of A with the help of the SVD (class: DecompositionSVD)
		svd = null; // TODO
	    A_pseudoinverse = null; // TODO
	  
		// Compute the distortion coefficients (solve for known corresponding undistorted points)
		u_vec = null;// TODO
		v_vec = null;// TODO
	}
	
	/**
	 * 4. Compute the distorted grid points (xDist, yDist) which are used to sample the
	 * distorted image to get the undistorted image
	 * (xprime,yprime) is the position in the undistorted image
	 * (xDist,yDist) is the position in the distorted (observed) X-ray image.
	 */
	public Grid2D computeDistortedGrid(Grid2D distortedImage, Grid2D grid_out, int degree){
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		xDist = new Grid2D(imageWidth,imageHeight);  
		yDist = new Grid2D(imageWidth,imageHeight); 
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float val1, val2; //variables Val1 and Val2 are used for intermediate computation of xDist and yDist respectively
				
				int cc = 0;
				
				for(int k = 0; k <= degree; k++){
					for(int l = 0; l <= degree - k; l++){
						
						val1 = 0;// TODO
						val2 = 0;// TODO
						
						// TODO: fill xDist
						// TODO: fill yDist
						
						cc++;
					}
				}
			}
		}
		
		float val; // variable for intermediate computations of undistorted image
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				// hint: consider the fact that the coordinate origin is in the center of the image
				val = 0;//TODO
				//TODO: fill grid_out
			}
		}
		
		return grid_out;
		
	}
	
	
	
	/**
	 * 
	 * end of the exercise
	 */	

	
	/**
	 * standard constructor
	 */
	public ExerciseGeoU(){
		
		this(0);
	}
		
	/**
	 * parameterized constructor for the ExerciseDPI object
	 * @param caseNo: select one of three images to test your undistortion method
	 */
	public ExerciseGeoU(int caseNo){
		
		switch (caseNo) {
		case 0:
			filename = "frame32.jpg";
			break;
		case 1:
			filename = "undistorted.jpg";
			break;
		case 2:
			filename = "frame90.jpg";
			break;
		default:
			filename = "frame32.jpg";
			break;
		}
		
		String imageDataLoc = System.getProperty("user.dir") + "/data/" + "/mipda/";
	
		originalImage = ImageUtil.wrapImagePlus(IJ.openImage(imageDataLoc + filename)).getSubGrid(0);
	}
	
	public void init(float a, float b, float d) {
		
		// Normalize intensity values to [0,1]
		float max = NumericPointwiseOperators.max(originalImage);
		float min = NumericPointwiseOperators.min(originalImage);
		
		for(int i = 0; i < originalImage.getWidth(); i++){
			for(int j = 0; j < originalImage.getHeight(); j++){
				
				float scaledValue = (originalImage.getAtIndex(i, j) - min) / (max-min);
				originalImage.setAtIndex(i, j, scaledValue);
			}
		}
		
		undistortedImage = new Grid2D(originalImage.getWidth(),originalImage.getHeight()); // initialization with zeros
		
		distortedImage = generateDistortedImage(originalImage,a,b,d);	
	}
	
	/**
	 * method to generate a distorted image
	 * An artificial distortion field is generated. With this field, 
	 * a distorted image is generated from the original image.
	 * Remark: coordinates of the latest distortion simulated are saved in class member variables
	 * @param inputImage: undistorted image on which distortion is simulated
	 * @param a: elliptic extent of the distortion in x-direction
	 * @param b: elliptic extent of the distortion in y-direction
	 * @param d: strength of the distortion
	 * @return: distorted image
	 */
    
	public Grid2D generateDistortedImage(Grid2D inputImage, float a, float b, float d){

		Grid2D grid = new Grid2D(inputImage);
		int imageWidth = grid.getWidth();
		int imageHeight = grid.getHeight();
		
		// generate grids to sample coordinates X and Y of the original image
		Grid2D X = new Grid2D(imageWidth,imageHeight); // x-coordinates with respect to origin in image center, spacing = 1 [unit]
		Grid2D Y = new Grid2D(imageWidth,imageHeight); // y-coordinates with respect to origin in image center, spacing = 1 [unit]
		
		float halfWidth = imageWidth / 2.0f;
		float halfHeight = imageHeight / 2.0f;
		
		for(int i = 0; i < X.getWidth(); i++){
			for(int j = 0; j < X.getHeight(); j++){
				
				X.setAtIndex(i, j, i - halfWidth + 0.5f); // assign pixel centers in x-direction
				Y.setAtIndex(i, j, j - halfHeight + 0.5f); // assign pixel center in y-direction
			}
		}
		
		// create an artificial elliptical distortion field R (additive field)
		Grid2D R = new Grid2D(imageWidth,imageHeight);

		for(int i = 0; i < R.getWidth(); i++){
			for(int j = 0; j < R.getHeight(); j++){
				
				// distortion gets stronger with the distance from the image center
				float r = d * (float)(Math.sqrt(
						Math.pow(X.getAtIndex(i, j)/(a*halfWidth),2)
						+ Math.pow(Y.getAtIndex(i, j)/(b*halfHeight),2)));
				R.setAtIndex(i, j, r);
			}
		}
		
		// shifting the positive range to half positive/half negative range
		float maxR = NumericPointwiseOperators.max(R);
		NumericPointwiseOperators.subtractBy(R, maxR * 0.5f);

		// create the distorted image coordinates:
		// distorted image coordinates = undistorted image points + artificial distortion field

		// distorted image coordinates Xd, Yd
		Grid2D Xd = new Grid2D(X);
		Grid2D Yd = new Grid2D(Y);
		
		NumericPointwiseOperators.addBy(Xd, R);
		NumericPointwiseOperators.addBy(Yd, R);
		
		// create the distorted image:
		// re-sample the original input image at the distorted image points (Xd,Yd) 
		// to create artificial distortion
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float distortedValue = InterpolationOperators.interpolateLinear(
						inputImage,
						Xd.getAtIndex(i, j) + halfWidth - 0.5f, // remember: coordinate origin was set to image center
						Yd.getAtIndex(i, j) + halfHeight - 0.5f);
				grid.setAtIndex(i, j, distortedValue);
			}
		}

		xprime = X;
		yprime = Y;
		x = Xd;
		y = Yd;
		
		return grid;	
	}	
	
	//getters for members
	// variables which are checked (DO NOT CHANGE!)
	
	public static int get_caseNo() {
		return caseNo;
	}
	
	public Grid2D get_originalImage() {
		return originalImage;
	}
	
	public Grid2D get_distortedImage() {
		return distortedImage;
	}
	
	public Grid2D get_undistortedImage() {
		return undistortedImage;
	}
	
	public int get_nx() {
		return nx;
	}
	
	public int get_ny() {
		return ny;
	}
	
	public float get_fx() {
		return fx;
	}
	
	public float get_fy() {
		return fy;
	}
	
	public SimpleMatrix get_Xu() {
		return Xu;
	}
	
	public SimpleMatrix get_Yu() {
		return Yu;
	}
	
	public SimpleMatrix get_Xd() {
		return Xd;
	}
	
	public SimpleMatrix get_Yd() {
		return Yd;
	}
	
	public int get_numCoeff() {
		return numCoeff;
	}
	
	public int get_numCorresp() {
		return numCorresp;
	}
	
	public SimpleMatrix get_A() {
		return A;
	}
	
	public DecompositionSVD get_svd() {
		return svd;
	}
	
	public SimpleMatrix get_A_pseudoinverse() {
		return A_pseudoinverse;
	}
	
	public SimpleVector get_u_vec() {
		return u_vec;
	}
	
	public SimpleVector get_v_vec() {
		return v_vec;
	}
	
	public SimpleVector get_XuVector() {
		return XuVector;
	}
	
	public SimpleVector get_YuVector() {
		return YuVector;
	}
	
	public SimpleVector get_XdVector() {
		return XdVector;
	}
	
	public SimpleVector get_YdVector() {
		return YdVector;
	}
	
	public Grid2D get_xDist() {
		return xDist;
	}
	
	public Grid2D get_yDist() {
		return yDist;
	}
	
	public Grid2D get_xprime() {
		return xprime;
	}
	
	public Grid2D get_yprime() {
		return yprime;
	}
	
	public Grid2D get_x() {
		return x;
	}
	
	public Grid2D get_y() {
		return y;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-15 23:55:39.789
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-15 23:55:39.790
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-15 23:55:39.987
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package edu.stanford.rsl.tutorial.mipda;

import edu.stanford.rsl.conrad.data.numeric.Grid2D;
import edu.stanford.rsl.conrad.data.numeric.NumericPointwiseOperators;
import edu.stanford.rsl.conrad.utils.ImageUtil;
//import edu.stanford.rsl.conrad.utils.VisualizationUtil;
import ij.IJ;
import ij.ImageJ;
import edu.stanford.rsl.conrad.data.numeric.InterpolationOperators;
//import edu.stanford.rsl.conrad.data.numeric.NumericGridOperator;
import edu.stanford.rsl.conrad.numerics.SimpleMatrix;
import edu.stanford.rsl.conrad.numerics.SimpleOperators;
import edu.stanford.rsl.conrad.numerics.SimpleVector;
import edu.stanford.rsl.conrad.numerics.DecompositionSVD;

/**
 * Geometric Undistortion
 * Programming exercise 1 for module "Defect Pixel Interpolation"
 * of the course "Medical Image Processing for Diagnostic Applications (MIPDA)"
 * @author Frank Schebesch, Ashwini Jadhav, Anna Gebhard, Mena Abdelmalek
 *
 */

public class ExerciseGeoU {

	final static int caseNo = 1; // choose 0, 1, or 2 for different test images

	final static float a = 0.6f; // a: spread among x-direction
	final static float b = 0.3f; // b: spread among y-direction
	final static float d = 5.0f; // d: d/2 value of distortion field at level set for (X/a)^2+(Y/b)^2=1
	
	String filename; // do not edit, choose a number in the main method instead
	Grid2D originalImage; // do not edit, read from filename when instantiating the object
	Grid2D distortedImage; // do not edit, generated in the main method
	Grid2D undistortedImage; // do not edit, member variable for the output image
	
	// number of lattice points
	final int nx = 8;//TODO: define the number of lattice point: nx (Positive number and less than 20)
	final int ny = 8;//TODO: define the number of lattice point: ny (Positive number and less than 20)
	
	float fx;
	float fy;
	SimpleMatrix Xu; 
	SimpleMatrix Yu;
	SimpleMatrix Xd;
	SimpleMatrix Yd;
	int numCoeff; 
	int numCorresp; 
	SimpleMatrix A;
	DecompositionSVD svd;
	SimpleMatrix A_pseudoinverse;
	SimpleVector u_vec;
	SimpleVector v_vec;
	SimpleVector XuVector;
	SimpleVector YuVector;
	SimpleVector XdVector;
	SimpleVector YdVector;
	Grid2D xDist;  
	Grid2D yDist;
	Grid2D xprime; // x-coordinates of point correspondences in the undistorted image
	Grid2D yprime; // y-coordinates of point correspondences in the undistorted image
	Grid2D x; // x-coordinates of point correspondences in the distorted image
	Grid2D y; // y-coordinates of point correspondences in the distorted image
	
	
	/** 
	 * main method
	 * Here you can choose the image, and set the distortion parameters
	 */
	public static void main(String[] args) {
		
		new ImageJ();
		
		// generate distorted image
		ExerciseGeoU exObj = new ExerciseGeoU(caseNo);
		exObj.init(a,b,d);
		
		// TASK: go to the method doImageUndistortion(...) and complete it 
		exObj.undistortedImage = exObj.doImageUndistortion(exObj.distortedImage);
		
		exObj.originalImage.show("Original Image");
		exObj.distortedImage.show("Distorted Image");
		exObj.undistortedImage.show("Undistorted Image");
		
		Grid2D differenceImage = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.originalImage, exObj.undistortedImage);
		
		differenceImage.show("Difference Original vs. Undistorted");
		
		Grid2D distortedVSundistorted = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.undistortedImage, exObj.distortedImage);
		
		distortedVSundistorted.show("Difference Undistorted vs. Distorted");
	}
	
	public Grid2D doImageUndistortion(Grid2D distortedImage){
		
		Grid2D grid = new Grid2D(distortedImage);
		
		// check if image distortion routine has been run
		if (distortedImage == null || undistortedImage == null
				|| xprime == null || yprime == null
				|| x == null || y == null) {
			
			System.err.println("Error in doImageUndistortion(): called before initialization of members.");
			return grid;
		}
		
		
		getLatticePoints(distortedImage);// There are TODOs here 
		
		
		int degree = 5; // polynomial's degree: 2,...,10
		calcPolynomial(degree, Xd);// There are TODOs here
		
		
		
		computeMatrixA(degree, numCorresp, numCoeff);// There are TODOs here
		
		
		computeDistortionCoeff(A, XuVector, YuVector);// There are TODOs here
		
		
		grid = computeDistortedGrid(distortedImage, grid, degree);// There are TODOs here
		
		return grid;
	}
	
	
	
	/** 1. Number of lattice points (this only works for symmetric images):
	 *  nx, ny feature points: usually provided by tracking point
	 *  correspondences in the phantom during the calibration step.
	 *  Here, we use the distorted and undistorted coordinates generated
	 *  in the course of the distortion simulation.
	 */ 
	public void getLatticePoints (Grid2D distortedImage){
		
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		// step size
		// calculate the step size of the lattice points: fx and fy 
		fx = imageWidth/nx; //TODO
		fy = imageHeight/ny; //TODO
		
		// fill the distorted and undistorted lattice points 
		// with data from the given correspondences
		// matrix = number of rows (y) x number of columns (x)
		Xu = new SimpleMatrix(ny,nx);
		Yu = new SimpleMatrix(ny,nx);
		Xd = new SimpleMatrix(ny,nx);
		Yd = new SimpleMatrix(ny,nx);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){

				// sample the distorted and undistorted grid points at the lattice points
				  Xu.setElementValue(i, j, double(xprime.getAtIndex(i + , j)));//TODO: fill matrix Xu
				  Yu.setElementValue(i, j, fy);//TODO: fill matrix Yu
				  Xd.setElementValue(i, j, fx);//TODO: fill matrix Xd
				  Yd.setElementValue(i, j, fy)//TODO: fill matrix Yd
			}
		}
	}
	
	/** 2. Polynomial of degree d
	 * Polynomial of degree d -> (d-1): extrema (e.g., d=5: 4 extrema)
	 * d=0: constant (horizontal line with y-intercept a_0 -> f(x)=a_0)
	 * d=1: oblique line with y-intercept a_0 & slope a_1 -> f(x)=a_0 + a_1 x
	 * d=2: parabola
	 * d>=2: continuous non-linear curve
	 * ...
	 * d = 10 -> NumCoeff: 66 -> but only 64 lattice points are known (nx, ny = 8)
	 */
	
	public void calcPolynomial(int degree, SimpleMatrix Xd){
		
		// number of coefficients: numCoeff
		// (hint: this is NOT the total number of multiplications!)
		numCoeff = 0; //TODO
		
		// number of correspondences: numCorresp
		numCorresp =  0; //TODO
		
		// Printout of the used parameters
		System.out.println("Polynom of degree: " + degree);
		System.out.println("Number of Coefficients: " + numCoeff);
		System.out.println("Number of Correspondences: " + numCorresp);
		
	}
	
	/**
	 * 3. Create the matrix A
	 */
	
	public void computeMatrixA(int degree, int numCorresp, int numCoeff){
		
		A = new SimpleMatrix(numCorresp, numCoeff);
		if (numCorresp <= 0 && numCoeff <= 0)
			return;
		A.zeros();
		
		// Realign the grid matrix into a vector for easier access in the next step
		XuVector = new SimpleVector(numCorresp);
		YuVector = new SimpleVector(numCorresp);
		XdVector = new SimpleVector(numCorresp);
		YdVector = new SimpleVector(numCorresp);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){
				
				XuVector.setElementValue(i*ny + j, Xu.getElement(j, i));
				YuVector.setElementValue(i*ny + j, Yu.getElement(j, i));
				XdVector.setElementValue(i*ny + j, Xd.getElement(j, i));
				YdVector.setElementValue(i*ny + j, Yd.getElement(j, i));
			}
		}
		
		// Compute matrix A (coordinates from distorted image)
		for(int r = 0; r < numCorresp; r++){
			
			int cc = 0;
			
			for(int k = 0; k <= degree; k++){
				for(int l = 0; l <= (degree-k); l++){
					
					// TODO: fill matrix A
					cc++;
					
				}
			}
		}
	}
	
	public void computeDistortionCoeff(SimpleMatrix A, SimpleVector XuVector, SimpleVector YuVector){
		
		// Compute the pseudo-inverse of A with the help of the SVD (class: DecompositionSVD)
		svd = null; // TODO
	    A_pseudoinverse = null; // TODO
	  
		// Compute the distortion coefficients (solve for known corresponding undistorted points)
		u_vec = null;// TODO
		v_vec = null;// TODO
	}
	
	/**
	 * 4. Compute the distorted grid points (xDist, yDist) which are used to sample the
	 * distorted image to get the undistorted image
	 * (xprime,yprime) is the position in the undistorted image
	 * (xDist,yDist) is the position in the distorted (observed) X-ray image.
	 */
	public Grid2D computeDistortedGrid(Grid2D distortedImage, Grid2D grid_out, int degree){
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		xDist = new Grid2D(imageWidth,imageHeight);  
		yDist = new Grid2D(imageWidth,imageHeight); 
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float val1, val2; //variables Val1 and Val2 are used for intermediate computation of xDist and yDist respectively
				
				int cc = 0;
				
				for(int k = 0; k <= degree; k++){
					for(int l = 0; l <= degree - k; l++){
						
						val1 = 0;// TODO
						val2 = 0;// TODO
						
						// TODO: fill xDist
						// TODO: fill yDist
						
						cc++;
					}
				}
			}
		}
		
		float val; // variable for intermediate computations of undistorted image
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				// hint: consider the fact that the coordinate origin is in the center of the image
				val = 0;//TODO
				//TODO: fill grid_out
			}
		}
		
		return grid_out;
		
	}
	
	
	
	/**
	 * 
	 * end of the exercise
	 */	

	
	/**
	 * standard constructor
	 */
	public ExerciseGeoU(){
		
		this(0);
	}
		
	/**
	 * parameterized constructor for the ExerciseDPI object
	 * @param caseNo: select one of three images to test your undistortion method
	 */
	public ExerciseGeoU(int caseNo){
		
		switch (caseNo) {
		case 0:
			filename = "frame32.jpg";
			break;
		case 1:
			filename = "undistorted.jpg";
			break;
		case 2:
			filename = "frame90.jpg";
			break;
		default:
			filename = "frame32.jpg";
			break;
		}
		
		String imageDataLoc = System.getProperty("user.dir") + "/data/" + "/mipda/";
	
		originalImage = ImageUtil.wrapImagePlus(IJ.openImage(imageDataLoc + filename)).getSubGrid(0);
	}
	
	public void init(float a, float b, float d) {
		
		// Normalize intensity values to [0,1]
		float max = NumericPointwiseOperators.max(originalImage);
		float min = NumericPointwiseOperators.min(originalImage);
		
		for(int i = 0; i < originalImage.getWidth(); i++){
			for(int j = 0; j < originalImage.getHeight(); j++){
				
				float scaledValue = (originalImage.getAtIndex(i, j) - min) / (max-min);
				originalImage.setAtIndex(i, j, scaledValue);
			}
		}
		
		undistortedImage = new Grid2D(originalImage.getWidth(),originalImage.getHeight()); // initialization with zeros
		
		distortedImage = generateDistortedImage(originalImage,a,b,d);	
	}
	
	/**
	 * method to generate a distorted image
	 * An artificial distortion field is generated. With this field, 
	 * a distorted image is generated from the original image.
	 * Remark: coordinates of the latest distortion simulated are saved in class member variables
	 * @param inputImage: undistorted image on which distortion is simulated
	 * @param a: elliptic extent of the distortion in x-direction
	 * @param b: elliptic extent of the distortion in y-direction
	 * @param d: strength of the distortion
	 * @return: distorted image
	 */
    
	public Grid2D generateDistortedImage(Grid2D inputImage, float a, float b, float d){

		Grid2D grid = new Grid2D(inputImage);
		int imageWidth = grid.getWidth();
		int imageHeight = grid.getHeight();
		
		// generate grids to sample coordinates X and Y of the original image
		Grid2D X = new Grid2D(imageWidth,imageHeight); // x-coordinates with respect to origin in image center, spacing = 1 [unit]
		Grid2D Y = new Grid2D(imageWidth,imageHeight); // y-coordinates with respect to origin in image center, spacing = 1 [unit]
		
		float halfWidth = imageWidth / 2.0f;
		float halfHeight = imageHeight / 2.0f;
		
		for(int i = 0; i < X.getWidth(); i++){
			for(int j = 0; j < X.getHeight(); j++){
				
				X.setAtIndex(i, j, i - halfWidth + 0.5f); // assign pixel centers in x-direction
				Y.setAtIndex(i, j, j - halfHeight + 0.5f); // assign pixel center in y-direction
			}
		}
		
		// create an artificial elliptical distortion field R (additive field)
		Grid2D R = new Grid2D(imageWidth,imageHeight);

		for(int i = 0; i < R.getWidth(); i++){
			for(int j = 0; j < R.getHeight(); j++){
				
				// distortion gets stronger with the distance from the image center
				float r = d * (float)(Math.sqrt(
						Math.pow(X.getAtIndex(i, j)/(a*halfWidth),2)
						+ Math.pow(Y.getAtIndex(i, j)/(b*halfHeight),2)));
				R.setAtIndex(i, j, r);
			}
		}
		
		// shifting the positive range to half positive/half negative range
		float maxR = NumericPointwiseOperators.max(R);
		NumericPointwiseOperators.subtractBy(R, maxR * 0.5f);

		// create the distorted image coordinates:
		// distorted image coordinates = undistorted image points + artificial distortion field

		// distorted image coordinates Xd, Yd
		Grid2D Xd = new Grid2D(X);
		Grid2D Yd = new Grid2D(Y);
		
		NumericPointwiseOperators.addBy(Xd, R);
		NumericPointwiseOperators.addBy(Yd, R);
		
		// create the distorted image:
		// re-sample the original input image at the distorted image points (Xd,Yd) 
		// to create artificial distortion
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float distortedValue = InterpolationOperators.interpolateLinear(
						inputImage,
						Xd.getAtIndex(i, j) + halfWidth - 0.5f, // remember: coordinate origin was set to image center
						Yd.getAtIndex(i, j) + halfHeight - 0.5f);
				grid.setAtIndex(i, j, distortedValue);
			}
		}

		xprime = X;
		yprime = Y;
		x = Xd;
		y = Yd;
		
		return grid;	
	}	
	
	//getters for members
	// variables which are checked (DO NOT CHANGE!)
	
	public static int get_caseNo() {
		return caseNo;
	}
	
	public Grid2D get_originalImage() {
		return originalImage;
	}
	
	public Grid2D get_distortedImage() {
		return distortedImage;
	}
	
	public Grid2D get_undistortedImage() {
		return undistortedImage;
	}
	
	public int get_nx() {
		return nx;
	}
	
	public int get_ny() {
		return ny;
	}
	
	public float get_fx() {
		return fx;
	}
	
	public float get_fy() {
		return fy;
	}
	
	public SimpleMatrix get_Xu() {
		return Xu;
	}
	
	public SimpleMatrix get_Yu() {
		return Yu;
	}
	
	public SimpleMatrix get_Xd() {
		return Xd;
	}
	
	public SimpleMatrix get_Yd() {
		return Yd;
	}
	
	public int get_numCoeff() {
		return numCoeff;
	}
	
	public int get_numCorresp() {
		return numCorresp;
	}
	
	public SimpleMatrix get_A() {
		return A;
	}
	
	public DecompositionSVD get_svd() {
		return svd;
	}
	
	public SimpleMatrix get_A_pseudoinverse() {
		return A_pseudoinverse;
	}
	
	public SimpleVector get_u_vec() {
		return u_vec;
	}
	
	public SimpleVector get_v_vec() {
		return v_vec;
	}
	
	public SimpleVector get_XuVector() {
		return XuVector;
	}
	
	public SimpleVector get_YuVector() {
		return YuVector;
	}
	
	public SimpleVector get_XdVector() {
		return XdVector;
	}
	
	public SimpleVector get_YdVector() {
		return YdVector;
	}
	
	public Grid2D get_xDist() {
		return xDist;
	}
	
	public Grid2D get_yDist() {
		return yDist;
	}
	
	public Grid2D get_xprime() {
		return xprime;
	}
	
	public Grid2D get_yprime() {
		return yprime;
	}
	
	public Grid2D get_x() {
		return x;
	}
	
	public Grid2D get_y() {
		return y;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-15 23:55:39.988
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-15 23:55:39.989
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-15 23:56:34.934
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package edu.stanford.rsl.tutorial.mipda;

import edu.stanford.rsl.conrad.data.numeric.Grid2D;
import edu.stanford.rsl.conrad.data.numeric.NumericPointwiseOperators;
import edu.stanford.rsl.conrad.utils.ImageUtil;
//import edu.stanford.rsl.conrad.utils.VisualizationUtil;
import ij.IJ;
import ij.ImageJ;
import edu.stanford.rsl.conrad.data.numeric.InterpolationOperators;
//import edu.stanford.rsl.conrad.data.numeric.NumericGridOperator;
import edu.stanford.rsl.conrad.numerics.SimpleMatrix;
import edu.stanford.rsl.conrad.numerics.SimpleOperators;
import edu.stanford.rsl.conrad.numerics.SimpleVector;
import edu.stanford.rsl.conrad.numerics.DecompositionSVD;

/**
 * Geometric Undistortion
 * Programming exercise 1 for module "Defect Pixel Interpolation"
 * of the course "Medical Image Processing for Diagnostic Applications (MIPDA)"
 * @author Frank Schebesch, Ashwini Jadhav, Anna Gebhard, Mena Abdelmalek
 *
 */

public class ExerciseGeoU {

	final static int caseNo = 1; // choose 0, 1, or 2 for different test images

	final static float a = 0.6f; // a: spread among x-direction
	final static float b = 0.3f; // b: spread among y-direction
	final static float d = 5.0f; // d: d/2 value of distortion field at level set for (X/a)^2+(Y/b)^2=1
	
	String filename; // do not edit, choose a number in the main method instead
	Grid2D originalImage; // do not edit, read from filename when instantiating the object
	Grid2D distortedImage; // do not edit, generated in the main method
	Grid2D undistortedImage; // do not edit, member variable for the output image
	
	// number of lattice points
	final int nx = 8;//TODO: define the number of lattice point: nx (Positive number and less than 20)
	final int ny = 8;//TODO: define the number of lattice point: ny (Positive number and less than 20)
	
	float fx;
	float fy;
	SimpleMatrix Xu; 
	SimpleMatrix Yu;
	SimpleMatrix Xd;
	SimpleMatrix Yd;
	int numCoeff; 
	int numCorresp; 
	SimpleMatrix A;
	DecompositionSVD svd;
	SimpleMatrix A_pseudoinverse;
	SimpleVector u_vec;
	SimpleVector v_vec;
	SimpleVector XuVector;
	SimpleVector YuVector;
	SimpleVector XdVector;
	SimpleVector YdVector;
	Grid2D xDist;  
	Grid2D yDist;
	Grid2D xprime; // x-coordinates of point correspondences in the undistorted image
	Grid2D yprime; // y-coordinates of point correspondences in the undistorted image
	Grid2D x; // x-coordinates of point correspondences in the distorted image
	Grid2D y; // y-coordinates of point correspondences in the distorted image
	
	
	/** 
	 * main method
	 * Here you can choose the image, and set the distortion parameters
	 */
	public static void main(String[] args) {
		
		new ImageJ();
		
		// generate distorted image
		ExerciseGeoU exObj = new ExerciseGeoU(caseNo);
		exObj.init(a,b,d);
		
		// TASK: go to the method doImageUndistortion(...) and complete it 
		exObj.undistortedImage = exObj.doImageUndistortion(exObj.distortedImage);
		
		exObj.originalImage.show("Original Image");
		exObj.distortedImage.show("Distorted Image");
		exObj.undistortedImage.show("Undistorted Image");
		
		Grid2D differenceImage = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.originalImage, exObj.undistortedImage);
		
		differenceImage.show("Difference Original vs. Undistorted");
		
		Grid2D distortedVSundistorted = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.undistortedImage, exObj.distortedImage);
		
		distortedVSundistorted.show("Difference Undistorted vs. Distorted");
	}
	
	public Grid2D doImageUndistortion(Grid2D distortedImage){
		
		Grid2D grid = new Grid2D(distortedImage);
		
		// check if image distortion routine has been run
		if (distortedImage == null || undistortedImage == null
				|| xprime == null || yprime == null
				|| x == null || y == null) {
			
			System.err.println("Error in doImageUndistortion(): called before initialization of members.");
			return grid;
		}
		
		
		getLatticePoints(distortedImage);// There are TODOs here 
		
		
		int degree = 5; // polynomial's degree: 2,...,10
		calcPolynomial(degree, Xd);// There are TODOs here
		
		
		
		computeMatrixA(degree, numCorresp, numCoeff);// There are TODOs here
		
		
		computeDistortionCoeff(A, XuVector, YuVector);// There are TODOs here
		
		
		grid = computeDistortedGrid(distortedImage, grid, degree);// There are TODOs here
		
		return grid;
	}
	
	
	
	/** 1. Number of lattice points (this only works for symmetric images):
	 *  nx, ny feature points: usually provided by tracking point
	 *  correspondences in the phantom during the calibration step.
	 *  Here, we use the distorted and undistorted coordinates generated
	 *  in the course of the distortion simulation.
	 */ 
	public void getLatticePoints (Grid2D distortedImage){
		
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		// step size
		// calculate the step size of the lattice points: fx and fy 
		fx = imageWidth/nx; //TODO
		fy = imageHeight/ny; //TODO
		
		// fill the distorted and undistorted lattice points 
		// with data from the given correspondences
		// matrix = number of rows (y) x number of columns (x)
		Xu = new SimpleMatrix(ny,nx);
		Yu = new SimpleMatrix(ny,nx);
		Xd = new SimpleMatrix(ny,nx);
		Yd = new SimpleMatrix(ny,nx);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){

				// sample the distorted and undistorted grid points at the lattice points
				  Xu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx, j + fy)));//TODO: fill matrix Xu
				  Yu.setElementValue(i, j, fy);//TODO: fill matrix Yu
				  Xd.setElementValue(i, j, fx);//TODO: fill matrix Xd
				  Yd.setElementValue(i, j, fy)//TODO: fill matrix Yd
			}
		}
	}
	
	/** 2. Polynomial of degree d
	 * Polynomial of degree d -> (d-1): extrema (e.g., d=5: 4 extrema)
	 * d=0: constant (horizontal line with y-intercept a_0 -> f(x)=a_0)
	 * d=1: oblique line with y-intercept a_0 & slope a_1 -> f(x)=a_0 + a_1 x
	 * d=2: parabola
	 * d>=2: continuous non-linear curve
	 * ...
	 * d = 10 -> NumCoeff: 66 -> but only 64 lattice points are known (nx, ny = 8)
	 */
	
	public void calcPolynomial(int degree, SimpleMatrix Xd){
		
		// number of coefficients: numCoeff
		// (hint: this is NOT the total number of multiplications!)
		numCoeff = 0; //TODO
		
		// number of correspondences: numCorresp
		numCorresp =  0; //TODO
		
		// Printout of the used parameters
		System.out.println("Polynom of degree: " + degree);
		System.out.println("Number of Coefficients: " + numCoeff);
		System.out.println("Number of Correspondences: " + numCorresp);
		
	}
	
	/**
	 * 3. Create the matrix A
	 */
	
	public void computeMatrixA(int degree, int numCorresp, int numCoeff){
		
		A = new SimpleMatrix(numCorresp, numCoeff);
		if (numCorresp <= 0 && numCoeff <= 0)
			return;
		A.zeros();
		
		// Realign the grid matrix into a vector for easier access in the next step
		XuVector = new SimpleVector(numCorresp);
		YuVector = new SimpleVector(numCorresp);
		XdVector = new SimpleVector(numCorresp);
		YdVector = new SimpleVector(numCorresp);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){
				
				XuVector.setElementValue(i*ny + j, Xu.getElement(j, i));
				YuVector.setElementValue(i*ny + j, Yu.getElement(j, i));
				XdVector.setElementValue(i*ny + j, Xd.getElement(j, i));
				YdVector.setElementValue(i*ny + j, Yd.getElement(j, i));
			}
		}
		
		// Compute matrix A (coordinates from distorted image)
		for(int r = 0; r < numCorresp; r++){
			
			int cc = 0;
			
			for(int k = 0; k <= degree; k++){
				for(int l = 0; l <= (degree-k); l++){
					
					// TODO: fill matrix A
					cc++;
					
				}
			}
		}
	}
	
	public void computeDistortionCoeff(SimpleMatrix A, SimpleVector XuVector, SimpleVector YuVector){
		
		// Compute the pseudo-inverse of A with the help of the SVD (class: DecompositionSVD)
		svd = null; // TODO
	    A_pseudoinverse = null; // TODO
	  
		// Compute the distortion coefficients (solve for known corresponding undistorted points)
		u_vec = null;// TODO
		v_vec = null;// TODO
	}
	
	/**
	 * 4. Compute the distorted grid points (xDist, yDist) which are used to sample the
	 * distorted image to get the undistorted image
	 * (xprime,yprime) is the position in the undistorted image
	 * (xDist,yDist) is the position in the distorted (observed) X-ray image.
	 */
	public Grid2D computeDistortedGrid(Grid2D distortedImage, Grid2D grid_out, int degree){
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		xDist = new Grid2D(imageWidth,imageHeight);  
		yDist = new Grid2D(imageWidth,imageHeight); 
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float val1, val2; //variables Val1 and Val2 are used for intermediate computation of xDist and yDist respectively
				
				int cc = 0;
				
				for(int k = 0; k <= degree; k++){
					for(int l = 0; l <= degree - k; l++){
						
						val1 = 0;// TODO
						val2 = 0;// TODO
						
						// TODO: fill xDist
						// TODO: fill yDist
						
						cc++;
					}
				}
			}
		}
		
		float val; // variable for intermediate computations of undistorted image
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				// hint: consider the fact that the coordinate origin is in the center of the image
				val = 0;//TODO
				//TODO: fill grid_out
			}
		}
		
		return grid_out;
		
	}
	
	
	
	/**
	 * 
	 * end of the exercise
	 */	

	
	/**
	 * standard constructor
	 */
	public ExerciseGeoU(){
		
		this(0);
	}
		
	/**
	 * parameterized constructor for the ExerciseDPI object
	 * @param caseNo: select one of three images to test your undistortion method
	 */
	public ExerciseGeoU(int caseNo){
		
		switch (caseNo) {
		case 0:
			filename = "frame32.jpg";
			break;
		case 1:
			filename = "undistorted.jpg";
			break;
		case 2:
			filename = "frame90.jpg";
			break;
		default:
			filename = "frame32.jpg";
			break;
		}
		
		String imageDataLoc = System.getProperty("user.dir") + "/data/" + "/mipda/";
	
		originalImage = ImageUtil.wrapImagePlus(IJ.openImage(imageDataLoc + filename)).getSubGrid(0);
	}
	
	public void init(float a, float b, float d) {
		
		// Normalize intensity values to [0,1]
		float max = NumericPointwiseOperators.max(originalImage);
		float min = NumericPointwiseOperators.min(originalImage);
		
		for(int i = 0; i < originalImage.getWidth(); i++){
			for(int j = 0; j < originalImage.getHeight(); j++){
				
				float scaledValue = (originalImage.getAtIndex(i, j) - min) / (max-min);
				originalImage.setAtIndex(i, j, scaledValue);
			}
		}
		
		undistortedImage = new Grid2D(originalImage.getWidth(),originalImage.getHeight()); // initialization with zeros
		
		distortedImage = generateDistortedImage(originalImage,a,b,d);	
	}
	
	/**
	 * method to generate a distorted image
	 * An artificial distortion field is generated. With this field, 
	 * a distorted image is generated from the original image.
	 * Remark: coordinates of the latest distortion simulated are saved in class member variables
	 * @param inputImage: undistorted image on which distortion is simulated
	 * @param a: elliptic extent of the distortion in x-direction
	 * @param b: elliptic extent of the distortion in y-direction
	 * @param d: strength of the distortion
	 * @return: distorted image
	 */
    
	public Grid2D generateDistortedImage(Grid2D inputImage, float a, float b, float d){

		Grid2D grid = new Grid2D(inputImage);
		int imageWidth = grid.getWidth();
		int imageHeight = grid.getHeight();
		
		// generate grids to sample coordinates X and Y of the original image
		Grid2D X = new Grid2D(imageWidth,imageHeight); // x-coordinates with respect to origin in image center, spacing = 1 [unit]
		Grid2D Y = new Grid2D(imageWidth,imageHeight); // y-coordinates with respect to origin in image center, spacing = 1 [unit]
		
		float halfWidth = imageWidth / 2.0f;
		float halfHeight = imageHeight / 2.0f;
		
		for(int i = 0; i < X.getWidth(); i++){
			for(int j = 0; j < X.getHeight(); j++){
				
				X.setAtIndex(i, j, i - halfWidth + 0.5f); // assign pixel centers in x-direction
				Y.setAtIndex(i, j, j - halfHeight + 0.5f); // assign pixel center in y-direction
			}
		}
		
		// create an artificial elliptical distortion field R (additive field)
		Grid2D R = new Grid2D(imageWidth,imageHeight);

		for(int i = 0; i < R.getWidth(); i++){
			for(int j = 0; j < R.getHeight(); j++){
				
				// distortion gets stronger with the distance from the image center
				float r = d * (float)(Math.sqrt(
						Math.pow(X.getAtIndex(i, j)/(a*halfWidth),2)
						+ Math.pow(Y.getAtIndex(i, j)/(b*halfHeight),2)));
				R.setAtIndex(i, j, r);
			}
		}
		
		// shifting the positive range to half positive/half negative range
		float maxR = NumericPointwiseOperators.max(R);
		NumericPointwiseOperators.subtractBy(R, maxR * 0.5f);

		// create the distorted image coordinates:
		// distorted image coordinates = undistorted image points + artificial distortion field

		// distorted image coordinates Xd, Yd
		Grid2D Xd = new Grid2D(X);
		Grid2D Yd = new Grid2D(Y);
		
		NumericPointwiseOperators.addBy(Xd, R);
		NumericPointwiseOperators.addBy(Yd, R);
		
		// create the distorted image:
		// re-sample the original input image at the distorted image points (Xd,Yd) 
		// to create artificial distortion
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float distortedValue = InterpolationOperators.interpolateLinear(
						inputImage,
						Xd.getAtIndex(i, j) + halfWidth - 0.5f, // remember: coordinate origin was set to image center
						Yd.getAtIndex(i, j) + halfHeight - 0.5f);
				grid.setAtIndex(i, j, distortedValue);
			}
		}

		xprime = X;
		yprime = Y;
		x = Xd;
		y = Yd;
		
		return grid;	
	}	
	
	//getters for members
	// variables which are checked (DO NOT CHANGE!)
	
	public static int get_caseNo() {
		return caseNo;
	}
	
	public Grid2D get_originalImage() {
		return originalImage;
	}
	
	public Grid2D get_distortedImage() {
		return distortedImage;
	}
	
	public Grid2D get_undistortedImage() {
		return undistortedImage;
	}
	
	public int get_nx() {
		return nx;
	}
	
	public int get_ny() {
		return ny;
	}
	
	public float get_fx() {
		return fx;
	}
	
	public float get_fy() {
		return fy;
	}
	
	public SimpleMatrix get_Xu() {
		return Xu;
	}
	
	public SimpleMatrix get_Yu() {
		return Yu;
	}
	
	public SimpleMatrix get_Xd() {
		return Xd;
	}
	
	public SimpleMatrix get_Yd() {
		return Yd;
	}
	
	public int get_numCoeff() {
		return numCoeff;
	}
	
	public int get_numCorresp() {
		return numCorresp;
	}
	
	public SimpleMatrix get_A() {
		return A;
	}
	
	public DecompositionSVD get_svd() {
		return svd;
	}
	
	public SimpleMatrix get_A_pseudoinverse() {
		return A_pseudoinverse;
	}
	
	public SimpleVector get_u_vec() {
		return u_vec;
	}
	
	public SimpleVector get_v_vec() {
		return v_vec;
	}
	
	public SimpleVector get_XuVector() {
		return XuVector;
	}
	
	public SimpleVector get_YuVector() {
		return YuVector;
	}
	
	public SimpleVector get_XdVector() {
		return XdVector;
	}
	
	public SimpleVector get_YdVector() {
		return YdVector;
	}
	
	public Grid2D get_xDist() {
		return xDist;
	}
	
	public Grid2D get_yDist() {
		return yDist;
	}
	
	public Grid2D get_xprime() {
		return xprime;
	}
	
	public Grid2D get_yprime() {
		return yprime;
	}
	
	public Grid2D get_x() {
		return x;
	}
	
	public Grid2D get_y() {
		return y;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-15 23:56:34.934
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-15 23:56:34.935
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-15 23:56:35.188
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package edu.stanford.rsl.tutorial.mipda;

import edu.stanford.rsl.conrad.data.numeric.Grid2D;
import edu.stanford.rsl.conrad.data.numeric.NumericPointwiseOperators;
import edu.stanford.rsl.conrad.utils.ImageUtil;
//import edu.stanford.rsl.conrad.utils.VisualizationUtil;
import ij.IJ;
import ij.ImageJ;
import edu.stanford.rsl.conrad.data.numeric.InterpolationOperators;
//import edu.stanford.rsl.conrad.data.numeric.NumericGridOperator;
import edu.stanford.rsl.conrad.numerics.SimpleMatrix;
import edu.stanford.rsl.conrad.numerics.SimpleOperators;
import edu.stanford.rsl.conrad.numerics.SimpleVector;
import edu.stanford.rsl.conrad.numerics.DecompositionSVD;

/**
 * Geometric Undistortion
 * Programming exercise 1 for module "Defect Pixel Interpolation"
 * of the course "Medical Image Processing for Diagnostic Applications (MIPDA)"
 * @author Frank Schebesch, Ashwini Jadhav, Anna Gebhard, Mena Abdelmalek
 *
 */

public class ExerciseGeoU {

	final static int caseNo = 1; // choose 0, 1, or 2 for different test images

	final static float a = 0.6f; // a: spread among x-direction
	final static float b = 0.3f; // b: spread among y-direction
	final static float d = 5.0f; // d: d/2 value of distortion field at level set for (X/a)^2+(Y/b)^2=1
	
	String filename; // do not edit, choose a number in the main method instead
	Grid2D originalImage; // do not edit, read from filename when instantiating the object
	Grid2D distortedImage; // do not edit, generated in the main method
	Grid2D undistortedImage; // do not edit, member variable for the output image
	
	// number of lattice points
	final int nx = 8;//TODO: define the number of lattice point: nx (Positive number and less than 20)
	final int ny = 8;//TODO: define the number of lattice point: ny (Positive number and less than 20)
	
	float fx;
	float fy;
	SimpleMatrix Xu; 
	SimpleMatrix Yu;
	SimpleMatrix Xd;
	SimpleMatrix Yd;
	int numCoeff; 
	int numCorresp; 
	SimpleMatrix A;
	DecompositionSVD svd;
	SimpleMatrix A_pseudoinverse;
	SimpleVector u_vec;
	SimpleVector v_vec;
	SimpleVector XuVector;
	SimpleVector YuVector;
	SimpleVector XdVector;
	SimpleVector YdVector;
	Grid2D xDist;  
	Grid2D yDist;
	Grid2D xprime; // x-coordinates of point correspondences in the undistorted image
	Grid2D yprime; // y-coordinates of point correspondences in the undistorted image
	Grid2D x; // x-coordinates of point correspondences in the distorted image
	Grid2D y; // y-coordinates of point correspondences in the distorted image
	
	
	/** 
	 * main method
	 * Here you can choose the image, and set the distortion parameters
	 */
	public static void main(String[] args) {
		
		new ImageJ();
		
		// generate distorted image
		ExerciseGeoU exObj = new ExerciseGeoU(caseNo);
		exObj.init(a,b,d);
		
		// TASK: go to the method doImageUndistortion(...) and complete it 
		exObj.undistortedImage = exObj.doImageUndistortion(exObj.distortedImage);
		
		exObj.originalImage.show("Original Image");
		exObj.distortedImage.show("Distorted Image");
		exObj.undistortedImage.show("Undistorted Image");
		
		Grid2D differenceImage = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.originalImage, exObj.undistortedImage);
		
		differenceImage.show("Difference Original vs. Undistorted");
		
		Grid2D distortedVSundistorted = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.undistortedImage, exObj.distortedImage);
		
		distortedVSundistorted.show("Difference Undistorted vs. Distorted");
	}
	
	public Grid2D doImageUndistortion(Grid2D distortedImage){
		
		Grid2D grid = new Grid2D(distortedImage);
		
		// check if image distortion routine has been run
		if (distortedImage == null || undistortedImage == null
				|| xprime == null || yprime == null
				|| x == null || y == null) {
			
			System.err.println("Error in doImageUndistortion(): called before initialization of members.");
			return grid;
		}
		
		
		getLatticePoints(distortedImage);// There are TODOs here 
		
		
		int degree = 5; // polynomial's degree: 2,...,10
		calcPolynomial(degree, Xd);// There are TODOs here
		
		
		
		computeMatrixA(degree, numCorresp, numCoeff);// There are TODOs here
		
		
		computeDistortionCoeff(A, XuVector, YuVector);// There are TODOs here
		
		
		grid = computeDistortedGrid(distortedImage, grid, degree);// There are TODOs here
		
		return grid;
	}
	
	
	
	/** 1. Number of lattice points (this only works for symmetric images):
	 *  nx, ny feature points: usually provided by tracking point
	 *  correspondences in the phantom during the calibration step.
	 *  Here, we use the distorted and undistorted coordinates generated
	 *  in the course of the distortion simulation.
	 */ 
	public void getLatticePoints (Grid2D distortedImage){
		
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		// step size
		// calculate the step size of the lattice points: fx and fy 
		fx = imageWidth/nx; //TODO
		fy = imageHeight/ny; //TODO
		
		// fill the distorted and undistorted lattice points 
		// with data from the given correspondences
		// matrix = number of rows (y) x number of columns (x)
		Xu = new SimpleMatrix(ny,nx);
		Yu = new SimpleMatrix(ny,nx);
		Xd = new SimpleMatrix(ny,nx);
		Yd = new SimpleMatrix(ny,nx);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){

				// sample the distorted and undistorted grid points at the lattice points
				  Xu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx, j + fy)));//TODO: fill matrix Xu
				  Yu.setElementValue(i, j, fy);//TODO: fill matrix Yu
				  Xd.setElementValue(i, j, fx);//TODO: fill matrix Xd
				  Yd.setElementValue(i, j, fy)//TODO: fill matrix Yd
			}
		}
	}
	
	/** 2. Polynomial of degree d
	 * Polynomial of degree d -> (d-1): extrema (e.g., d=5: 4 extrema)
	 * d=0: constant (horizontal line with y-intercept a_0 -> f(x)=a_0)
	 * d=1: oblique line with y-intercept a_0 & slope a_1 -> f(x)=a_0 + a_1 x
	 * d=2: parabola
	 * d>=2: continuous non-linear curve
	 * ...
	 * d = 10 -> NumCoeff: 66 -> but only 64 lattice points are known (nx, ny = 8)
	 */
	
	public void calcPolynomial(int degree, SimpleMatrix Xd){
		
		// number of coefficients: numCoeff
		// (hint: this is NOT the total number of multiplications!)
		numCoeff = 0; //TODO
		
		// number of correspondences: numCorresp
		numCorresp =  0; //TODO
		
		// Printout of the used parameters
		System.out.println("Polynom of degree: " + degree);
		System.out.println("Number of Coefficients: " + numCoeff);
		System.out.println("Number of Correspondences: " + numCorresp);
		
	}
	
	/**
	 * 3. Create the matrix A
	 */
	
	public void computeMatrixA(int degree, int numCorresp, int numCoeff){
		
		A = new SimpleMatrix(numCorresp, numCoeff);
		if (numCorresp <= 0 && numCoeff <= 0)
			return;
		A.zeros();
		
		// Realign the grid matrix into a vector for easier access in the next step
		XuVector = new SimpleVector(numCorresp);
		YuVector = new SimpleVector(numCorresp);
		XdVector = new SimpleVector(numCorresp);
		YdVector = new SimpleVector(numCorresp);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){
				
				XuVector.setElementValue(i*ny + j, Xu.getElement(j, i));
				YuVector.setElementValue(i*ny + j, Yu.getElement(j, i));
				XdVector.setElementValue(i*ny + j, Xd.getElement(j, i));
				YdVector.setElementValue(i*ny + j, Yd.getElement(j, i));
			}
		}
		
		// Compute matrix A (coordinates from distorted image)
		for(int r = 0; r < numCorresp; r++){
			
			int cc = 0;
			
			for(int k = 0; k <= degree; k++){
				for(int l = 0; l <= (degree-k); l++){
					
					// TODO: fill matrix A
					cc++;
					
				}
			}
		}
	}
	
	public void computeDistortionCoeff(SimpleMatrix A, SimpleVector XuVector, SimpleVector YuVector){
		
		// Compute the pseudo-inverse of A with the help of the SVD (class: DecompositionSVD)
		svd = null; // TODO
	    A_pseudoinverse = null; // TODO
	  
		// Compute the distortion coefficients (solve for known corresponding undistorted points)
		u_vec = null;// TODO
		v_vec = null;// TODO
	}
	
	/**
	 * 4. Compute the distorted grid points (xDist, yDist) which are used to sample the
	 * distorted image to get the undistorted image
	 * (xprime,yprime) is the position in the undistorted image
	 * (xDist,yDist) is the position in the distorted (observed) X-ray image.
	 */
	public Grid2D computeDistortedGrid(Grid2D distortedImage, Grid2D grid_out, int degree){
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		xDist = new Grid2D(imageWidth,imageHeight);  
		yDist = new Grid2D(imageWidth,imageHeight); 
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float val1, val2; //variables Val1 and Val2 are used for intermediate computation of xDist and yDist respectively
				
				int cc = 0;
				
				for(int k = 0; k <= degree; k++){
					for(int l = 0; l <= degree - k; l++){
						
						val1 = 0;// TODO
						val2 = 0;// TODO
						
						// TODO: fill xDist
						// TODO: fill yDist
						
						cc++;
					}
				}
			}
		}
		
		float val; // variable for intermediate computations of undistorted image
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				// hint: consider the fact that the coordinate origin is in the center of the image
				val = 0;//TODO
				//TODO: fill grid_out
			}
		}
		
		return grid_out;
		
	}
	
	
	
	/**
	 * 
	 * end of the exercise
	 */	

	
	/**
	 * standard constructor
	 */
	public ExerciseGeoU(){
		
		this(0);
	}
		
	/**
	 * parameterized constructor for the ExerciseDPI object
	 * @param caseNo: select one of three images to test your undistortion method
	 */
	public ExerciseGeoU(int caseNo){
		
		switch (caseNo) {
		case 0:
			filename = "frame32.jpg";
			break;
		case 1:
			filename = "undistorted.jpg";
			break;
		case 2:
			filename = "frame90.jpg";
			break;
		default:
			filename = "frame32.jpg";
			break;
		}
		
		String imageDataLoc = System.getProperty("user.dir") + "/data/" + "/mipda/";
	
		originalImage = ImageUtil.wrapImagePlus(IJ.openImage(imageDataLoc + filename)).getSubGrid(0);
	}
	
	public void init(float a, float b, float d) {
		
		// Normalize intensity values to [0,1]
		float max = NumericPointwiseOperators.max(originalImage);
		float min = NumericPointwiseOperators.min(originalImage);
		
		for(int i = 0; i < originalImage.getWidth(); i++){
			for(int j = 0; j < originalImage.getHeight(); j++){
				
				float scaledValue = (originalImage.getAtIndex(i, j) - min) / (max-min);
				originalImage.setAtIndex(i, j, scaledValue);
			}
		}
		
		undistortedImage = new Grid2D(originalImage.getWidth(),originalImage.getHeight()); // initialization with zeros
		
		distortedImage = generateDistortedImage(originalImage,a,b,d);	
	}
	
	/**
	 * method to generate a distorted image
	 * An artificial distortion field is generated. With this field, 
	 * a distorted image is generated from the original image.
	 * Remark: coordinates of the latest distortion simulated are saved in class member variables
	 * @param inputImage: undistorted image on which distortion is simulated
	 * @param a: elliptic extent of the distortion in x-direction
	 * @param b: elliptic extent of the distortion in y-direction
	 * @param d: strength of the distortion
	 * @return: distorted image
	 */
    
	public Grid2D generateDistortedImage(Grid2D inputImage, float a, float b, float d){

		Grid2D grid = new Grid2D(inputImage);
		int imageWidth = grid.getWidth();
		int imageHeight = grid.getHeight();
		
		// generate grids to sample coordinates X and Y of the original image
		Grid2D X = new Grid2D(imageWidth,imageHeight); // x-coordinates with respect to origin in image center, spacing = 1 [unit]
		Grid2D Y = new Grid2D(imageWidth,imageHeight); // y-coordinates with respect to origin in image center, spacing = 1 [unit]
		
		float halfWidth = imageWidth / 2.0f;
		float halfHeight = imageHeight / 2.0f;
		
		for(int i = 0; i < X.getWidth(); i++){
			for(int j = 0; j < X.getHeight(); j++){
				
				X.setAtIndex(i, j, i - halfWidth + 0.5f); // assign pixel centers in x-direction
				Y.setAtIndex(i, j, j - halfHeight + 0.5f); // assign pixel center in y-direction
			}
		}
		
		// create an artificial elliptical distortion field R (additive field)
		Grid2D R = new Grid2D(imageWidth,imageHeight);

		for(int i = 0; i < R.getWidth(); i++){
			for(int j = 0; j < R.getHeight(); j++){
				
				// distortion gets stronger with the distance from the image center
				float r = d * (float)(Math.sqrt(
						Math.pow(X.getAtIndex(i, j)/(a*halfWidth),2)
						+ Math.pow(Y.getAtIndex(i, j)/(b*halfHeight),2)));
				R.setAtIndex(i, j, r);
			}
		}
		
		// shifting the positive range to half positive/half negative range
		float maxR = NumericPointwiseOperators.max(R);
		NumericPointwiseOperators.subtractBy(R, maxR * 0.5f);

		// create the distorted image coordinates:
		// distorted image coordinates = undistorted image points + artificial distortion field

		// distorted image coordinates Xd, Yd
		Grid2D Xd = new Grid2D(X);
		Grid2D Yd = new Grid2D(Y);
		
		NumericPointwiseOperators.addBy(Xd, R);
		NumericPointwiseOperators.addBy(Yd, R);
		
		// create the distorted image:
		// re-sample the original input image at the distorted image points (Xd,Yd) 
		// to create artificial distortion
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float distortedValue = InterpolationOperators.interpolateLinear(
						inputImage,
						Xd.getAtIndex(i, j) + halfWidth - 0.5f, // remember: coordinate origin was set to image center
						Yd.getAtIndex(i, j) + halfHeight - 0.5f);
				grid.setAtIndex(i, j, distortedValue);
			}
		}

		xprime = X;
		yprime = Y;
		x = Xd;
		y = Yd;
		
		return grid;	
	}	
	
	//getters for members
	// variables which are checked (DO NOT CHANGE!)
	
	public static int get_caseNo() {
		return caseNo;
	}
	
	public Grid2D get_originalImage() {
		return originalImage;
	}
	
	public Grid2D get_distortedImage() {
		return distortedImage;
	}
	
	public Grid2D get_undistortedImage() {
		return undistortedImage;
	}
	
	public int get_nx() {
		return nx;
	}
	
	public int get_ny() {
		return ny;
	}
	
	public float get_fx() {
		return fx;
	}
	
	public float get_fy() {
		return fy;
	}
	
	public SimpleMatrix get_Xu() {
		return Xu;
	}
	
	public SimpleMatrix get_Yu() {
		return Yu;
	}
	
	public SimpleMatrix get_Xd() {
		return Xd;
	}
	
	public SimpleMatrix get_Yd() {
		return Yd;
	}
	
	public int get_numCoeff() {
		return numCoeff;
	}
	
	public int get_numCorresp() {
		return numCorresp;
	}
	
	public SimpleMatrix get_A() {
		return A;
	}
	
	public DecompositionSVD get_svd() {
		return svd;
	}
	
	public SimpleMatrix get_A_pseudoinverse() {
		return A_pseudoinverse;
	}
	
	public SimpleVector get_u_vec() {
		return u_vec;
	}
	
	public SimpleVector get_v_vec() {
		return v_vec;
	}
	
	public SimpleVector get_XuVector() {
		return XuVector;
	}
	
	public SimpleVector get_YuVector() {
		return YuVector;
	}
	
	public SimpleVector get_XdVector() {
		return XdVector;
	}
	
	public SimpleVector get_YdVector() {
		return YdVector;
	}
	
	public Grid2D get_xDist() {
		return xDist;
	}
	
	public Grid2D get_yDist() {
		return yDist;
	}
	
	public Grid2D get_xprime() {
		return xprime;
	}
	
	public Grid2D get_yprime() {
		return yprime;
	}
	
	public Grid2D get_x() {
		return x;
	}
	
	public Grid2D get_y() {
		return y;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-15 23:56:35.189
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-15 23:56:35.190
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-15 23:56:36.451
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package edu.stanford.rsl.tutorial.mipda;

import edu.stanford.rsl.conrad.data.numeric.Grid2D;
import edu.stanford.rsl.conrad.data.numeric.NumericPointwiseOperators;
import edu.stanford.rsl.conrad.utils.ImageUtil;
//import edu.stanford.rsl.conrad.utils.VisualizationUtil;
import ij.IJ;
import ij.ImageJ;
import edu.stanford.rsl.conrad.data.numeric.InterpolationOperators;
//import edu.stanford.rsl.conrad.data.numeric.NumericGridOperator;
import edu.stanford.rsl.conrad.numerics.SimpleMatrix;
import edu.stanford.rsl.conrad.numerics.SimpleOperators;
import edu.stanford.rsl.conrad.numerics.SimpleVector;
import edu.stanford.rsl.conrad.numerics.DecompositionSVD;

/**
 * Geometric Undistortion
 * Programming exercise 1 for module "Defect Pixel Interpolation"
 * of the course "Medical Image Processing for Diagnostic Applications (MIPDA)"
 * @author Frank Schebesch, Ashwini Jadhav, Anna Gebhard, Mena Abdelmalek
 *
 */

public class ExerciseGeoU {

	final static int caseNo = 1; // choose 0, 1, or 2 for different test images

	final static float a = 0.6f; // a: spread among x-direction
	final static float b = 0.3f; // b: spread among y-direction
	final static float d = 5.0f; // d: d/2 value of distortion field at level set for (X/a)^2+(Y/b)^2=1
	
	String filename; // do not edit, choose a number in the main method instead
	Grid2D originalImage; // do not edit, read from filename when instantiating the object
	Grid2D distortedImage; // do not edit, generated in the main method
	Grid2D undistortedImage; // do not edit, member variable for the output image
	
	// number of lattice points
	final int nx = 8;//TODO: define the number of lattice point: nx (Positive number and less than 20)
	final int ny = 8;//TODO: define the number of lattice point: ny (Positive number and less than 20)
	
	float fx;
	float fy;
	SimpleMatrix Xu; 
	SimpleMatrix Yu;
	SimpleMatrix Xd;
	SimpleMatrix Yd;
	int numCoeff; 
	int numCorresp; 
	SimpleMatrix A;
	DecompositionSVD svd;
	SimpleMatrix A_pseudoinverse;
	SimpleVector u_vec;
	SimpleVector v_vec;
	SimpleVector XuVector;
	SimpleVector YuVector;
	SimpleVector XdVector;
	SimpleVector YdVector;
	Grid2D xDist;  
	Grid2D yDist;
	Grid2D xprime; // x-coordinates of point correspondences in the undistorted image
	Grid2D yprime; // y-coordinates of point correspondences in the undistorted image
	Grid2D x; // x-coordinates of point correspondences in the distorted image
	Grid2D y; // y-coordinates of point correspondences in the distorted image
	
	
	/** 
	 * main method
	 * Here you can choose the image, and set the distortion parameters
	 */
	public static void main(String[] args) {
		
		new ImageJ();
		
		// generate distorted image
		ExerciseGeoU exObj = new ExerciseGeoU(caseNo);
		exObj.init(a,b,d);
		
		// TASK: go to the method doImageUndistortion(...) and complete it 
		exObj.undistortedImage = exObj.doImageUndistortion(exObj.distortedImage);
		
		exObj.originalImage.show("Original Image");
		exObj.distortedImage.show("Distorted Image");
		exObj.undistortedImage.show("Undistorted Image");
		
		Grid2D differenceImage = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.originalImage, exObj.undistortedImage);
		
		differenceImage.show("Difference Original vs. Undistorted");
		
		Grid2D distortedVSundistorted = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.undistortedImage, exObj.distortedImage);
		
		distortedVSundistorted.show("Difference Undistorted vs. Distorted");
	}
	
	public Grid2D doImageUndistortion(Grid2D distortedImage){
		
		Grid2D grid = new Grid2D(distortedImage);
		
		// check if image distortion routine has been run
		if (distortedImage == null || undistortedImage == null
				|| xprime == null || yprime == null
				|| x == null || y == null) {
			
			System.err.println("Error in doImageUndistortion(): called before initialization of members.");
			return grid;
		}
		
		
		getLatticePoints(distortedImage);// There are TODOs here 
		
		
		int degree = 5; // polynomial's degree: 2,...,10
		calcPolynomial(degree, Xd);// There are TODOs here
		
		
		
		computeMatrixA(degree, numCorresp, numCoeff);// There are TODOs here
		
		
		computeDistortionCoeff(A, XuVector, YuVector);// There are TODOs here
		
		
		grid = computeDistortedGrid(distortedImage, grid, degree);// There are TODOs here
		
		return grid;
	}
	
	
	
	/** 1. Number of lattice points (this only works for symmetric images):
	 *  nx, ny feature points: usually provided by tracking point
	 *  correspondences in the phantom during the calibration step.
	 *  Here, we use the distorted and undistorted coordinates generated
	 *  in the course of the distortion simulation.
	 */ 
	public void getLatticePoints (Grid2D distortedImage){
		
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		// step size
		// calculate the step size of the lattice points: fx and fy 
		fx = imageWidth/nx; //TODO
		fy = imageHeight/ny; //TODO
		
		// fill the distorted and undistorted lattice points 
		// with data from the given correspondences
		// matrix = number of rows (y) x number of columns (x)
		Xu = new SimpleMatrix(ny,nx);
		Yu = new SimpleMatrix(ny,nx);
		Xd = new SimpleMatrix(ny,nx);
		Yd = new SimpleMatrix(ny,nx);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){

				// sample the distorted and undistorted grid points at the lattice points
				  Xu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx), j + fy)));//TODO: fill matrix Xu
				  Yu.setElementValue(i, j, fy);//TODO: fill matrix Yu
				  Xd.setElementValue(i, j, fx);//TODO: fill matrix Xd
				  Yd.setElementValue(i, j, fy)//TODO: fill matrix Yd
			}
		}
	}
	
	/** 2. Polynomial of degree d
	 * Polynomial of degree d -> (d-1): extrema (e.g., d=5: 4 extrema)
	 * d=0: constant (horizontal line with y-intercept a_0 -> f(x)=a_0)
	 * d=1: oblique line with y-intercept a_0 & slope a_1 -> f(x)=a_0 + a_1 x
	 * d=2: parabola
	 * d>=2: continuous non-linear curve
	 * ...
	 * d = 10 -> NumCoeff: 66 -> but only 64 lattice points are known (nx, ny = 8)
	 */
	
	public void calcPolynomial(int degree, SimpleMatrix Xd){
		
		// number of coefficients: numCoeff
		// (hint: this is NOT the total number of multiplications!)
		numCoeff = 0; //TODO
		
		// number of correspondences: numCorresp
		numCorresp =  0; //TODO
		
		// Printout of the used parameters
		System.out.println("Polynom of degree: " + degree);
		System.out.println("Number of Coefficients: " + numCoeff);
		System.out.println("Number of Correspondences: " + numCorresp);
		
	}
	
	/**
	 * 3. Create the matrix A
	 */
	
	public void computeMatrixA(int degree, int numCorresp, int numCoeff){
		
		A = new SimpleMatrix(numCorresp, numCoeff);
		if (numCorresp <= 0 && numCoeff <= 0)
			return;
		A.zeros();
		
		// Realign the grid matrix into a vector for easier access in the next step
		XuVector = new SimpleVector(numCorresp);
		YuVector = new SimpleVector(numCorresp);
		XdVector = new SimpleVector(numCorresp);
		YdVector = new SimpleVector(numCorresp);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){
				
				XuVector.setElementValue(i*ny + j, Xu.getElement(j, i));
				YuVector.setElementValue(i*ny + j, Yu.getElement(j, i));
				XdVector.setElementValue(i*ny + j, Xd.getElement(j, i));
				YdVector.setElementValue(i*ny + j, Yd.getElement(j, i));
			}
		}
		
		// Compute matrix A (coordinates from distorted image)
		for(int r = 0; r < numCorresp; r++){
			
			int cc = 0;
			
			for(int k = 0; k <= degree; k++){
				for(int l = 0; l <= (degree-k); l++){
					
					// TODO: fill matrix A
					cc++;
					
				}
			}
		}
	}
	
	public void computeDistortionCoeff(SimpleMatrix A, SimpleVector XuVector, SimpleVector YuVector){
		
		// Compute the pseudo-inverse of A with the help of the SVD (class: DecompositionSVD)
		svd = null; // TODO
	    A_pseudoinverse = null; // TODO
	  
		// Compute the distortion coefficients (solve for known corresponding undistorted points)
		u_vec = null;// TODO
		v_vec = null;// TODO
	}
	
	/**
	 * 4. Compute the distorted grid points (xDist, yDist) which are used to sample the
	 * distorted image to get the undistorted image
	 * (xprime,yprime) is the position in the undistorted image
	 * (xDist,yDist) is the position in the distorted (observed) X-ray image.
	 */
	public Grid2D computeDistortedGrid(Grid2D distortedImage, Grid2D grid_out, int degree){
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		xDist = new Grid2D(imageWidth,imageHeight);  
		yDist = new Grid2D(imageWidth,imageHeight); 
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float val1, val2; //variables Val1 and Val2 are used for intermediate computation of xDist and yDist respectively
				
				int cc = 0;
				
				for(int k = 0; k <= degree; k++){
					for(int l = 0; l <= degree - k; l++){
						
						val1 = 0;// TODO
						val2 = 0;// TODO
						
						// TODO: fill xDist
						// TODO: fill yDist
						
						cc++;
					}
				}
			}
		}
		
		float val; // variable for intermediate computations of undistorted image
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				// hint: consider the fact that the coordinate origin is in the center of the image
				val = 0;//TODO
				//TODO: fill grid_out
			}
		}
		
		return grid_out;
		
	}
	
	
	
	/**
	 * 
	 * end of the exercise
	 */	

	
	/**
	 * standard constructor
	 */
	public ExerciseGeoU(){
		
		this(0);
	}
		
	/**
	 * parameterized constructor for the ExerciseDPI object
	 * @param caseNo: select one of three images to test your undistortion method
	 */
	public ExerciseGeoU(int caseNo){
		
		switch (caseNo) {
		case 0:
			filename = "frame32.jpg";
			break;
		case 1:
			filename = "undistorted.jpg";
			break;
		case 2:
			filename = "frame90.jpg";
			break;
		default:
			filename = "frame32.jpg";
			break;
		}
		
		String imageDataLoc = System.getProperty("user.dir") + "/data/" + "/mipda/";
	
		originalImage = ImageUtil.wrapImagePlus(IJ.openImage(imageDataLoc + filename)).getSubGrid(0);
	}
	
	public void init(float a, float b, float d) {
		
		// Normalize intensity values to [0,1]
		float max = NumericPointwiseOperators.max(originalImage);
		float min = NumericPointwiseOperators.min(originalImage);
		
		for(int i = 0; i < originalImage.getWidth(); i++){
			for(int j = 0; j < originalImage.getHeight(); j++){
				
				float scaledValue = (originalImage.getAtIndex(i, j) - min) / (max-min);
				originalImage.setAtIndex(i, j, scaledValue);
			}
		}
		
		undistortedImage = new Grid2D(originalImage.getWidth(),originalImage.getHeight()); // initialization with zeros
		
		distortedImage = generateDistortedImage(originalImage,a,b,d);	
	}
	
	/**
	 * method to generate a distorted image
	 * An artificial distortion field is generated. With this field, 
	 * a distorted image is generated from the original image.
	 * Remark: coordinates of the latest distortion simulated are saved in class member variables
	 * @param inputImage: undistorted image on which distortion is simulated
	 * @param a: elliptic extent of the distortion in x-direction
	 * @param b: elliptic extent of the distortion in y-direction
	 * @param d: strength of the distortion
	 * @return: distorted image
	 */
    
	public Grid2D generateDistortedImage(Grid2D inputImage, float a, float b, float d){

		Grid2D grid = new Grid2D(inputImage);
		int imageWidth = grid.getWidth();
		int imageHeight = grid.getHeight();
		
		// generate grids to sample coordinates X and Y of the original image
		Grid2D X = new Grid2D(imageWidth,imageHeight); // x-coordinates with respect to origin in image center, spacing = 1 [unit]
		Grid2D Y = new Grid2D(imageWidth,imageHeight); // y-coordinates with respect to origin in image center, spacing = 1 [unit]
		
		float halfWidth = imageWidth / 2.0f;
		float halfHeight = imageHeight / 2.0f;
		
		for(int i = 0; i < X.getWidth(); i++){
			for(int j = 0; j < X.getHeight(); j++){
				
				X.setAtIndex(i, j, i - halfWidth + 0.5f); // assign pixel centers in x-direction
				Y.setAtIndex(i, j, j - halfHeight + 0.5f); // assign pixel center in y-direction
			}
		}
		
		// create an artificial elliptical distortion field R (additive field)
		Grid2D R = new Grid2D(imageWidth,imageHeight);

		for(int i = 0; i < R.getWidth(); i++){
			for(int j = 0; j < R.getHeight(); j++){
				
				// distortion gets stronger with the distance from the image center
				float r = d * (float)(Math.sqrt(
						Math.pow(X.getAtIndex(i, j)/(a*halfWidth),2)
						+ Math.pow(Y.getAtIndex(i, j)/(b*halfHeight),2)));
				R.setAtIndex(i, j, r);
			}
		}
		
		// shifting the positive range to half positive/half negative range
		float maxR = NumericPointwiseOperators.max(R);
		NumericPointwiseOperators.subtractBy(R, maxR * 0.5f);

		// create the distorted image coordinates:
		// distorted image coordinates = undistorted image points + artificial distortion field

		// distorted image coordinates Xd, Yd
		Grid2D Xd = new Grid2D(X);
		Grid2D Yd = new Grid2D(Y);
		
		NumericPointwiseOperators.addBy(Xd, R);
		NumericPointwiseOperators.addBy(Yd, R);
		
		// create the distorted image:
		// re-sample the original input image at the distorted image points (Xd,Yd) 
		// to create artificial distortion
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float distortedValue = InterpolationOperators.interpolateLinear(
						inputImage,
						Xd.getAtIndex(i, j) + halfWidth - 0.5f, // remember: coordinate origin was set to image center
						Yd.getAtIndex(i, j) + halfHeight - 0.5f);
				grid.setAtIndex(i, j, distortedValue);
			}
		}

		xprime = X;
		yprime = Y;
		x = Xd;
		y = Yd;
		
		return grid;	
	}	
	
	//getters for members
	// variables which are checked (DO NOT CHANGE!)
	
	public static int get_caseNo() {
		return caseNo;
	}
	
	public Grid2D get_originalImage() {
		return originalImage;
	}
	
	public Grid2D get_distortedImage() {
		return distortedImage;
	}
	
	public Grid2D get_undistortedImage() {
		return undistortedImage;
	}
	
	public int get_nx() {
		return nx;
	}
	
	public int get_ny() {
		return ny;
	}
	
	public float get_fx() {
		return fx;
	}
	
	public float get_fy() {
		return fy;
	}
	
	public SimpleMatrix get_Xu() {
		return Xu;
	}
	
	public SimpleMatrix get_Yu() {
		return Yu;
	}
	
	public SimpleMatrix get_Xd() {
		return Xd;
	}
	
	public SimpleMatrix get_Yd() {
		return Yd;
	}
	
	public int get_numCoeff() {
		return numCoeff;
	}
	
	public int get_numCorresp() {
		return numCorresp;
	}
	
	public SimpleMatrix get_A() {
		return A;
	}
	
	public DecompositionSVD get_svd() {
		return svd;
	}
	
	public SimpleMatrix get_A_pseudoinverse() {
		return A_pseudoinverse;
	}
	
	public SimpleVector get_u_vec() {
		return u_vec;
	}
	
	public SimpleVector get_v_vec() {
		return v_vec;
	}
	
	public SimpleVector get_XuVector() {
		return XuVector;
	}
	
	public SimpleVector get_YuVector() {
		return YuVector;
	}
	
	public SimpleVector get_XdVector() {
		return XdVector;
	}
	
	public SimpleVector get_YdVector() {
		return YdVector;
	}
	
	public Grid2D get_xDist() {
		return xDist;
	}
	
	public Grid2D get_yDist() {
		return yDist;
	}
	
	public Grid2D get_xprime() {
		return xprime;
	}
	
	public Grid2D get_yprime() {
		return yprime;
	}
	
	public Grid2D get_x() {
		return x;
	}
	
	public Grid2D get_y() {
		return y;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-15 23:56:36.452
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-15 23:56:36.453
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-15 23:56:36.471
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package edu.stanford.rsl.tutorial.mipda;

import edu.stanford.rsl.conrad.data.numeric.Grid2D;
import edu.stanford.rsl.conrad.data.numeric.NumericPointwiseOperators;
import edu.stanford.rsl.conrad.utils.ImageUtil;
//import edu.stanford.rsl.conrad.utils.VisualizationUtil;
import ij.IJ;
import ij.ImageJ;
import edu.stanford.rsl.conrad.data.numeric.InterpolationOperators;
//import edu.stanford.rsl.conrad.data.numeric.NumericGridOperator;
import edu.stanford.rsl.conrad.numerics.SimpleMatrix;
import edu.stanford.rsl.conrad.numerics.SimpleOperators;
import edu.stanford.rsl.conrad.numerics.SimpleVector;
import edu.stanford.rsl.conrad.numerics.DecompositionSVD;

/**
 * Geometric Undistortion
 * Programming exercise 1 for module "Defect Pixel Interpolation"
 * of the course "Medical Image Processing for Diagnostic Applications (MIPDA)"
 * @author Frank Schebesch, Ashwini Jadhav, Anna Gebhard, Mena Abdelmalek
 *
 */

public class ExerciseGeoU {

	final static int caseNo = 1; // choose 0, 1, or 2 for different test images

	final static float a = 0.6f; // a: spread among x-direction
	final static float b = 0.3f; // b: spread among y-direction
	final static float d = 5.0f; // d: d/2 value of distortion field at level set for (X/a)^2+(Y/b)^2=1
	
	String filename; // do not edit, choose a number in the main method instead
	Grid2D originalImage; // do not edit, read from filename when instantiating the object
	Grid2D distortedImage; // do not edit, generated in the main method
	Grid2D undistortedImage; // do not edit, member variable for the output image
	
	// number of lattice points
	final int nx = 8;//TODO: define the number of lattice point: nx (Positive number and less than 20)
	final int ny = 8;//TODO: define the number of lattice point: ny (Positive number and less than 20)
	
	float fx;
	float fy;
	SimpleMatrix Xu; 
	SimpleMatrix Yu;
	SimpleMatrix Xd;
	SimpleMatrix Yd;
	int numCoeff; 
	int numCorresp; 
	SimpleMatrix A;
	DecompositionSVD svd;
	SimpleMatrix A_pseudoinverse;
	SimpleVector u_vec;
	SimpleVector v_vec;
	SimpleVector XuVector;
	SimpleVector YuVector;
	SimpleVector XdVector;
	SimpleVector YdVector;
	Grid2D xDist;  
	Grid2D yDist;
	Grid2D xprime; // x-coordinates of point correspondences in the undistorted image
	Grid2D yprime; // y-coordinates of point correspondences in the undistorted image
	Grid2D x; // x-coordinates of point correspondences in the distorted image
	Grid2D y; // y-coordinates of point correspondences in the distorted image
	
	
	/** 
	 * main method
	 * Here you can choose the image, and set the distortion parameters
	 */
	public static void main(String[] args) {
		
		new ImageJ();
		
		// generate distorted image
		ExerciseGeoU exObj = new ExerciseGeoU(caseNo);
		exObj.init(a,b,d);
		
		// TASK: go to the method doImageUndistortion(...) and complete it 
		exObj.undistortedImage = exObj.doImageUndistortion(exObj.distortedImage);
		
		exObj.originalImage.show("Original Image");
		exObj.distortedImage.show("Distorted Image");
		exObj.undistortedImage.show("Undistorted Image");
		
		Grid2D differenceImage = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.originalImage, exObj.undistortedImage);
		
		differenceImage.show("Difference Original vs. Undistorted");
		
		Grid2D distortedVSundistorted = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.undistortedImage, exObj.distortedImage);
		
		distortedVSundistorted.show("Difference Undistorted vs. Distorted");
	}
	
	public Grid2D doImageUndistortion(Grid2D distortedImage){
		
		Grid2D grid = new Grid2D(distortedImage);
		
		// check if image distortion routine has been run
		if (distortedImage == null || undistortedImage == null
				|| xprime == null || yprime == null
				|| x == null || y == null) {
			
			System.err.println("Error in doImageUndistortion(): called before initialization of members.");
			return grid;
		}
		
		
		getLatticePoints(distortedImage);// There are TODOs here 
		
		
		int degree = 5; // polynomial's degree: 2,...,10
		calcPolynomial(degree, Xd);// There are TODOs here
		
		
		
		computeMatrixA(degree, numCorresp, numCoeff);// There are TODOs here
		
		
		computeDistortionCoeff(A, XuVector, YuVector);// There are TODOs here
		
		
		grid = computeDistortedGrid(distortedImage, grid, degree);// There are TODOs here
		
		return grid;
	}
	
	
	
	/** 1. Number of lattice points (this only works for symmetric images):
	 *  nx, ny feature points: usually provided by tracking point
	 *  correspondences in the phantom during the calibration step.
	 *  Here, we use the distorted and undistorted coordinates generated
	 *  in the course of the distortion simulation.
	 */ 
	public void getLatticePoints (Grid2D distortedImage){
		
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		// step size
		// calculate the step size of the lattice points: fx and fy 
		fx = imageWidth/nx; //TODO
		fy = imageHeight/ny; //TODO
		
		// fill the distorted and undistorted lattice points 
		// with data from the given correspondences
		// matrix = number of rows (y) x number of columns (x)
		Xu = new SimpleMatrix(ny,nx);
		Yu = new SimpleMatrix(ny,nx);
		Xd = new SimpleMatrix(ny,nx);
		Yd = new SimpleMatrix(ny,nx);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){

				// sample the distorted and undistorted grid points at the lattice points
				  Xu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx), j + fy)));//TODO: fill matrix Xu
				  Yu.setElementValue(i, j, fy);//TODO: fill matrix Yu
				  Xd.setElementValue(i, j, fx);//TODO: fill matrix Xd
				  Yd.setElementValue(i, j, fy)//TODO: fill matrix Yd
			}
		}
	}
	
	/** 2. Polynomial of degree d
	 * Polynomial of degree d -> (d-1): extrema (e.g., d=5: 4 extrema)
	 * d=0: constant (horizontal line with y-intercept a_0 -> f(x)=a_0)
	 * d=1: oblique line with y-intercept a_0 & slope a_1 -> f(x)=a_0 + a_1 x
	 * d=2: parabola
	 * d>=2: continuous non-linear curve
	 * ...
	 * d = 10 -> NumCoeff: 66 -> but only 64 lattice points are known (nx, ny = 8)
	 */
	
	public void calcPolynomial(int degree, SimpleMatrix Xd){
		
		// number of coefficients: numCoeff
		// (hint: this is NOT the total number of multiplications!)
		numCoeff = 0; //TODO
		
		// number of correspondences: numCorresp
		numCorresp =  0; //TODO
		
		// Printout of the used parameters
		System.out.println("Polynom of degree: " + degree);
		System.out.println("Number of Coefficients: " + numCoeff);
		System.out.println("Number of Correspondences: " + numCorresp);
		
	}
	
	/**
	 * 3. Create the matrix A
	 */
	
	public void computeMatrixA(int degree, int numCorresp, int numCoeff){
		
		A = new SimpleMatrix(numCorresp, numCoeff);
		if (numCorresp <= 0 && numCoeff <= 0)
			return;
		A.zeros();
		
		// Realign the grid matrix into a vector for easier access in the next step
		XuVector = new SimpleVector(numCorresp);
		YuVector = new SimpleVector(numCorresp);
		XdVector = new SimpleVector(numCorresp);
		YdVector = new SimpleVector(numCorresp);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){
				
				XuVector.setElementValue(i*ny + j, Xu.getElement(j, i));
				YuVector.setElementValue(i*ny + j, Yu.getElement(j, i));
				XdVector.setElementValue(i*ny + j, Xd.getElement(j, i));
				YdVector.setElementValue(i*ny + j, Yd.getElement(j, i));
			}
		}
		
		// Compute matrix A (coordinates from distorted image)
		for(int r = 0; r < numCorresp; r++){
			
			int cc = 0;
			
			for(int k = 0; k <= degree; k++){
				for(int l = 0; l <= (degree-k); l++){
					
					// TODO: fill matrix A
					cc++;
					
				}
			}
		}
	}
	
	public void computeDistortionCoeff(SimpleMatrix A, SimpleVector XuVector, SimpleVector YuVector){
		
		// Compute the pseudo-inverse of A with the help of the SVD (class: DecompositionSVD)
		svd = null; // TODO
	    A_pseudoinverse = null; // TODO
	  
		// Compute the distortion coefficients (solve for known corresponding undistorted points)
		u_vec = null;// TODO
		v_vec = null;// TODO
	}
	
	/**
	 * 4. Compute the distorted grid points (xDist, yDist) which are used to sample the
	 * distorted image to get the undistorted image
	 * (xprime,yprime) is the position in the undistorted image
	 * (xDist,yDist) is the position in the distorted (observed) X-ray image.
	 */
	public Grid2D computeDistortedGrid(Grid2D distortedImage, Grid2D grid_out, int degree){
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		xDist = new Grid2D(imageWidth,imageHeight);  
		yDist = new Grid2D(imageWidth,imageHeight); 
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float val1, val2; //variables Val1 and Val2 are used for intermediate computation of xDist and yDist respectively
				
				int cc = 0;
				
				for(int k = 0; k <= degree; k++){
					for(int l = 0; l <= degree - k; l++){
						
						val1 = 0;// TODO
						val2 = 0;// TODO
						
						// TODO: fill xDist
						// TODO: fill yDist
						
						cc++;
					}
				}
			}
		}
		
		float val; // variable for intermediate computations of undistorted image
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				// hint: consider the fact that the coordinate origin is in the center of the image
				val = 0;//TODO
				//TODO: fill grid_out
			}
		}
		
		return grid_out;
		
	}
	
	
	
	/**
	 * 
	 * end of the exercise
	 */	

	
	/**
	 * standard constructor
	 */
	public ExerciseGeoU(){
		
		this(0);
	}
		
	/**
	 * parameterized constructor for the ExerciseDPI object
	 * @param caseNo: select one of three images to test your undistortion method
	 */
	public ExerciseGeoU(int caseNo){
		
		switch (caseNo) {
		case 0:
			filename = "frame32.jpg";
			break;
		case 1:
			filename = "undistorted.jpg";
			break;
		case 2:
			filename = "frame90.jpg";
			break;
		default:
			filename = "frame32.jpg";
			break;
		}
		
		String imageDataLoc = System.getProperty("user.dir") + "/data/" + "/mipda/";
	
		originalImage = ImageUtil.wrapImagePlus(IJ.openImage(imageDataLoc + filename)).getSubGrid(0);
	}
	
	public void init(float a, float b, float d) {
		
		// Normalize intensity values to [0,1]
		float max = NumericPointwiseOperators.max(originalImage);
		float min = NumericPointwiseOperators.min(originalImage);
		
		for(int i = 0; i < originalImage.getWidth(); i++){
			for(int j = 0; j < originalImage.getHeight(); j++){
				
				float scaledValue = (originalImage.getAtIndex(i, j) - min) / (max-min);
				originalImage.setAtIndex(i, j, scaledValue);
			}
		}
		
		undistortedImage = new Grid2D(originalImage.getWidth(),originalImage.getHeight()); // initialization with zeros
		
		distortedImage = generateDistortedImage(originalImage,a,b,d);	
	}
	
	/**
	 * method to generate a distorted image
	 * An artificial distortion field is generated. With this field, 
	 * a distorted image is generated from the original image.
	 * Remark: coordinates of the latest distortion simulated are saved in class member variables
	 * @param inputImage: undistorted image on which distortion is simulated
	 * @param a: elliptic extent of the distortion in x-direction
	 * @param b: elliptic extent of the distortion in y-direction
	 * @param d: strength of the distortion
	 * @return: distorted image
	 */
    
	public Grid2D generateDistortedImage(Grid2D inputImage, float a, float b, float d){

		Grid2D grid = new Grid2D(inputImage);
		int imageWidth = grid.getWidth();
		int imageHeight = grid.getHeight();
		
		// generate grids to sample coordinates X and Y of the original image
		Grid2D X = new Grid2D(imageWidth,imageHeight); // x-coordinates with respect to origin in image center, spacing = 1 [unit]
		Grid2D Y = new Grid2D(imageWidth,imageHeight); // y-coordinates with respect to origin in image center, spacing = 1 [unit]
		
		float halfWidth = imageWidth / 2.0f;
		float halfHeight = imageHeight / 2.0f;
		
		for(int i = 0; i < X.getWidth(); i++){
			for(int j = 0; j < X.getHeight(); j++){
				
				X.setAtIndex(i, j, i - halfWidth + 0.5f); // assign pixel centers in x-direction
				Y.setAtIndex(i, j, j - halfHeight + 0.5f); // assign pixel center in y-direction
			}
		}
		
		// create an artificial elliptical distortion field R (additive field)
		Grid2D R = new Grid2D(imageWidth,imageHeight);

		for(int i = 0; i < R.getWidth(); i++){
			for(int j = 0; j < R.getHeight(); j++){
				
				// distortion gets stronger with the distance from the image center
				float r = d * (float)(Math.sqrt(
						Math.pow(X.getAtIndex(i, j)/(a*halfWidth),2)
						+ Math.pow(Y.getAtIndex(i, j)/(b*halfHeight),2)));
				R.setAtIndex(i, j, r);
			}
		}
		
		// shifting the positive range to half positive/half negative range
		float maxR = NumericPointwiseOperators.max(R);
		NumericPointwiseOperators.subtractBy(R, maxR * 0.5f);

		// create the distorted image coordinates:
		// distorted image coordinates = undistorted image points + artificial distortion field

		// distorted image coordinates Xd, Yd
		Grid2D Xd = new Grid2D(X);
		Grid2D Yd = new Grid2D(Y);
		
		NumericPointwiseOperators.addBy(Xd, R);
		NumericPointwiseOperators.addBy(Yd, R);
		
		// create the distorted image:
		// re-sample the original input image at the distorted image points (Xd,Yd) 
		// to create artificial distortion
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float distortedValue = InterpolationOperators.interpolateLinear(
						inputImage,
						Xd.getAtIndex(i, j) + halfWidth - 0.5f, // remember: coordinate origin was set to image center
						Yd.getAtIndex(i, j) + halfHeight - 0.5f);
				grid.setAtIndex(i, j, distortedValue);
			}
		}

		xprime = X;
		yprime = Y;
		x = Xd;
		y = Yd;
		
		return grid;	
	}	
	
	//getters for members
	// variables which are checked (DO NOT CHANGE!)
	
	public static int get_caseNo() {
		return caseNo;
	}
	
	public Grid2D get_originalImage() {
		return originalImage;
	}
	
	public Grid2D get_distortedImage() {
		return distortedImage;
	}
	
	public Grid2D get_undistortedImage() {
		return undistortedImage;
	}
	
	public int get_nx() {
		return nx;
	}
	
	public int get_ny() {
		return ny;
	}
	
	public float get_fx() {
		return fx;
	}
	
	public float get_fy() {
		return fy;
	}
	
	public SimpleMatrix get_Xu() {
		return Xu;
	}
	
	public SimpleMatrix get_Yu() {
		return Yu;
	}
	
	public SimpleMatrix get_Xd() {
		return Xd;
	}
	
	public SimpleMatrix get_Yd() {
		return Yd;
	}
	
	public int get_numCoeff() {
		return numCoeff;
	}
	
	public int get_numCorresp() {
		return numCorresp;
	}
	
	public SimpleMatrix get_A() {
		return A;
	}
	
	public DecompositionSVD get_svd() {
		return svd;
	}
	
	public SimpleMatrix get_A_pseudoinverse() {
		return A_pseudoinverse;
	}
	
	public SimpleVector get_u_vec() {
		return u_vec;
	}
	
	public SimpleVector get_v_vec() {
		return v_vec;
	}
	
	public SimpleVector get_XuVector() {
		return XuVector;
	}
	
	public SimpleVector get_YuVector() {
		return YuVector;
	}
	
	public SimpleVector get_XdVector() {
		return XdVector;
	}
	
	public SimpleVector get_YdVector() {
		return YdVector;
	}
	
	public Grid2D get_xDist() {
		return xDist;
	}
	
	public Grid2D get_yDist() {
		return yDist;
	}
	
	public Grid2D get_xprime() {
		return xprime;
	}
	
	public Grid2D get_yprime() {
		return yprime;
	}
	
	public Grid2D get_x() {
		return x;
	}
	
	public Grid2D get_y() {
		return y;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-15 23:56:36.472
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-15 23:56:36.472
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-15 23:56:37.819
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package edu.stanford.rsl.tutorial.mipda;

import edu.stanford.rsl.conrad.data.numeric.Grid2D;
import edu.stanford.rsl.conrad.data.numeric.NumericPointwiseOperators;
import edu.stanford.rsl.conrad.utils.ImageUtil;
//import edu.stanford.rsl.conrad.utils.VisualizationUtil;
import ij.IJ;
import ij.ImageJ;
import edu.stanford.rsl.conrad.data.numeric.InterpolationOperators;
//import edu.stanford.rsl.conrad.data.numeric.NumericGridOperator;
import edu.stanford.rsl.conrad.numerics.SimpleMatrix;
import edu.stanford.rsl.conrad.numerics.SimpleOperators;
import edu.stanford.rsl.conrad.numerics.SimpleVector;
import edu.stanford.rsl.conrad.numerics.DecompositionSVD;

/**
 * Geometric Undistortion
 * Programming exercise 1 for module "Defect Pixel Interpolation"
 * of the course "Medical Image Processing for Diagnostic Applications (MIPDA)"
 * @author Frank Schebesch, Ashwini Jadhav, Anna Gebhard, Mena Abdelmalek
 *
 */

public class ExerciseGeoU {

	final static int caseNo = 1; // choose 0, 1, or 2 for different test images

	final static float a = 0.6f; // a: spread among x-direction
	final static float b = 0.3f; // b: spread among y-direction
	final static float d = 5.0f; // d: d/2 value of distortion field at level set for (X/a)^2+(Y/b)^2=1
	
	String filename; // do not edit, choose a number in the main method instead
	Grid2D originalImage; // do not edit, read from filename when instantiating the object
	Grid2D distortedImage; // do not edit, generated in the main method
	Grid2D undistortedImage; // do not edit, member variable for the output image
	
	// number of lattice points
	final int nx = 8;//TODO: define the number of lattice point: nx (Positive number and less than 20)
	final int ny = 8;//TODO: define the number of lattice point: ny (Positive number and less than 20)
	
	float fx;
	float fy;
	SimpleMatrix Xu; 
	SimpleMatrix Yu;
	SimpleMatrix Xd;
	SimpleMatrix Yd;
	int numCoeff; 
	int numCorresp; 
	SimpleMatrix A;
	DecompositionSVD svd;
	SimpleMatrix A_pseudoinverse;
	SimpleVector u_vec;
	SimpleVector v_vec;
	SimpleVector XuVector;
	SimpleVector YuVector;
	SimpleVector XdVector;
	SimpleVector YdVector;
	Grid2D xDist;  
	Grid2D yDist;
	Grid2D xprime; // x-coordinates of point correspondences in the undistorted image
	Grid2D yprime; // y-coordinates of point correspondences in the undistorted image
	Grid2D x; // x-coordinates of point correspondences in the distorted image
	Grid2D y; // y-coordinates of point correspondences in the distorted image
	
	
	/** 
	 * main method
	 * Here you can choose the image, and set the distortion parameters
	 */
	public static void main(String[] args) {
		
		new ImageJ();
		
		// generate distorted image
		ExerciseGeoU exObj = new ExerciseGeoU(caseNo);
		exObj.init(a,b,d);
		
		// TASK: go to the method doImageUndistortion(...) and complete it 
		exObj.undistortedImage = exObj.doImageUndistortion(exObj.distortedImage);
		
		exObj.originalImage.show("Original Image");
		exObj.distortedImage.show("Distorted Image");
		exObj.undistortedImage.show("Undistorted Image");
		
		Grid2D differenceImage = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.originalImage, exObj.undistortedImage);
		
		differenceImage.show("Difference Original vs. Undistorted");
		
		Grid2D distortedVSundistorted = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.undistortedImage, exObj.distortedImage);
		
		distortedVSundistorted.show("Difference Undistorted vs. Distorted");
	}
	
	public Grid2D doImageUndistortion(Grid2D distortedImage){
		
		Grid2D grid = new Grid2D(distortedImage);
		
		// check if image distortion routine has been run
		if (distortedImage == null || undistortedImage == null
				|| xprime == null || yprime == null
				|| x == null || y == null) {
			
			System.err.println("Error in doImageUndistortion(): called before initialization of members.");
			return grid;
		}
		
		
		getLatticePoints(distortedImage);// There are TODOs here 
		
		
		int degree = 5; // polynomial's degree: 2,...,10
		calcPolynomial(degree, Xd);// There are TODOs here
		
		
		
		computeMatrixA(degree, numCorresp, numCoeff);// There are TODOs here
		
		
		computeDistortionCoeff(A, XuVector, YuVector);// There are TODOs here
		
		
		grid = computeDistortedGrid(distortedImage, grid, degree);// There are TODOs here
		
		return grid;
	}
	
	
	
	/** 1. Number of lattice points (this only works for symmetric images):
	 *  nx, ny feature points: usually provided by tracking point
	 *  correspondences in the phantom during the calibration step.
	 *  Here, we use the distorted and undistorted coordinates generated
	 *  in the course of the distortion simulation.
	 */ 
	public void getLatticePoints (Grid2D distortedImage){
		
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		// step size
		// calculate the step size of the lattice points: fx and fy 
		fx = imageWidth/nx; //TODO
		fy = imageHeight/ny; //TODO
		
		// fill the distorted and undistorted lattice points 
		// with data from the given correspondences
		// matrix = number of rows (y) x number of columns (x)
		Xu = new SimpleMatrix(ny,nx);
		Yu = new SimpleMatrix(ny,nx);
		Xd = new SimpleMatrix(ny,nx);
		Yd = new SimpleMatrix(ny,nx);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){

				// sample the distorted and undistorted grid points at the lattice points
				  Xu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx), j + fy)));//TODO: fill matrix Xu
				  Yu.setElementValue(i, j, fy);//TODO: fill matrix Yu
				  Xd.setElementValue(i, j, fx);//TODO: fill matrix Xd
				  Yd.setElementValue(i, j, fy)//TODO: fill matrix Yd
			}
		}
	}
	
	/** 2. Polynomial of degree d
	 * Polynomial of degree d -> (d-1): extrema (e.g., d=5: 4 extrema)
	 * d=0: constant (horizontal line with y-intercept a_0 -> f(x)=a_0)
	 * d=1: oblique line with y-intercept a_0 & slope a_1 -> f(x)=a_0 + a_1 x
	 * d=2: parabola
	 * d>=2: continuous non-linear curve
	 * ...
	 * d = 10 -> NumCoeff: 66 -> but only 64 lattice points are known (nx, ny = 8)
	 */
	
	public void calcPolynomial(int degree, SimpleMatrix Xd){
		
		// number of coefficients: numCoeff
		// (hint: this is NOT the total number of multiplications!)
		numCoeff = 0; //TODO
		
		// number of correspondences: numCorresp
		numCorresp =  0; //TODO
		
		// Printout of the used parameters
		System.out.println("Polynom of degree: " + degree);
		System.out.println("Number of Coefficients: " + numCoeff);
		System.out.println("Number of Correspondences: " + numCorresp);
		
	}
	
	/**
	 * 3. Create the matrix A
	 */
	
	public void computeMatrixA(int degree, int numCorresp, int numCoeff){
		
		A = new SimpleMatrix(numCorresp, numCoeff);
		if (numCorresp <= 0 && numCoeff <= 0)
			return;
		A.zeros();
		
		// Realign the grid matrix into a vector for easier access in the next step
		XuVector = new SimpleVector(numCorresp);
		YuVector = new SimpleVector(numCorresp);
		XdVector = new SimpleVector(numCorresp);
		YdVector = new SimpleVector(numCorresp);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){
				
				XuVector.setElementValue(i*ny + j, Xu.getElement(j, i));
				YuVector.setElementValue(i*ny + j, Yu.getElement(j, i));
				XdVector.setElementValue(i*ny + j, Xd.getElement(j, i));
				YdVector.setElementValue(i*ny + j, Yd.getElement(j, i));
			}
		}
		
		// Compute matrix A (coordinates from distorted image)
		for(int r = 0; r < numCorresp; r++){
			
			int cc = 0;
			
			for(int k = 0; k <= degree; k++){
				for(int l = 0; l <= (degree-k); l++){
					
					// TODO: fill matrix A
					cc++;
					
				}
			}
		}
	}
	
	public void computeDistortionCoeff(SimpleMatrix A, SimpleVector XuVector, SimpleVector YuVector){
		
		// Compute the pseudo-inverse of A with the help of the SVD (class: DecompositionSVD)
		svd = null; // TODO
	    A_pseudoinverse = null; // TODO
	  
		// Compute the distortion coefficients (solve for known corresponding undistorted points)
		u_vec = null;// TODO
		v_vec = null;// TODO
	}
	
	/**
	 * 4. Compute the distorted grid points (xDist, yDist) which are used to sample the
	 * distorted image to get the undistorted image
	 * (xprime,yprime) is the position in the undistorted image
	 * (xDist,yDist) is the position in the distorted (observed) X-ray image.
	 */
	public Grid2D computeDistortedGrid(Grid2D distortedImage, Grid2D grid_out, int degree){
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		xDist = new Grid2D(imageWidth,imageHeight);  
		yDist = new Grid2D(imageWidth,imageHeight); 
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float val1, val2; //variables Val1 and Val2 are used for intermediate computation of xDist and yDist respectively
				
				int cc = 0;
				
				for(int k = 0; k <= degree; k++){
					for(int l = 0; l <= degree - k; l++){
						
						val1 = 0;// TODO
						val2 = 0;// TODO
						
						// TODO: fill xDist
						// TODO: fill yDist
						
						cc++;
					}
				}
			}
		}
		
		float val; // variable for intermediate computations of undistorted image
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				// hint: consider the fact that the coordinate origin is in the center of the image
				val = 0;//TODO
				//TODO: fill grid_out
			}
		}
		
		return grid_out;
		
	}
	
	
	
	/**
	 * 
	 * end of the exercise
	 */	

	
	/**
	 * standard constructor
	 */
	public ExerciseGeoU(){
		
		this(0);
	}
		
	/**
	 * parameterized constructor for the ExerciseDPI object
	 * @param caseNo: select one of three images to test your undistortion method
	 */
	public ExerciseGeoU(int caseNo){
		
		switch (caseNo) {
		case 0:
			filename = "frame32.jpg";
			break;
		case 1:
			filename = "undistorted.jpg";
			break;
		case 2:
			filename = "frame90.jpg";
			break;
		default:
			filename = "frame32.jpg";
			break;
		}
		
		String imageDataLoc = System.getProperty("user.dir") + "/data/" + "/mipda/";
	
		originalImage = ImageUtil.wrapImagePlus(IJ.openImage(imageDataLoc + filename)).getSubGrid(0);
	}
	
	public void init(float a, float b, float d) {
		
		// Normalize intensity values to [0,1]
		float max = NumericPointwiseOperators.max(originalImage);
		float min = NumericPointwiseOperators.min(originalImage);
		
		for(int i = 0; i < originalImage.getWidth(); i++){
			for(int j = 0; j < originalImage.getHeight(); j++){
				
				float scaledValue = (originalImage.getAtIndex(i, j) - min) / (max-min);
				originalImage.setAtIndex(i, j, scaledValue);
			}
		}
		
		undistortedImage = new Grid2D(originalImage.getWidth(),originalImage.getHeight()); // initialization with zeros
		
		distortedImage = generateDistortedImage(originalImage,a,b,d);	
	}
	
	/**
	 * method to generate a distorted image
	 * An artificial distortion field is generated. With this field, 
	 * a distorted image is generated from the original image.
	 * Remark: coordinates of the latest distortion simulated are saved in class member variables
	 * @param inputImage: undistorted image on which distortion is simulated
	 * @param a: elliptic extent of the distortion in x-direction
	 * @param b: elliptic extent of the distortion in y-direction
	 * @param d: strength of the distortion
	 * @return: distorted image
	 */
    
	public Grid2D generateDistortedImage(Grid2D inputImage, float a, float b, float d){

		Grid2D grid = new Grid2D(inputImage);
		int imageWidth = grid.getWidth();
		int imageHeight = grid.getHeight();
		
		// generate grids to sample coordinates X and Y of the original image
		Grid2D X = new Grid2D(imageWidth,imageHeight); // x-coordinates with respect to origin in image center, spacing = 1 [unit]
		Grid2D Y = new Grid2D(imageWidth,imageHeight); // y-coordinates with respect to origin in image center, spacing = 1 [unit]
		
		float halfWidth = imageWidth / 2.0f;
		float halfHeight = imageHeight / 2.0f;
		
		for(int i = 0; i < X.getWidth(); i++){
			for(int j = 0; j < X.getHeight(); j++){
				
				X.setAtIndex(i, j, i - halfWidth + 0.5f); // assign pixel centers in x-direction
				Y.setAtIndex(i, j, j - halfHeight + 0.5f); // assign pixel center in y-direction
			}
		}
		
		// create an artificial elliptical distortion field R (additive field)
		Grid2D R = new Grid2D(imageWidth,imageHeight);

		for(int i = 0; i < R.getWidth(); i++){
			for(int j = 0; j < R.getHeight(); j++){
				
				// distortion gets stronger with the distance from the image center
				float r = d * (float)(Math.sqrt(
						Math.pow(X.getAtIndex(i, j)/(a*halfWidth),2)
						+ Math.pow(Y.getAtIndex(i, j)/(b*halfHeight),2)));
				R.setAtIndex(i, j, r);
			}
		}
		
		// shifting the positive range to half positive/half negative range
		float maxR = NumericPointwiseOperators.max(R);
		NumericPointwiseOperators.subtractBy(R, maxR * 0.5f);

		// create the distorted image coordinates:
		// distorted image coordinates = undistorted image points + artificial distortion field

		// distorted image coordinates Xd, Yd
		Grid2D Xd = new Grid2D(X);
		Grid2D Yd = new Grid2D(Y);
		
		NumericPointwiseOperators.addBy(Xd, R);
		NumericPointwiseOperators.addBy(Yd, R);
		
		// create the distorted image:
		// re-sample the original input image at the distorted image points (Xd,Yd) 
		// to create artificial distortion
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float distortedValue = InterpolationOperators.interpolateLinear(
						inputImage,
						Xd.getAtIndex(i, j) + halfWidth - 0.5f, // remember: coordinate origin was set to image center
						Yd.getAtIndex(i, j) + halfHeight - 0.5f);
				grid.setAtIndex(i, j, distortedValue);
			}
		}

		xprime = X;
		yprime = Y;
		x = Xd;
		y = Yd;
		
		return grid;	
	}	
	
	//getters for members
	// variables which are checked (DO NOT CHANGE!)
	
	public static int get_caseNo() {
		return caseNo;
	}
	
	public Grid2D get_originalImage() {
		return originalImage;
	}
	
	public Grid2D get_distortedImage() {
		return distortedImage;
	}
	
	public Grid2D get_undistortedImage() {
		return undistortedImage;
	}
	
	public int get_nx() {
		return nx;
	}
	
	public int get_ny() {
		return ny;
	}
	
	public float get_fx() {
		return fx;
	}
	
	public float get_fy() {
		return fy;
	}
	
	public SimpleMatrix get_Xu() {
		return Xu;
	}
	
	public SimpleMatrix get_Yu() {
		return Yu;
	}
	
	public SimpleMatrix get_Xd() {
		return Xd;
	}
	
	public SimpleMatrix get_Yd() {
		return Yd;
	}
	
	public int get_numCoeff() {
		return numCoeff;
	}
	
	public int get_numCorresp() {
		return numCorresp;
	}
	
	public SimpleMatrix get_A() {
		return A;
	}
	
	public DecompositionSVD get_svd() {
		return svd;
	}
	
	public SimpleMatrix get_A_pseudoinverse() {
		return A_pseudoinverse;
	}
	
	public SimpleVector get_u_vec() {
		return u_vec;
	}
	
	public SimpleVector get_v_vec() {
		return v_vec;
	}
	
	public SimpleVector get_XuVector() {
		return XuVector;
	}
	
	public SimpleVector get_YuVector() {
		return YuVector;
	}
	
	public SimpleVector get_XdVector() {
		return XdVector;
	}
	
	public SimpleVector get_YdVector() {
		return YdVector;
	}
	
	public Grid2D get_xDist() {
		return xDist;
	}
	
	public Grid2D get_yDist() {
		return yDist;
	}
	
	public Grid2D get_xprime() {
		return xprime;
	}
	
	public Grid2D get_yprime() {
		return yprime;
	}
	
	public Grid2D get_x() {
		return x;
	}
	
	public Grid2D get_y() {
		return y;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-15 23:56:37.820
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-15 23:56:37.821
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-15 23:56:39.878
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package edu.stanford.rsl.tutorial.mipda;

import edu.stanford.rsl.conrad.data.numeric.Grid2D;
import edu.stanford.rsl.conrad.data.numeric.NumericPointwiseOperators;
import edu.stanford.rsl.conrad.utils.ImageUtil;
//import edu.stanford.rsl.conrad.utils.VisualizationUtil;
import ij.IJ;
import ij.ImageJ;
import edu.stanford.rsl.conrad.data.numeric.InterpolationOperators;
//import edu.stanford.rsl.conrad.data.numeric.NumericGridOperator;
import edu.stanford.rsl.conrad.numerics.SimpleMatrix;
import edu.stanford.rsl.conrad.numerics.SimpleOperators;
import edu.stanford.rsl.conrad.numerics.SimpleVector;
import edu.stanford.rsl.conrad.numerics.DecompositionSVD;

/**
 * Geometric Undistortion
 * Programming exercise 1 for module "Defect Pixel Interpolation"
 * of the course "Medical Image Processing for Diagnostic Applications (MIPDA)"
 * @author Frank Schebesch, Ashwini Jadhav, Anna Gebhard, Mena Abdelmalek
 *
 */

public class ExerciseGeoU {

	final static int caseNo = 1; // choose 0, 1, or 2 for different test images

	final static float a = 0.6f; // a: spread among x-direction
	final static float b = 0.3f; // b: spread among y-direction
	final static float d = 5.0f; // d: d/2 value of distortion field at level set for (X/a)^2+(Y/b)^2=1
	
	String filename; // do not edit, choose a number in the main method instead
	Grid2D originalImage; // do not edit, read from filename when instantiating the object
	Grid2D distortedImage; // do not edit, generated in the main method
	Grid2D undistortedImage; // do not edit, member variable for the output image
	
	// number of lattice points
	final int nx = 8;//TODO: define the number of lattice point: nx (Positive number and less than 20)
	final int ny = 8;//TODO: define the number of lattice point: ny (Positive number and less than 20)
	
	float fx;
	float fy;
	SimpleMatrix Xu; 
	SimpleMatrix Yu;
	SimpleMatrix Xd;
	SimpleMatrix Yd;
	int numCoeff; 
	int numCorresp; 
	SimpleMatrix A;
	DecompositionSVD svd;
	SimpleMatrix A_pseudoinverse;
	SimpleVector u_vec;
	SimpleVector v_vec;
	SimpleVector XuVector;
	SimpleVector YuVector;
	SimpleVector XdVector;
	SimpleVector YdVector;
	Grid2D xDist;  
	Grid2D yDist;
	Grid2D xprime; // x-coordinates of point correspondences in the undistorted image
	Grid2D yprime; // y-coordinates of point correspondences in the undistorted image
	Grid2D x; // x-coordinates of point correspondences in the distorted image
	Grid2D y; // y-coordinates of point correspondences in the distorted image
	
	
	/** 
	 * main method
	 * Here you can choose the image, and set the distortion parameters
	 */
	public static void main(String[] args) {
		
		new ImageJ();
		
		// generate distorted image
		ExerciseGeoU exObj = new ExerciseGeoU(caseNo);
		exObj.init(a,b,d);
		
		// TASK: go to the method doImageUndistortion(...) and complete it 
		exObj.undistortedImage = exObj.doImageUndistortion(exObj.distortedImage);
		
		exObj.originalImage.show("Original Image");
		exObj.distortedImage.show("Distorted Image");
		exObj.undistortedImage.show("Undistorted Image");
		
		Grid2D differenceImage = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.originalImage, exObj.undistortedImage);
		
		differenceImage.show("Difference Original vs. Undistorted");
		
		Grid2D distortedVSundistorted = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.undistortedImage, exObj.distortedImage);
		
		distortedVSundistorted.show("Difference Undistorted vs. Distorted");
	}
	
	public Grid2D doImageUndistortion(Grid2D distortedImage){
		
		Grid2D grid = new Grid2D(distortedImage);
		
		// check if image distortion routine has been run
		if (distortedImage == null || undistortedImage == null
				|| xprime == null || yprime == null
				|| x == null || y == null) {
			
			System.err.println("Error in doImageUndistortion(): called before initialization of members.");
			return grid;
		}
		
		
		getLatticePoints(distortedImage);// There are TODOs here 
		
		
		int degree = 5; // polynomial's degree: 2,...,10
		calcPolynomial(degree, Xd);// There are TODOs here
		
		
		
		computeMatrixA(degree, numCorresp, numCoeff);// There are TODOs here
		
		
		computeDistortionCoeff(A, XuVector, YuVector);// There are TODOs here
		
		
		grid = computeDistortedGrid(distortedImage, grid, degree);// There are TODOs here
		
		return grid;
	}
	
	
	
	/** 1. Number of lattice points (this only works for symmetric images):
	 *  nx, ny feature points: usually provided by tracking point
	 *  correspondences in the phantom during the calibration step.
	 *  Here, we use the distorted and undistorted coordinates generated
	 *  in the course of the distortion simulation.
	 */ 
	public void getLatticePoints (Grid2D distortedImage){
		
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		// step size
		// calculate the step size of the lattice points: fx and fy 
		fx = imageWidth/nx; //TODO
		fy = imageHeight/ny; //TODO
		
		// fill the distorted and undistorted lattice points 
		// with data from the given correspondences
		// matrix = number of rows (y) x number of columns (x)
		Xu = new SimpleMatrix(ny,nx);
		Yu = new SimpleMatrix(ny,nx);
		Xd = new SimpleMatrix(ny,nx);
		Yd = new SimpleMatrix(ny,nx);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){

				// sample the distorted and undistorted grid points at the lattice points
				  Xu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx), j + fy)));//TODO: fill matrix Xu
				  Yu.setElementValue(i, j, fy);//TODO: fill matrix Yu
				  Xd.setElementValue(i, j, fx);//TODO: fill matrix Xd
				  Yd.setElementValue(i, j, fy)//TODO: fill matrix Yd
			}
		}
	}
	
	/** 2. Polynomial of degree d
	 * Polynomial of degree d -> (d-1): extrema (e.g., d=5: 4 extrema)
	 * d=0: constant (horizontal line with y-intercept a_0 -> f(x)=a_0)
	 * d=1: oblique line with y-intercept a_0 & slope a_1 -> f(x)=a_0 + a_1 x
	 * d=2: parabola
	 * d>=2: continuous non-linear curve
	 * ...
	 * d = 10 -> NumCoeff: 66 -> but only 64 lattice points are known (nx, ny = 8)
	 */
	
	public void calcPolynomial(int degree, SimpleMatrix Xd){
		
		// number of coefficients: numCoeff
		// (hint: this is NOT the total number of multiplications!)
		numCoeff = 0; //TODO
		
		// number of correspondences: numCorresp
		numCorresp =  0; //TODO
		
		// Printout of the used parameters
		System.out.println("Polynom of degree: " + degree);
		System.out.println("Number of Coefficients: " + numCoeff);
		System.out.println("Number of Correspondences: " + numCorresp);
		
	}
	
	/**
	 * 3. Create the matrix A
	 */
	
	public void computeMatrixA(int degree, int numCorresp, int numCoeff){
		
		A = new SimpleMatrix(numCorresp, numCoeff);
		if (numCorresp <= 0 && numCoeff <= 0)
			return;
		A.zeros();
		
		// Realign the grid matrix into a vector for easier access in the next step
		XuVector = new SimpleVector(numCorresp);
		YuVector = new SimpleVector(numCorresp);
		XdVector = new SimpleVector(numCorresp);
		YdVector = new SimpleVector(numCorresp);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){
				
				XuVector.setElementValue(i*ny + j, Xu.getElement(j, i));
				YuVector.setElementValue(i*ny + j, Yu.getElement(j, i));
				XdVector.setElementValue(i*ny + j, Xd.getElement(j, i));
				YdVector.setElementValue(i*ny + j, Yd.getElement(j, i));
			}
		}
		
		// Compute matrix A (coordinates from distorted image)
		for(int r = 0; r < numCorresp; r++){
			
			int cc = 0;
			
			for(int k = 0; k <= degree; k++){
				for(int l = 0; l <= (degree-k); l++){
					
					// TODO: fill matrix A
					cc++;
					
				}
			}
		}
	}
	
	public void computeDistortionCoeff(SimpleMatrix A, SimpleVector XuVector, SimpleVector YuVector){
		
		// Compute the pseudo-inverse of A with the help of the SVD (class: DecompositionSVD)
		svd = null; // TODO
	    A_pseudoinverse = null; // TODO
	  
		// Compute the distortion coefficients (solve for known corresponding undistorted points)
		u_vec = null;// TODO
		v_vec = null;// TODO
	}
	
	/**
	 * 4. Compute the distorted grid points (xDist, yDist) which are used to sample the
	 * distorted image to get the undistorted image
	 * (xprime,yprime) is the position in the undistorted image
	 * (xDist,yDist) is the position in the distorted (observed) X-ray image.
	 */
	public Grid2D computeDistortedGrid(Grid2D distortedImage, Grid2D grid_out, int degree){
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		xDist = new Grid2D(imageWidth,imageHeight);  
		yDist = new Grid2D(imageWidth,imageHeight); 
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float val1, val2; //variables Val1 and Val2 are used for intermediate computation of xDist and yDist respectively
				
				int cc = 0;
				
				for(int k = 0; k <= degree; k++){
					for(int l = 0; l <= degree - k; l++){
						
						val1 = 0;// TODO
						val2 = 0;// TODO
						
						// TODO: fill xDist
						// TODO: fill yDist
						
						cc++;
					}
				}
			}
		}
		
		float val; // variable for intermediate computations of undistorted image
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				// hint: consider the fact that the coordinate origin is in the center of the image
				val = 0;//TODO
				//TODO: fill grid_out
			}
		}
		
		return grid_out;
		
	}
	
	
	
	/**
	 * 
	 * end of the exercise
	 */	

	
	/**
	 * standard constructor
	 */
	public ExerciseGeoU(){
		
		this(0);
	}
		
	/**
	 * parameterized constructor for the ExerciseDPI object
	 * @param caseNo: select one of three images to test your undistortion method
	 */
	public ExerciseGeoU(int caseNo){
		
		switch (caseNo) {
		case 0:
			filename = "frame32.jpg";
			break;
		case 1:
			filename = "undistorted.jpg";
			break;
		case 2:
			filename = "frame90.jpg";
			break;
		default:
			filename = "frame32.jpg";
			break;
		}
		
		String imageDataLoc = System.getProperty("user.dir") + "/data/" + "/mipda/";
	
		originalImage = ImageUtil.wrapImagePlus(IJ.openImage(imageDataLoc + filename)).getSubGrid(0);
	}
	
	public void init(float a, float b, float d) {
		
		// Normalize intensity values to [0,1]
		float max = NumericPointwiseOperators.max(originalImage);
		float min = NumericPointwiseOperators.min(originalImage);
		
		for(int i = 0; i < originalImage.getWidth(); i++){
			for(int j = 0; j < originalImage.getHeight(); j++){
				
				float scaledValue = (originalImage.getAtIndex(i, j) - min) / (max-min);
				originalImage.setAtIndex(i, j, scaledValue);
			}
		}
		
		undistortedImage = new Grid2D(originalImage.getWidth(),originalImage.getHeight()); // initialization with zeros
		
		distortedImage = generateDistortedImage(originalImage,a,b,d);	
	}
	
	/**
	 * method to generate a distorted image
	 * An artificial distortion field is generated. With this field, 
	 * a distorted image is generated from the original image.
	 * Remark: coordinates of the latest distortion simulated are saved in class member variables
	 * @param inputImage: undistorted image on which distortion is simulated
	 * @param a: elliptic extent of the distortion in x-direction
	 * @param b: elliptic extent of the distortion in y-direction
	 * @param d: strength of the distortion
	 * @return: distorted image
	 */
    
	public Grid2D generateDistortedImage(Grid2D inputImage, float a, float b, float d){

		Grid2D grid = new Grid2D(inputImage);
		int imageWidth = grid.getWidth();
		int imageHeight = grid.getHeight();
		
		// generate grids to sample coordinates X and Y of the original image
		Grid2D X = new Grid2D(imageWidth,imageHeight); // x-coordinates with respect to origin in image center, spacing = 1 [unit]
		Grid2D Y = new Grid2D(imageWidth,imageHeight); // y-coordinates with respect to origin in image center, spacing = 1 [unit]
		
		float halfWidth = imageWidth / 2.0f;
		float halfHeight = imageHeight / 2.0f;
		
		for(int i = 0; i < X.getWidth(); i++){
			for(int j = 0; j < X.getHeight(); j++){
				
				X.setAtIndex(i, j, i - halfWidth + 0.5f); // assign pixel centers in x-direction
				Y.setAtIndex(i, j, j - halfHeight + 0.5f); // assign pixel center in y-direction
			}
		}
		
		// create an artificial elliptical distortion field R (additive field)
		Grid2D R = new Grid2D(imageWidth,imageHeight);

		for(int i = 0; i < R.getWidth(); i++){
			for(int j = 0; j < R.getHeight(); j++){
				
				// distortion gets stronger with the distance from the image center
				float r = d * (float)(Math.sqrt(
						Math.pow(X.getAtIndex(i, j)/(a*halfWidth),2)
						+ Math.pow(Y.getAtIndex(i, j)/(b*halfHeight),2)));
				R.setAtIndex(i, j, r);
			}
		}
		
		// shifting the positive range to half positive/half negative range
		float maxR = NumericPointwiseOperators.max(R);
		NumericPointwiseOperators.subtractBy(R, maxR * 0.5f);

		// create the distorted image coordinates:
		// distorted image coordinates = undistorted image points + artificial distortion field

		// distorted image coordinates Xd, Yd
		Grid2D Xd = new Grid2D(X);
		Grid2D Yd = new Grid2D(Y);
		
		NumericPointwiseOperators.addBy(Xd, R);
		NumericPointwiseOperators.addBy(Yd, R);
		
		// create the distorted image:
		// re-sample the original input image at the distorted image points (Xd,Yd) 
		// to create artificial distortion
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float distortedValue = InterpolationOperators.interpolateLinear(
						inputImage,
						Xd.getAtIndex(i, j) + halfWidth - 0.5f, // remember: coordinate origin was set to image center
						Yd.getAtIndex(i, j) + halfHeight - 0.5f);
				grid.setAtIndex(i, j, distortedValue);
			}
		}

		xprime = X;
		yprime = Y;
		x = Xd;
		y = Yd;
		
		return grid;	
	}	
	
	//getters for members
	// variables which are checked (DO NOT CHANGE!)
	
	public static int get_caseNo() {
		return caseNo;
	}
	
	public Grid2D get_originalImage() {
		return originalImage;
	}
	
	public Grid2D get_distortedImage() {
		return distortedImage;
	}
	
	public Grid2D get_undistortedImage() {
		return undistortedImage;
	}
	
	public int get_nx() {
		return nx;
	}
	
	public int get_ny() {
		return ny;
	}
	
	public float get_fx() {
		return fx;
	}
	
	public float get_fy() {
		return fy;
	}
	
	public SimpleMatrix get_Xu() {
		return Xu;
	}
	
	public SimpleMatrix get_Yu() {
		return Yu;
	}
	
	public SimpleMatrix get_Xd() {
		return Xd;
	}
	
	public SimpleMatrix get_Yd() {
		return Yd;
	}
	
	public int get_numCoeff() {
		return numCoeff;
	}
	
	public int get_numCorresp() {
		return numCorresp;
	}
	
	public SimpleMatrix get_A() {
		return A;
	}
	
	public DecompositionSVD get_svd() {
		return svd;
	}
	
	public SimpleMatrix get_A_pseudoinverse() {
		return A_pseudoinverse;
	}
	
	public SimpleVector get_u_vec() {
		return u_vec;
	}
	
	public SimpleVector get_v_vec() {
		return v_vec;
	}
	
	public SimpleVector get_XuVector() {
		return XuVector;
	}
	
	public SimpleVector get_YuVector() {
		return YuVector;
	}
	
	public SimpleVector get_XdVector() {
		return XdVector;
	}
	
	public SimpleVector get_YdVector() {
		return YdVector;
	}
	
	public Grid2D get_xDist() {
		return xDist;
	}
	
	public Grid2D get_yDist() {
		return yDist;
	}
	
	public Grid2D get_xprime() {
		return xprime;
	}
	
	public Grid2D get_yprime() {
		return yprime;
	}
	
	public Grid2D get_x() {
		return x;
	}
	
	public Grid2D get_y() {
		return y;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-15 23:56:39.879
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-15 23:56:39.879
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-15 23:56:41.472
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package edu.stanford.rsl.tutorial.mipda;

import edu.stanford.rsl.conrad.data.numeric.Grid2D;
import edu.stanford.rsl.conrad.data.numeric.NumericPointwiseOperators;
import edu.stanford.rsl.conrad.utils.ImageUtil;
//import edu.stanford.rsl.conrad.utils.VisualizationUtil;
import ij.IJ;
import ij.ImageJ;
import edu.stanford.rsl.conrad.data.numeric.InterpolationOperators;
//import edu.stanford.rsl.conrad.data.numeric.NumericGridOperator;
import edu.stanford.rsl.conrad.numerics.SimpleMatrix;
import edu.stanford.rsl.conrad.numerics.SimpleOperators;
import edu.stanford.rsl.conrad.numerics.SimpleVector;
import edu.stanford.rsl.conrad.numerics.DecompositionSVD;

/**
 * Geometric Undistortion
 * Programming exercise 1 for module "Defect Pixel Interpolation"
 * of the course "Medical Image Processing for Diagnostic Applications (MIPDA)"
 * @author Frank Schebesch, Ashwini Jadhav, Anna Gebhard, Mena Abdelmalek
 *
 */

public class ExerciseGeoU {

	final static int caseNo = 1; // choose 0, 1, or 2 for different test images

	final static float a = 0.6f; // a: spread among x-direction
	final static float b = 0.3f; // b: spread among y-direction
	final static float d = 5.0f; // d: d/2 value of distortion field at level set for (X/a)^2+(Y/b)^2=1
	
	String filename; // do not edit, choose a number in the main method instead
	Grid2D originalImage; // do not edit, read from filename when instantiating the object
	Grid2D distortedImage; // do not edit, generated in the main method
	Grid2D undistortedImage; // do not edit, member variable for the output image
	
	// number of lattice points
	final int nx = 8;//TODO: define the number of lattice point: nx (Positive number and less than 20)
	final int ny = 8;//TODO: define the number of lattice point: ny (Positive number and less than 20)
	
	float fx;
	float fy;
	SimpleMatrix Xu; 
	SimpleMatrix Yu;
	SimpleMatrix Xd;
	SimpleMatrix Yd;
	int numCoeff; 
	int numCorresp; 
	SimpleMatrix A;
	DecompositionSVD svd;
	SimpleMatrix A_pseudoinverse;
	SimpleVector u_vec;
	SimpleVector v_vec;
	SimpleVector XuVector;
	SimpleVector YuVector;
	SimpleVector XdVector;
	SimpleVector YdVector;
	Grid2D xDist;  
	Grid2D yDist;
	Grid2D xprime; // x-coordinates of point correspondences in the undistorted image
	Grid2D yprime; // y-coordinates of point correspondences in the undistorted image
	Grid2D x; // x-coordinates of point correspondences in the distorted image
	Grid2D y; // y-coordinates of point correspondences in the distorted image
	
	
	/** 
	 * main method
	 * Here you can choose the image, and set the distortion parameters
	 */
	public static void main(String[] args) {
		
		new ImageJ();
		
		// generate distorted image
		ExerciseGeoU exObj = new ExerciseGeoU(caseNo);
		exObj.init(a,b,d);
		
		// TASK: go to the method doImageUndistortion(...) and complete it 
		exObj.undistortedImage = exObj.doImageUndistortion(exObj.distortedImage);
		
		exObj.originalImage.show("Original Image");
		exObj.distortedImage.show("Distorted Image");
		exObj.undistortedImage.show("Undistorted Image");
		
		Grid2D differenceImage = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.originalImage, exObj.undistortedImage);
		
		differenceImage.show("Difference Original vs. Undistorted");
		
		Grid2D distortedVSundistorted = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.undistortedImage, exObj.distortedImage);
		
		distortedVSundistorted.show("Difference Undistorted vs. Distorted");
	}
	
	public Grid2D doImageUndistortion(Grid2D distortedImage){
		
		Grid2D grid = new Grid2D(distortedImage);
		
		// check if image distortion routine has been run
		if (distortedImage == null || undistortedImage == null
				|| xprime == null || yprime == null
				|| x == null || y == null) {
			
			System.err.println("Error in doImageUndistortion(): called before initialization of members.");
			return grid;
		}
		
		
		getLatticePoints(distortedImage);// There are TODOs here 
		
		
		int degree = 5; // polynomial's degree: 2,...,10
		calcPolynomial(degree, Xd);// There are TODOs here
		
		
		
		computeMatrixA(degree, numCorresp, numCoeff);// There are TODOs here
		
		
		computeDistortionCoeff(A, XuVector, YuVector);// There are TODOs here
		
		
		grid = computeDistortedGrid(distortedImage, grid, degree);// There are TODOs here
		
		return grid;
	}
	
	
	
	/** 1. Number of lattice points (this only works for symmetric images):
	 *  nx, ny feature points: usually provided by tracking point
	 *  correspondences in the phantom during the calibration step.
	 *  Here, we use the distorted and undistorted coordinates generated
	 *  in the course of the distortion simulation.
	 */ 
	public void getLatticePoints (Grid2D distortedImage){
		
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		// step size
		// calculate the step size of the lattice points: fx and fy 
		fx = imageWidth/nx; //TODO
		fy = imageHeight/ny; //TODO
		
		// fill the distorted and undistorted lattice points 
		// with data from the given correspondences
		// matrix = number of rows (y) x number of columns (x)
		Xu = new SimpleMatrix(ny,nx);
		Yu = new SimpleMatrix(ny,nx);
		Xd = new SimpleMatrix(ny,nx);
		Yd = new SimpleMatrix(ny,nx);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){

				// sample the distorted and undistorted grid points at the lattice points
				  Xu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx), j + intfy)));//TODO: fill matrix Xu
				  Yu.setElementValue(i, j, fy);//TODO: fill matrix Yu
				  Xd.setElementValue(i, j, fx);//TODO: fill matrix Xd
				  Yd.setElementValue(i, j, fy)//TODO: fill matrix Yd
			}
		}
	}
	
	/** 2. Polynomial of degree d
	 * Polynomial of degree d -> (d-1): extrema (e.g., d=5: 4 extrema)
	 * d=0: constant (horizontal line with y-intercept a_0 -> f(x)=a_0)
	 * d=1: oblique line with y-intercept a_0 & slope a_1 -> f(x)=a_0 + a_1 x
	 * d=2: parabola
	 * d>=2: continuous non-linear curve
	 * ...
	 * d = 10 -> NumCoeff: 66 -> but only 64 lattice points are known (nx, ny = 8)
	 */
	
	public void calcPolynomial(int degree, SimpleMatrix Xd){
		
		// number of coefficients: numCoeff
		// (hint: this is NOT the total number of multiplications!)
		numCoeff = 0; //TODO
		
		// number of correspondences: numCorresp
		numCorresp =  0; //TODO
		
		// Printout of the used parameters
		System.out.println("Polynom of degree: " + degree);
		System.out.println("Number of Coefficients: " + numCoeff);
		System.out.println("Number of Correspondences: " + numCorresp);
		
	}
	
	/**
	 * 3. Create the matrix A
	 */
	
	public void computeMatrixA(int degree, int numCorresp, int numCoeff){
		
		A = new SimpleMatrix(numCorresp, numCoeff);
		if (numCorresp <= 0 && numCoeff <= 0)
			return;
		A.zeros();
		
		// Realign the grid matrix into a vector for easier access in the next step
		XuVector = new SimpleVector(numCorresp);
		YuVector = new SimpleVector(numCorresp);
		XdVector = new SimpleVector(numCorresp);
		YdVector = new SimpleVector(numCorresp);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){
				
				XuVector.setElementValue(i*ny + j, Xu.getElement(j, i));
				YuVector.setElementValue(i*ny + j, Yu.getElement(j, i));
				XdVector.setElementValue(i*ny + j, Xd.getElement(j, i));
				YdVector.setElementValue(i*ny + j, Yd.getElement(j, i));
			}
		}
		
		// Compute matrix A (coordinates from distorted image)
		for(int r = 0; r < numCorresp; r++){
			
			int cc = 0;
			
			for(int k = 0; k <= degree; k++){
				for(int l = 0; l <= (degree-k); l++){
					
					// TODO: fill matrix A
					cc++;
					
				}
			}
		}
	}
	
	public void computeDistortionCoeff(SimpleMatrix A, SimpleVector XuVector, SimpleVector YuVector){
		
		// Compute the pseudo-inverse of A with the help of the SVD (class: DecompositionSVD)
		svd = null; // TODO
	    A_pseudoinverse = null; // TODO
	  
		// Compute the distortion coefficients (solve for known corresponding undistorted points)
		u_vec = null;// TODO
		v_vec = null;// TODO
	}
	
	/**
	 * 4. Compute the distorted grid points (xDist, yDist) which are used to sample the
	 * distorted image to get the undistorted image
	 * (xprime,yprime) is the position in the undistorted image
	 * (xDist,yDist) is the position in the distorted (observed) X-ray image.
	 */
	public Grid2D computeDistortedGrid(Grid2D distortedImage, Grid2D grid_out, int degree){
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		xDist = new Grid2D(imageWidth,imageHeight);  
		yDist = new Grid2D(imageWidth,imageHeight); 
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float val1, val2; //variables Val1 and Val2 are used for intermediate computation of xDist and yDist respectively
				
				int cc = 0;
				
				for(int k = 0; k <= degree; k++){
					for(int l = 0; l <= degree - k; l++){
						
						val1 = 0;// TODO
						val2 = 0;// TODO
						
						// TODO: fill xDist
						// TODO: fill yDist
						
						cc++;
					}
				}
			}
		}
		
		float val; // variable for intermediate computations of undistorted image
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				// hint: consider the fact that the coordinate origin is in the center of the image
				val = 0;//TODO
				//TODO: fill grid_out
			}
		}
		
		return grid_out;
		
	}
	
	
	
	/**
	 * 
	 * end of the exercise
	 */	

	
	/**
	 * standard constructor
	 */
	public ExerciseGeoU(){
		
		this(0);
	}
		
	/**
	 * parameterized constructor for the ExerciseDPI object
	 * @param caseNo: select one of three images to test your undistortion method
	 */
	public ExerciseGeoU(int caseNo){
		
		switch (caseNo) {
		case 0:
			filename = "frame32.jpg";
			break;
		case 1:
			filename = "undistorted.jpg";
			break;
		case 2:
			filename = "frame90.jpg";
			break;
		default:
			filename = "frame32.jpg";
			break;
		}
		
		String imageDataLoc = System.getProperty("user.dir") + "/data/" + "/mipda/";
	
		originalImage = ImageUtil.wrapImagePlus(IJ.openImage(imageDataLoc + filename)).getSubGrid(0);
	}
	
	public void init(float a, float b, float d) {
		
		// Normalize intensity values to [0,1]
		float max = NumericPointwiseOperators.max(originalImage);
		float min = NumericPointwiseOperators.min(originalImage);
		
		for(int i = 0; i < originalImage.getWidth(); i++){
			for(int j = 0; j < originalImage.getHeight(); j++){
				
				float scaledValue = (originalImage.getAtIndex(i, j) - min) / (max-min);
				originalImage.setAtIndex(i, j, scaledValue);
			}
		}
		
		undistortedImage = new Grid2D(originalImage.getWidth(),originalImage.getHeight()); // initialization with zeros
		
		distortedImage = generateDistortedImage(originalImage,a,b,d);	
	}
	
	/**
	 * method to generate a distorted image
	 * An artificial distortion field is generated. With this field, 
	 * a distorted image is generated from the original image.
	 * Remark: coordinates of the latest distortion simulated are saved in class member variables
	 * @param inputImage: undistorted image on which distortion is simulated
	 * @param a: elliptic extent of the distortion in x-direction
	 * @param b: elliptic extent of the distortion in y-direction
	 * @param d: strength of the distortion
	 * @return: distorted image
	 */
    
	public Grid2D generateDistortedImage(Grid2D inputImage, float a, float b, float d){

		Grid2D grid = new Grid2D(inputImage);
		int imageWidth = grid.getWidth();
		int imageHeight = grid.getHeight();
		
		// generate grids to sample coordinates X and Y of the original image
		Grid2D X = new Grid2D(imageWidth,imageHeight); // x-coordinates with respect to origin in image center, spacing = 1 [unit]
		Grid2D Y = new Grid2D(imageWidth,imageHeight); // y-coordinates with respect to origin in image center, spacing = 1 [unit]
		
		float halfWidth = imageWidth / 2.0f;
		float halfHeight = imageHeight / 2.0f;
		
		for(int i = 0; i < X.getWidth(); i++){
			for(int j = 0; j < X.getHeight(); j++){
				
				X.setAtIndex(i, j, i - halfWidth + 0.5f); // assign pixel centers in x-direction
				Y.setAtIndex(i, j, j - halfHeight + 0.5f); // assign pixel center in y-direction
			}
		}
		
		// create an artificial elliptical distortion field R (additive field)
		Grid2D R = new Grid2D(imageWidth,imageHeight);

		for(int i = 0; i < R.getWidth(); i++){
			for(int j = 0; j < R.getHeight(); j++){
				
				// distortion gets stronger with the distance from the image center
				float r = d * (float)(Math.sqrt(
						Math.pow(X.getAtIndex(i, j)/(a*halfWidth),2)
						+ Math.pow(Y.getAtIndex(i, j)/(b*halfHeight),2)));
				R.setAtIndex(i, j, r);
			}
		}
		
		// shifting the positive range to half positive/half negative range
		float maxR = NumericPointwiseOperators.max(R);
		NumericPointwiseOperators.subtractBy(R, maxR * 0.5f);

		// create the distorted image coordinates:
		// distorted image coordinates = undistorted image points + artificial distortion field

		// distorted image coordinates Xd, Yd
		Grid2D Xd = new Grid2D(X);
		Grid2D Yd = new Grid2D(Y);
		
		NumericPointwiseOperators.addBy(Xd, R);
		NumericPointwiseOperators.addBy(Yd, R);
		
		// create the distorted image:
		// re-sample the original input image at the distorted image points (Xd,Yd) 
		// to create artificial distortion
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float distortedValue = InterpolationOperators.interpolateLinear(
						inputImage,
						Xd.getAtIndex(i, j) + halfWidth - 0.5f, // remember: coordinate origin was set to image center
						Yd.getAtIndex(i, j) + halfHeight - 0.5f);
				grid.setAtIndex(i, j, distortedValue);
			}
		}

		xprime = X;
		yprime = Y;
		x = Xd;
		y = Yd;
		
		return grid;	
	}	
	
	//getters for members
	// variables which are checked (DO NOT CHANGE!)
	
	public static int get_caseNo() {
		return caseNo;
	}
	
	public Grid2D get_originalImage() {
		return originalImage;
	}
	
	public Grid2D get_distortedImage() {
		return distortedImage;
	}
	
	public Grid2D get_undistortedImage() {
		return undistortedImage;
	}
	
	public int get_nx() {
		return nx;
	}
	
	public int get_ny() {
		return ny;
	}
	
	public float get_fx() {
		return fx;
	}
	
	public float get_fy() {
		return fy;
	}
	
	public SimpleMatrix get_Xu() {
		return Xu;
	}
	
	public SimpleMatrix get_Yu() {
		return Yu;
	}
	
	public SimpleMatrix get_Xd() {
		return Xd;
	}
	
	public SimpleMatrix get_Yd() {
		return Yd;
	}
	
	public int get_numCoeff() {
		return numCoeff;
	}
	
	public int get_numCorresp() {
		return numCorresp;
	}
	
	public SimpleMatrix get_A() {
		return A;
	}
	
	public DecompositionSVD get_svd() {
		return svd;
	}
	
	public SimpleMatrix get_A_pseudoinverse() {
		return A_pseudoinverse;
	}
	
	public SimpleVector get_u_vec() {
		return u_vec;
	}
	
	public SimpleVector get_v_vec() {
		return v_vec;
	}
	
	public SimpleVector get_XuVector() {
		return XuVector;
	}
	
	public SimpleVector get_YuVector() {
		return YuVector;
	}
	
	public SimpleVector get_XdVector() {
		return XdVector;
	}
	
	public SimpleVector get_YdVector() {
		return YdVector;
	}
	
	public Grid2D get_xDist() {
		return xDist;
	}
	
	public Grid2D get_yDist() {
		return yDist;
	}
	
	public Grid2D get_xprime() {
		return xprime;
	}
	
	public Grid2D get_yprime() {
		return yprime;
	}
	
	public Grid2D get_x() {
		return x;
	}
	
	public Grid2D get_y() {
		return y;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-15 23:56:41.473
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-15 23:56:41.473
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-15 23:56:42.489
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package edu.stanford.rsl.tutorial.mipda;

import edu.stanford.rsl.conrad.data.numeric.Grid2D;
import edu.stanford.rsl.conrad.data.numeric.NumericPointwiseOperators;
import edu.stanford.rsl.conrad.utils.ImageUtil;
//import edu.stanford.rsl.conrad.utils.VisualizationUtil;
import ij.IJ;
import ij.ImageJ;
import edu.stanford.rsl.conrad.data.numeric.InterpolationOperators;
//import edu.stanford.rsl.conrad.data.numeric.NumericGridOperator;
import edu.stanford.rsl.conrad.numerics.SimpleMatrix;
import edu.stanford.rsl.conrad.numerics.SimpleOperators;
import edu.stanford.rsl.conrad.numerics.SimpleVector;
import edu.stanford.rsl.conrad.numerics.DecompositionSVD;

/**
 * Geometric Undistortion
 * Programming exercise 1 for module "Defect Pixel Interpolation"
 * of the course "Medical Image Processing for Diagnostic Applications (MIPDA)"
 * @author Frank Schebesch, Ashwini Jadhav, Anna Gebhard, Mena Abdelmalek
 *
 */

public class ExerciseGeoU {

	final static int caseNo = 1; // choose 0, 1, or 2 for different test images

	final static float a = 0.6f; // a: spread among x-direction
	final static float b = 0.3f; // b: spread among y-direction
	final static float d = 5.0f; // d: d/2 value of distortion field at level set for (X/a)^2+(Y/b)^2=1
	
	String filename; // do not edit, choose a number in the main method instead
	Grid2D originalImage; // do not edit, read from filename when instantiating the object
	Grid2D distortedImage; // do not edit, generated in the main method
	Grid2D undistortedImage; // do not edit, member variable for the output image
	
	// number of lattice points
	final int nx = 8;//TODO: define the number of lattice point: nx (Positive number and less than 20)
	final int ny = 8;//TODO: define the number of lattice point: ny (Positive number and less than 20)
	
	float fx;
	float fy;
	SimpleMatrix Xu; 
	SimpleMatrix Yu;
	SimpleMatrix Xd;
	SimpleMatrix Yd;
	int numCoeff; 
	int numCorresp; 
	SimpleMatrix A;
	DecompositionSVD svd;
	SimpleMatrix A_pseudoinverse;
	SimpleVector u_vec;
	SimpleVector v_vec;
	SimpleVector XuVector;
	SimpleVector YuVector;
	SimpleVector XdVector;
	SimpleVector YdVector;
	Grid2D xDist;  
	Grid2D yDist;
	Grid2D xprime; // x-coordinates of point correspondences in the undistorted image
	Grid2D yprime; // y-coordinates of point correspondences in the undistorted image
	Grid2D x; // x-coordinates of point correspondences in the distorted image
	Grid2D y; // y-coordinates of point correspondences in the distorted image
	
	
	/** 
	 * main method
	 * Here you can choose the image, and set the distortion parameters
	 */
	public static void main(String[] args) {
		
		new ImageJ();
		
		// generate distorted image
		ExerciseGeoU exObj = new ExerciseGeoU(caseNo);
		exObj.init(a,b,d);
		
		// TASK: go to the method doImageUndistortion(...) and complete it 
		exObj.undistortedImage = exObj.doImageUndistortion(exObj.distortedImage);
		
		exObj.originalImage.show("Original Image");
		exObj.distortedImage.show("Distorted Image");
		exObj.undistortedImage.show("Undistorted Image");
		
		Grid2D differenceImage = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.originalImage, exObj.undistortedImage);
		
		differenceImage.show("Difference Original vs. Undistorted");
		
		Grid2D distortedVSundistorted = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.undistortedImage, exObj.distortedImage);
		
		distortedVSundistorted.show("Difference Undistorted vs. Distorted");
	}
	
	public Grid2D doImageUndistortion(Grid2D distortedImage){
		
		Grid2D grid = new Grid2D(distortedImage);
		
		// check if image distortion routine has been run
		if (distortedImage == null || undistortedImage == null
				|| xprime == null || yprime == null
				|| x == null || y == null) {
			
			System.err.println("Error in doImageUndistortion(): called before initialization of members.");
			return grid;
		}
		
		
		getLatticePoints(distortedImage);// There are TODOs here 
		
		
		int degree = 5; // polynomial's degree: 2,...,10
		calcPolynomial(degree, Xd);// There are TODOs here
		
		
		
		computeMatrixA(degree, numCorresp, numCoeff);// There are TODOs here
		
		
		computeDistortionCoeff(A, XuVector, YuVector);// There are TODOs here
		
		
		grid = computeDistortedGrid(distortedImage, grid, degree);// There are TODOs here
		
		return grid;
	}
	
	
	
	/** 1. Number of lattice points (this only works for symmetric images):
	 *  nx, ny feature points: usually provided by tracking point
	 *  correspondences in the phantom during the calibration step.
	 *  Here, we use the distorted and undistorted coordinates generated
	 *  in the course of the distortion simulation.
	 */ 
	public void getLatticePoints (Grid2D distortedImage){
		
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		// step size
		// calculate the step size of the lattice points: fx and fy 
		fx = imageWidth/nx; //TODO
		fy = imageHeight/ny; //TODO
		
		// fill the distorted and undistorted lattice points 
		// with data from the given correspondences
		// matrix = number of rows (y) x number of columns (x)
		Xu = new SimpleMatrix(ny,nx);
		Yu = new SimpleMatrix(ny,nx);
		Xd = new SimpleMatrix(ny,nx);
		Yd = new SimpleMatrix(ny,nx);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){

				// sample the distorted and undistorted grid points at the lattice points
				  Xu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx), j + int(fy)));//TODO: fill matrix Xu
				  Yu.setElementValue(i, j, fy);//TODO: fill matrix Yu
				  Xd.setElementValue(i, j, fx);//TODO: fill matrix Xd
				  Yd.setElementValue(i, j, fy)//TODO: fill matrix Yd
			}
		}
	}
	
	/** 2. Polynomial of degree d
	 * Polynomial of degree d -> (d-1): extrema (e.g., d=5: 4 extrema)
	 * d=0: constant (horizontal line with y-intercept a_0 -> f(x)=a_0)
	 * d=1: oblique line with y-intercept a_0 & slope a_1 -> f(x)=a_0 + a_1 x
	 * d=2: parabola
	 * d>=2: continuous non-linear curve
	 * ...
	 * d = 10 -> NumCoeff: 66 -> but only 64 lattice points are known (nx, ny = 8)
	 */
	
	public void calcPolynomial(int degree, SimpleMatrix Xd){
		
		// number of coefficients: numCoeff
		// (hint: this is NOT the total number of multiplications!)
		numCoeff = 0; //TODO
		
		// number of correspondences: numCorresp
		numCorresp =  0; //TODO
		
		// Printout of the used parameters
		System.out.println("Polynom of degree: " + degree);
		System.out.println("Number of Coefficients: " + numCoeff);
		System.out.println("Number of Correspondences: " + numCorresp);
		
	}
	
	/**
	 * 3. Create the matrix A
	 */
	
	public void computeMatrixA(int degree, int numCorresp, int numCoeff){
		
		A = new SimpleMatrix(numCorresp, numCoeff);
		if (numCorresp <= 0 && numCoeff <= 0)
			return;
		A.zeros();
		
		// Realign the grid matrix into a vector for easier access in the next step
		XuVector = new SimpleVector(numCorresp);
		YuVector = new SimpleVector(numCorresp);
		XdVector = new SimpleVector(numCorresp);
		YdVector = new SimpleVector(numCorresp);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){
				
				XuVector.setElementValue(i*ny + j, Xu.getElement(j, i));
				YuVector.setElementValue(i*ny + j, Yu.getElement(j, i));
				XdVector.setElementValue(i*ny + j, Xd.getElement(j, i));
				YdVector.setElementValue(i*ny + j, Yd.getElement(j, i));
			}
		}
		
		// Compute matrix A (coordinates from distorted image)
		for(int r = 0; r < numCorresp; r++){
			
			int cc = 0;
			
			for(int k = 0; k <= degree; k++){
				for(int l = 0; l <= (degree-k); l++){
					
					// TODO: fill matrix A
					cc++;
					
				}
			}
		}
	}
	
	public void computeDistortionCoeff(SimpleMatrix A, SimpleVector XuVector, SimpleVector YuVector){
		
		// Compute the pseudo-inverse of A with the help of the SVD (class: DecompositionSVD)
		svd = null; // TODO
	    A_pseudoinverse = null; // TODO
	  
		// Compute the distortion coefficients (solve for known corresponding undistorted points)
		u_vec = null;// TODO
		v_vec = null;// TODO
	}
	
	/**
	 * 4. Compute the distorted grid points (xDist, yDist) which are used to sample the
	 * distorted image to get the undistorted image
	 * (xprime,yprime) is the position in the undistorted image
	 * (xDist,yDist) is the position in the distorted (observed) X-ray image.
	 */
	public Grid2D computeDistortedGrid(Grid2D distortedImage, Grid2D grid_out, int degree){
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		xDist = new Grid2D(imageWidth,imageHeight);  
		yDist = new Grid2D(imageWidth,imageHeight); 
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float val1, val2; //variables Val1 and Val2 are used for intermediate computation of xDist and yDist respectively
				
				int cc = 0;
				
				for(int k = 0; k <= degree; k++){
					for(int l = 0; l <= degree - k; l++){
						
						val1 = 0;// TODO
						val2 = 0;// TODO
						
						// TODO: fill xDist
						// TODO: fill yDist
						
						cc++;
					}
				}
			}
		}
		
		float val; // variable for intermediate computations of undistorted image
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				// hint: consider the fact that the coordinate origin is in the center of the image
				val = 0;//TODO
				//TODO: fill grid_out
			}
		}
		
		return grid_out;
		
	}
	
	
	
	/**
	 * 
	 * end of the exercise
	 */	

	
	/**
	 * standard constructor
	 */
	public ExerciseGeoU(){
		
		this(0);
	}
		
	/**
	 * parameterized constructor for the ExerciseDPI object
	 * @param caseNo: select one of three images to test your undistortion method
	 */
	public ExerciseGeoU(int caseNo){
		
		switch (caseNo) {
		case 0:
			filename = "frame32.jpg";
			break;
		case 1:
			filename = "undistorted.jpg";
			break;
		case 2:
			filename = "frame90.jpg";
			break;
		default:
			filename = "frame32.jpg";
			break;
		}
		
		String imageDataLoc = System.getProperty("user.dir") + "/data/" + "/mipda/";
	
		originalImage = ImageUtil.wrapImagePlus(IJ.openImage(imageDataLoc + filename)).getSubGrid(0);
	}
	
	public void init(float a, float b, float d) {
		
		// Normalize intensity values to [0,1]
		float max = NumericPointwiseOperators.max(originalImage);
		float min = NumericPointwiseOperators.min(originalImage);
		
		for(int i = 0; i < originalImage.getWidth(); i++){
			for(int j = 0; j < originalImage.getHeight(); j++){
				
				float scaledValue = (originalImage.getAtIndex(i, j) - min) / (max-min);
				originalImage.setAtIndex(i, j, scaledValue);
			}
		}
		
		undistortedImage = new Grid2D(originalImage.getWidth(),originalImage.getHeight()); // initialization with zeros
		
		distortedImage = generateDistortedImage(originalImage,a,b,d);	
	}
	
	/**
	 * method to generate a distorted image
	 * An artificial distortion field is generated. With this field, 
	 * a distorted image is generated from the original image.
	 * Remark: coordinates of the latest distortion simulated are saved in class member variables
	 * @param inputImage: undistorted image on which distortion is simulated
	 * @param a: elliptic extent of the distortion in x-direction
	 * @param b: elliptic extent of the distortion in y-direction
	 * @param d: strength of the distortion
	 * @return: distorted image
	 */
    
	public Grid2D generateDistortedImage(Grid2D inputImage, float a, float b, float d){

		Grid2D grid = new Grid2D(inputImage);
		int imageWidth = grid.getWidth();
		int imageHeight = grid.getHeight();
		
		// generate grids to sample coordinates X and Y of the original image
		Grid2D X = new Grid2D(imageWidth,imageHeight); // x-coordinates with respect to origin in image center, spacing = 1 [unit]
		Grid2D Y = new Grid2D(imageWidth,imageHeight); // y-coordinates with respect to origin in image center, spacing = 1 [unit]
		
		float halfWidth = imageWidth / 2.0f;
		float halfHeight = imageHeight / 2.0f;
		
		for(int i = 0; i < X.getWidth(); i++){
			for(int j = 0; j < X.getHeight(); j++){
				
				X.setAtIndex(i, j, i - halfWidth + 0.5f); // assign pixel centers in x-direction
				Y.setAtIndex(i, j, j - halfHeight + 0.5f); // assign pixel center in y-direction
			}
		}
		
		// create an artificial elliptical distortion field R (additive field)
		Grid2D R = new Grid2D(imageWidth,imageHeight);

		for(int i = 0; i < R.getWidth(); i++){
			for(int j = 0; j < R.getHeight(); j++){
				
				// distortion gets stronger with the distance from the image center
				float r = d * (float)(Math.sqrt(
						Math.pow(X.getAtIndex(i, j)/(a*halfWidth),2)
						+ Math.pow(Y.getAtIndex(i, j)/(b*halfHeight),2)));
				R.setAtIndex(i, j, r);
			}
		}
		
		// shifting the positive range to half positive/half negative range
		float maxR = NumericPointwiseOperators.max(R);
		NumericPointwiseOperators.subtractBy(R, maxR * 0.5f);

		// create the distorted image coordinates:
		// distorted image coordinates = undistorted image points + artificial distortion field

		// distorted image coordinates Xd, Yd
		Grid2D Xd = new Grid2D(X);
		Grid2D Yd = new Grid2D(Y);
		
		NumericPointwiseOperators.addBy(Xd, R);
		NumericPointwiseOperators.addBy(Yd, R);
		
		// create the distorted image:
		// re-sample the original input image at the distorted image points (Xd,Yd) 
		// to create artificial distortion
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float distortedValue = InterpolationOperators.interpolateLinear(
						inputImage,
						Xd.getAtIndex(i, j) + halfWidth - 0.5f, // remember: coordinate origin was set to image center
						Yd.getAtIndex(i, j) + halfHeight - 0.5f);
				grid.setAtIndex(i, j, distortedValue);
			}
		}

		xprime = X;
		yprime = Y;
		x = Xd;
		y = Yd;
		
		return grid;	
	}	
	
	//getters for members
	// variables which are checked (DO NOT CHANGE!)
	
	public static int get_caseNo() {
		return caseNo;
	}
	
	public Grid2D get_originalImage() {
		return originalImage;
	}
	
	public Grid2D get_distortedImage() {
		return distortedImage;
	}
	
	public Grid2D get_undistortedImage() {
		return undistortedImage;
	}
	
	public int get_nx() {
		return nx;
	}
	
	public int get_ny() {
		return ny;
	}
	
	public float get_fx() {
		return fx;
	}
	
	public float get_fy() {
		return fy;
	}
	
	public SimpleMatrix get_Xu() {
		return Xu;
	}
	
	public SimpleMatrix get_Yu() {
		return Yu;
	}
	
	public SimpleMatrix get_Xd() {
		return Xd;
	}
	
	public SimpleMatrix get_Yd() {
		return Yd;
	}
	
	public int get_numCoeff() {
		return numCoeff;
	}
	
	public int get_numCorresp() {
		return numCorresp;
	}
	
	public SimpleMatrix get_A() {
		return A;
	}
	
	public DecompositionSVD get_svd() {
		return svd;
	}
	
	public SimpleMatrix get_A_pseudoinverse() {
		return A_pseudoinverse;
	}
	
	public SimpleVector get_u_vec() {
		return u_vec;
	}
	
	public SimpleVector get_v_vec() {
		return v_vec;
	}
	
	public SimpleVector get_XuVector() {
		return XuVector;
	}
	
	public SimpleVector get_YuVector() {
		return YuVector;
	}
	
	public SimpleVector get_XdVector() {
		return XdVector;
	}
	
	public SimpleVector get_YdVector() {
		return YdVector;
	}
	
	public Grid2D get_xDist() {
		return xDist;
	}
	
	public Grid2D get_yDist() {
		return yDist;
	}
	
	public Grid2D get_xprime() {
		return xprime;
	}
	
	public Grid2D get_yprime() {
		return yprime;
	}
	
	public Grid2D get_x() {
		return x;
	}
	
	public Grid2D get_y() {
		return y;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-15 23:56:42.489
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-15 23:56:42.490
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-15 23:56:42.508
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package edu.stanford.rsl.tutorial.mipda;

import edu.stanford.rsl.conrad.data.numeric.Grid2D;
import edu.stanford.rsl.conrad.data.numeric.NumericPointwiseOperators;
import edu.stanford.rsl.conrad.utils.ImageUtil;
//import edu.stanford.rsl.conrad.utils.VisualizationUtil;
import ij.IJ;
import ij.ImageJ;
import edu.stanford.rsl.conrad.data.numeric.InterpolationOperators;
//import edu.stanford.rsl.conrad.data.numeric.NumericGridOperator;
import edu.stanford.rsl.conrad.numerics.SimpleMatrix;
import edu.stanford.rsl.conrad.numerics.SimpleOperators;
import edu.stanford.rsl.conrad.numerics.SimpleVector;
import edu.stanford.rsl.conrad.numerics.DecompositionSVD;

/**
 * Geometric Undistortion
 * Programming exercise 1 for module "Defect Pixel Interpolation"
 * of the course "Medical Image Processing for Diagnostic Applications (MIPDA)"
 * @author Frank Schebesch, Ashwini Jadhav, Anna Gebhard, Mena Abdelmalek
 *
 */

public class ExerciseGeoU {

	final static int caseNo = 1; // choose 0, 1, or 2 for different test images

	final static float a = 0.6f; // a: spread among x-direction
	final static float b = 0.3f; // b: spread among y-direction
	final static float d = 5.0f; // d: d/2 value of distortion field at level set for (X/a)^2+(Y/b)^2=1
	
	String filename; // do not edit, choose a number in the main method instead
	Grid2D originalImage; // do not edit, read from filename when instantiating the object
	Grid2D distortedImage; // do not edit, generated in the main method
	Grid2D undistortedImage; // do not edit, member variable for the output image
	
	// number of lattice points
	final int nx = 8;//TODO: define the number of lattice point: nx (Positive number and less than 20)
	final int ny = 8;//TODO: define the number of lattice point: ny (Positive number and less than 20)
	
	float fx;
	float fy;
	SimpleMatrix Xu; 
	SimpleMatrix Yu;
	SimpleMatrix Xd;
	SimpleMatrix Yd;
	int numCoeff; 
	int numCorresp; 
	SimpleMatrix A;
	DecompositionSVD svd;
	SimpleMatrix A_pseudoinverse;
	SimpleVector u_vec;
	SimpleVector v_vec;
	SimpleVector XuVector;
	SimpleVector YuVector;
	SimpleVector XdVector;
	SimpleVector YdVector;
	Grid2D xDist;  
	Grid2D yDist;
	Grid2D xprime; // x-coordinates of point correspondences in the undistorted image
	Grid2D yprime; // y-coordinates of point correspondences in the undistorted image
	Grid2D x; // x-coordinates of point correspondences in the distorted image
	Grid2D y; // y-coordinates of point correspondences in the distorted image
	
	
	/** 
	 * main method
	 * Here you can choose the image, and set the distortion parameters
	 */
	public static void main(String[] args) {
		
		new ImageJ();
		
		// generate distorted image
		ExerciseGeoU exObj = new ExerciseGeoU(caseNo);
		exObj.init(a,b,d);
		
		// TASK: go to the method doImageUndistortion(...) and complete it 
		exObj.undistortedImage = exObj.doImageUndistortion(exObj.distortedImage);
		
		exObj.originalImage.show("Original Image");
		exObj.distortedImage.show("Distorted Image");
		exObj.undistortedImage.show("Undistorted Image");
		
		Grid2D differenceImage = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.originalImage, exObj.undistortedImage);
		
		differenceImage.show("Difference Original vs. Undistorted");
		
		Grid2D distortedVSundistorted = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.undistortedImage, exObj.distortedImage);
		
		distortedVSundistorted.show("Difference Undistorted vs. Distorted");
	}
	
	public Grid2D doImageUndistortion(Grid2D distortedImage){
		
		Grid2D grid = new Grid2D(distortedImage);
		
		// check if image distortion routine has been run
		if (distortedImage == null || undistortedImage == null
				|| xprime == null || yprime == null
				|| x == null || y == null) {
			
			System.err.println("Error in doImageUndistortion(): called before initialization of members.");
			return grid;
		}
		
		
		getLatticePoints(distortedImage);// There are TODOs here 
		
		
		int degree = 5; // polynomial's degree: 2,...,10
		calcPolynomial(degree, Xd);// There are TODOs here
		
		
		
		computeMatrixA(degree, numCorresp, numCoeff);// There are TODOs here
		
		
		computeDistortionCoeff(A, XuVector, YuVector);// There are TODOs here
		
		
		grid = computeDistortedGrid(distortedImage, grid, degree);// There are TODOs here
		
		return grid;
	}
	
	
	
	/** 1. Number of lattice points (this only works for symmetric images):
	 *  nx, ny feature points: usually provided by tracking point
	 *  correspondences in the phantom during the calibration step.
	 *  Here, we use the distorted and undistorted coordinates generated
	 *  in the course of the distortion simulation.
	 */ 
	public void getLatticePoints (Grid2D distortedImage){
		
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		// step size
		// calculate the step size of the lattice points: fx and fy 
		fx = imageWidth/nx; //TODO
		fy = imageHeight/ny; //TODO
		
		// fill the distorted and undistorted lattice points 
		// with data from the given correspondences
		// matrix = number of rows (y) x number of columns (x)
		Xu = new SimpleMatrix(ny,nx);
		Yu = new SimpleMatrix(ny,nx);
		Xd = new SimpleMatrix(ny,nx);
		Yd = new SimpleMatrix(ny,nx);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){

				// sample the distorted and undistorted grid points at the lattice points
				  Xu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx), j + int(fy)));//TODO: fill matrix Xu
				  Yu.setElementValue(i, j, fy);//TODO: fill matrix Yu
				  Xd.setElementValue(i, j, fx);//TODO: fill matrix Xd
				  Yd.setElementValue(i, j, fy)//TODO: fill matrix Yd
			}
		}
	}
	
	/** 2. Polynomial of degree d
	 * Polynomial of degree d -> (d-1): extrema (e.g., d=5: 4 extrema)
	 * d=0: constant (horizontal line with y-intercept a_0 -> f(x)=a_0)
	 * d=1: oblique line with y-intercept a_0 & slope a_1 -> f(x)=a_0 + a_1 x
	 * d=2: parabola
	 * d>=2: continuous non-linear curve
	 * ...
	 * d = 10 -> NumCoeff: 66 -> but only 64 lattice points are known (nx, ny = 8)
	 */
	
	public void calcPolynomial(int degree, SimpleMatrix Xd){
		
		// number of coefficients: numCoeff
		// (hint: this is NOT the total number of multiplications!)
		numCoeff = 0; //TODO
		
		// number of correspondences: numCorresp
		numCorresp =  0; //TODO
		
		// Printout of the used parameters
		System.out.println("Polynom of degree: " + degree);
		System.out.println("Number of Coefficients: " + numCoeff);
		System.out.println("Number of Correspondences: " + numCorresp);
		
	}
	
	/**
	 * 3. Create the matrix A
	 */
	
	public void computeMatrixA(int degree, int numCorresp, int numCoeff){
		
		A = new SimpleMatrix(numCorresp, numCoeff);
		if (numCorresp <= 0 && numCoeff <= 0)
			return;
		A.zeros();
		
		// Realign the grid matrix into a vector for easier access in the next step
		XuVector = new SimpleVector(numCorresp);
		YuVector = new SimpleVector(numCorresp);
		XdVector = new SimpleVector(numCorresp);
		YdVector = new SimpleVector(numCorresp);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){
				
				XuVector.setElementValue(i*ny + j, Xu.getElement(j, i));
				YuVector.setElementValue(i*ny + j, Yu.getElement(j, i));
				XdVector.setElementValue(i*ny + j, Xd.getElement(j, i));
				YdVector.setElementValue(i*ny + j, Yd.getElement(j, i));
			}
		}
		
		// Compute matrix A (coordinates from distorted image)
		for(int r = 0; r < numCorresp; r++){
			
			int cc = 0;
			
			for(int k = 0; k <= degree; k++){
				for(int l = 0; l <= (degree-k); l++){
					
					// TODO: fill matrix A
					cc++;
					
				}
			}
		}
	}
	
	public void computeDistortionCoeff(SimpleMatrix A, SimpleVector XuVector, SimpleVector YuVector){
		
		// Compute the pseudo-inverse of A with the help of the SVD (class: DecompositionSVD)
		svd = null; // TODO
	    A_pseudoinverse = null; // TODO
	  
		// Compute the distortion coefficients (solve for known corresponding undistorted points)
		u_vec = null;// TODO
		v_vec = null;// TODO
	}
	
	/**
	 * 4. Compute the distorted grid points (xDist, yDist) which are used to sample the
	 * distorted image to get the undistorted image
	 * (xprime,yprime) is the position in the undistorted image
	 * (xDist,yDist) is the position in the distorted (observed) X-ray image.
	 */
	public Grid2D computeDistortedGrid(Grid2D distortedImage, Grid2D grid_out, int degree){
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		xDist = new Grid2D(imageWidth,imageHeight);  
		yDist = new Grid2D(imageWidth,imageHeight); 
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float val1, val2; //variables Val1 and Val2 are used for intermediate computation of xDist and yDist respectively
				
				int cc = 0;
				
				for(int k = 0; k <= degree; k++){
					for(int l = 0; l <= degree - k; l++){
						
						val1 = 0;// TODO
						val2 = 0;// TODO
						
						// TODO: fill xDist
						// TODO: fill yDist
						
						cc++;
					}
				}
			}
		}
		
		float val; // variable for intermediate computations of undistorted image
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				// hint: consider the fact that the coordinate origin is in the center of the image
				val = 0;//TODO
				//TODO: fill grid_out
			}
		}
		
		return grid_out;
		
	}
	
	
	
	/**
	 * 
	 * end of the exercise
	 */	

	
	/**
	 * standard constructor
	 */
	public ExerciseGeoU(){
		
		this(0);
	}
		
	/**
	 * parameterized constructor for the ExerciseDPI object
	 * @param caseNo: select one of three images to test your undistortion method
	 */
	public ExerciseGeoU(int caseNo){
		
		switch (caseNo) {
		case 0:
			filename = "frame32.jpg";
			break;
		case 1:
			filename = "undistorted.jpg";
			break;
		case 2:
			filename = "frame90.jpg";
			break;
		default:
			filename = "frame32.jpg";
			break;
		}
		
		String imageDataLoc = System.getProperty("user.dir") + "/data/" + "/mipda/";
	
		originalImage = ImageUtil.wrapImagePlus(IJ.openImage(imageDataLoc + filename)).getSubGrid(0);
	}
	
	public void init(float a, float b, float d) {
		
		// Normalize intensity values to [0,1]
		float max = NumericPointwiseOperators.max(originalImage);
		float min = NumericPointwiseOperators.min(originalImage);
		
		for(int i = 0; i < originalImage.getWidth(); i++){
			for(int j = 0; j < originalImage.getHeight(); j++){
				
				float scaledValue = (originalImage.getAtIndex(i, j) - min) / (max-min);
				originalImage.setAtIndex(i, j, scaledValue);
			}
		}
		
		undistortedImage = new Grid2D(originalImage.getWidth(),originalImage.getHeight()); // initialization with zeros
		
		distortedImage = generateDistortedImage(originalImage,a,b,d);	
	}
	
	/**
	 * method to generate a distorted image
	 * An artificial distortion field is generated. With this field, 
	 * a distorted image is generated from the original image.
	 * Remark: coordinates of the latest distortion simulated are saved in class member variables
	 * @param inputImage: undistorted image on which distortion is simulated
	 * @param a: elliptic extent of the distortion in x-direction
	 * @param b: elliptic extent of the distortion in y-direction
	 * @param d: strength of the distortion
	 * @return: distorted image
	 */
    
	public Grid2D generateDistortedImage(Grid2D inputImage, float a, float b, float d){

		Grid2D grid = new Grid2D(inputImage);
		int imageWidth = grid.getWidth();
		int imageHeight = grid.getHeight();
		
		// generate grids to sample coordinates X and Y of the original image
		Grid2D X = new Grid2D(imageWidth,imageHeight); // x-coordinates with respect to origin in image center, spacing = 1 [unit]
		Grid2D Y = new Grid2D(imageWidth,imageHeight); // y-coordinates with respect to origin in image center, spacing = 1 [unit]
		
		float halfWidth = imageWidth / 2.0f;
		float halfHeight = imageHeight / 2.0f;
		
		for(int i = 0; i < X.getWidth(); i++){
			for(int j = 0; j < X.getHeight(); j++){
				
				X.setAtIndex(i, j, i - halfWidth + 0.5f); // assign pixel centers in x-direction
				Y.setAtIndex(i, j, j - halfHeight + 0.5f); // assign pixel center in y-direction
			}
		}
		
		// create an artificial elliptical distortion field R (additive field)
		Grid2D R = new Grid2D(imageWidth,imageHeight);

		for(int i = 0; i < R.getWidth(); i++){
			for(int j = 0; j < R.getHeight(); j++){
				
				// distortion gets stronger with the distance from the image center
				float r = d * (float)(Math.sqrt(
						Math.pow(X.getAtIndex(i, j)/(a*halfWidth),2)
						+ Math.pow(Y.getAtIndex(i, j)/(b*halfHeight),2)));
				R.setAtIndex(i, j, r);
			}
		}
		
		// shifting the positive range to half positive/half negative range
		float maxR = NumericPointwiseOperators.max(R);
		NumericPointwiseOperators.subtractBy(R, maxR * 0.5f);

		// create the distorted image coordinates:
		// distorted image coordinates = undistorted image points + artificial distortion field

		// distorted image coordinates Xd, Yd
		Grid2D Xd = new Grid2D(X);
		Grid2D Yd = new Grid2D(Y);
		
		NumericPointwiseOperators.addBy(Xd, R);
		NumericPointwiseOperators.addBy(Yd, R);
		
		// create the distorted image:
		// re-sample the original input image at the distorted image points (Xd,Yd) 
		// to create artificial distortion
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float distortedValue = InterpolationOperators.interpolateLinear(
						inputImage,
						Xd.getAtIndex(i, j) + halfWidth - 0.5f, // remember: coordinate origin was set to image center
						Yd.getAtIndex(i, j) + halfHeight - 0.5f);
				grid.setAtIndex(i, j, distortedValue);
			}
		}

		xprime = X;
		yprime = Y;
		x = Xd;
		y = Yd;
		
		return grid;	
	}	
	
	//getters for members
	// variables which are checked (DO NOT CHANGE!)
	
	public static int get_caseNo() {
		return caseNo;
	}
	
	public Grid2D get_originalImage() {
		return originalImage;
	}
	
	public Grid2D get_distortedImage() {
		return distortedImage;
	}
	
	public Grid2D get_undistortedImage() {
		return undistortedImage;
	}
	
	public int get_nx() {
		return nx;
	}
	
	public int get_ny() {
		return ny;
	}
	
	public float get_fx() {
		return fx;
	}
	
	public float get_fy() {
		return fy;
	}
	
	public SimpleMatrix get_Xu() {
		return Xu;
	}
	
	public SimpleMatrix get_Yu() {
		return Yu;
	}
	
	public SimpleMatrix get_Xd() {
		return Xd;
	}
	
	public SimpleMatrix get_Yd() {
		return Yd;
	}
	
	public int get_numCoeff() {
		return numCoeff;
	}
	
	public int get_numCorresp() {
		return numCorresp;
	}
	
	public SimpleMatrix get_A() {
		return A;
	}
	
	public DecompositionSVD get_svd() {
		return svd;
	}
	
	public SimpleMatrix get_A_pseudoinverse() {
		return A_pseudoinverse;
	}
	
	public SimpleVector get_u_vec() {
		return u_vec;
	}
	
	public SimpleVector get_v_vec() {
		return v_vec;
	}
	
	public SimpleVector get_XuVector() {
		return XuVector;
	}
	
	public SimpleVector get_YuVector() {
		return YuVector;
	}
	
	public SimpleVector get_XdVector() {
		return XdVector;
	}
	
	public SimpleVector get_YdVector() {
		return YdVector;
	}
	
	public Grid2D get_xDist() {
		return xDist;
	}
	
	public Grid2D get_yDist() {
		return yDist;
	}
	
	public Grid2D get_xprime() {
		return xprime;
	}
	
	public Grid2D get_yprime() {
		return yprime;
	}
	
	public Grid2D get_x() {
		return x;
	}
	
	public Grid2D get_y() {
		return y;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-15 23:56:42.509
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-15 23:56:42.509
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-15 23:56:42.584
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package edu.stanford.rsl.tutorial.mipda;

import edu.stanford.rsl.conrad.data.numeric.Grid2D;
import edu.stanford.rsl.conrad.data.numeric.NumericPointwiseOperators;
import edu.stanford.rsl.conrad.utils.ImageUtil;
//import edu.stanford.rsl.conrad.utils.VisualizationUtil;
import ij.IJ;
import ij.ImageJ;
import edu.stanford.rsl.conrad.data.numeric.InterpolationOperators;
//import edu.stanford.rsl.conrad.data.numeric.NumericGridOperator;
import edu.stanford.rsl.conrad.numerics.SimpleMatrix;
import edu.stanford.rsl.conrad.numerics.SimpleOperators;
import edu.stanford.rsl.conrad.numerics.SimpleVector;
import edu.stanford.rsl.conrad.numerics.DecompositionSVD;

/**
 * Geometric Undistortion
 * Programming exercise 1 for module "Defect Pixel Interpolation"
 * of the course "Medical Image Processing for Diagnostic Applications (MIPDA)"
 * @author Frank Schebesch, Ashwini Jadhav, Anna Gebhard, Mena Abdelmalek
 *
 */

public class ExerciseGeoU {

	final static int caseNo = 1; // choose 0, 1, or 2 for different test images

	final static float a = 0.6f; // a: spread among x-direction
	final static float b = 0.3f; // b: spread among y-direction
	final static float d = 5.0f; // d: d/2 value of distortion field at level set for (X/a)^2+(Y/b)^2=1
	
	String filename; // do not edit, choose a number in the main method instead
	Grid2D originalImage; // do not edit, read from filename when instantiating the object
	Grid2D distortedImage; // do not edit, generated in the main method
	Grid2D undistortedImage; // do not edit, member variable for the output image
	
	// number of lattice points
	final int nx = 8;//TODO: define the number of lattice point: nx (Positive number and less than 20)
	final int ny = 8;//TODO: define the number of lattice point: ny (Positive number and less than 20)
	
	float fx;
	float fy;
	SimpleMatrix Xu; 
	SimpleMatrix Yu;
	SimpleMatrix Xd;
	SimpleMatrix Yd;
	int numCoeff; 
	int numCorresp; 
	SimpleMatrix A;
	DecompositionSVD svd;
	SimpleMatrix A_pseudoinverse;
	SimpleVector u_vec;
	SimpleVector v_vec;
	SimpleVector XuVector;
	SimpleVector YuVector;
	SimpleVector XdVector;
	SimpleVector YdVector;
	Grid2D xDist;  
	Grid2D yDist;
	Grid2D xprime; // x-coordinates of point correspondences in the undistorted image
	Grid2D yprime; // y-coordinates of point correspondences in the undistorted image
	Grid2D x; // x-coordinates of point correspondences in the distorted image
	Grid2D y; // y-coordinates of point correspondences in the distorted image
	
	
	/** 
	 * main method
	 * Here you can choose the image, and set the distortion parameters
	 */
	public static void main(String[] args) {
		
		new ImageJ();
		
		// generate distorted image
		ExerciseGeoU exObj = new ExerciseGeoU(caseNo);
		exObj.init(a,b,d);
		
		// TASK: go to the method doImageUndistortion(...) and complete it 
		exObj.undistortedImage = exObj.doImageUndistortion(exObj.distortedImage);
		
		exObj.originalImage.show("Original Image");
		exObj.distortedImage.show("Distorted Image");
		exObj.undistortedImage.show("Undistorted Image");
		
		Grid2D differenceImage = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.originalImage, exObj.undistortedImage);
		
		differenceImage.show("Difference Original vs. Undistorted");
		
		Grid2D distortedVSundistorted = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.undistortedImage, exObj.distortedImage);
		
		distortedVSundistorted.show("Difference Undistorted vs. Distorted");
	}
	
	public Grid2D doImageUndistortion(Grid2D distortedImage){
		
		Grid2D grid = new Grid2D(distortedImage);
		
		// check if image distortion routine has been run
		if (distortedImage == null || undistortedImage == null
				|| xprime == null || yprime == null
				|| x == null || y == null) {
			
			System.err.println("Error in doImageUndistortion(): called before initialization of members.");
			return grid;
		}
		
		
		getLatticePoints(distortedImage);// There are TODOs here 
		
		
		int degree = 5; // polynomial's degree: 2,...,10
		calcPolynomial(degree, Xd);// There are TODOs here
		
		
		
		computeMatrixA(degree, numCorresp, numCoeff);// There are TODOs here
		
		
		computeDistortionCoeff(A, XuVector, YuVector);// There are TODOs here
		
		
		grid = computeDistortedGrid(distortedImage, grid, degree);// There are TODOs here
		
		return grid;
	}
	
	
	
	/** 1. Number of lattice points (this only works for symmetric images):
	 *  nx, ny feature points: usually provided by tracking point
	 *  correspondences in the phantom during the calibration step.
	 *  Here, we use the distorted and undistorted coordinates generated
	 *  in the course of the distortion simulation.
	 */ 
	public void getLatticePoints (Grid2D distortedImage){
		
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		// step size
		// calculate the step size of the lattice points: fx and fy 
		fx = imageWidth/nx; //TODO
		fy = imageHeight/ny; //TODO
		
		// fill the distorted and undistorted lattice points 
		// with data from the given correspondences
		// matrix = number of rows (y) x number of columns (x)
		Xu = new SimpleMatrix(ny,nx);
		Yu = new SimpleMatrix(ny,nx);
		Xd = new SimpleMatrix(ny,nx);
		Yd = new SimpleMatrix(ny,nx);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){

				// sample the distorted and undistorted grid points at the lattice points
				  Xu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx), j + int(fy)));//TODO: fill matrix Xu
				  Yu.setElementValue(i, j, fy);//TODO: fill matrix Yu
				  Xd.setElementValue(i, j, fx);//TODO: fill matrix Xd
				  Yd.setElementValue(i, j, fy)//TODO: fill matrix Yd
			}
		}
	}
	
	/** 2. Polynomial of degree d
	 * Polynomial of degree d -> (d-1): extrema (e.g., d=5: 4 extrema)
	 * d=0: constant (horizontal line with y-intercept a_0 -> f(x)=a_0)
	 * d=1: oblique line with y-intercept a_0 & slope a_1 -> f(x)=a_0 + a_1 x
	 * d=2: parabola
	 * d>=2: continuous non-linear curve
	 * ...
	 * d = 10 -> NumCoeff: 66 -> but only 64 lattice points are known (nx, ny = 8)
	 */
	
	public void calcPolynomial(int degree, SimpleMatrix Xd){
		
		// number of coefficients: numCoeff
		// (hint: this is NOT the total number of multiplications!)
		numCoeff = 0; //TODO
		
		// number of correspondences: numCorresp
		numCorresp =  0; //TODO
		
		// Printout of the used parameters
		System.out.println("Polynom of degree: " + degree);
		System.out.println("Number of Coefficients: " + numCoeff);
		System.out.println("Number of Correspondences: " + numCorresp);
		
	}
	
	/**
	 * 3. Create the matrix A
	 */
	
	public void computeMatrixA(int degree, int numCorresp, int numCoeff){
		
		A = new SimpleMatrix(numCorresp, numCoeff);
		if (numCorresp <= 0 && numCoeff <= 0)
			return;
		A.zeros();
		
		// Realign the grid matrix into a vector for easier access in the next step
		XuVector = new SimpleVector(numCorresp);
		YuVector = new SimpleVector(numCorresp);
		XdVector = new SimpleVector(numCorresp);
		YdVector = new SimpleVector(numCorresp);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){
				
				XuVector.setElementValue(i*ny + j, Xu.getElement(j, i));
				YuVector.setElementValue(i*ny + j, Yu.getElement(j, i));
				XdVector.setElementValue(i*ny + j, Xd.getElement(j, i));
				YdVector.setElementValue(i*ny + j, Yd.getElement(j, i));
			}
		}
		
		// Compute matrix A (coordinates from distorted image)
		for(int r = 0; r < numCorresp; r++){
			
			int cc = 0;
			
			for(int k = 0; k <= degree; k++){
				for(int l = 0; l <= (degree-k); l++){
					
					// TODO: fill matrix A
					cc++;
					
				}
			}
		}
	}
	
	public void computeDistortionCoeff(SimpleMatrix A, SimpleVector XuVector, SimpleVector YuVector){
		
		// Compute the pseudo-inverse of A with the help of the SVD (class: DecompositionSVD)
		svd = null; // TODO
	    A_pseudoinverse = null; // TODO
	  
		// Compute the distortion coefficients (solve for known corresponding undistorted points)
		u_vec = null;// TODO
		v_vec = null;// TODO
	}
	
	/**
	 * 4. Compute the distorted grid points (xDist, yDist) which are used to sample the
	 * distorted image to get the undistorted image
	 * (xprime,yprime) is the position in the undistorted image
	 * (xDist,yDist) is the position in the distorted (observed) X-ray image.
	 */
	public Grid2D computeDistortedGrid(Grid2D distortedImage, Grid2D grid_out, int degree){
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		xDist = new Grid2D(imageWidth,imageHeight);  
		yDist = new Grid2D(imageWidth,imageHeight); 
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float val1, val2; //variables Val1 and Val2 are used for intermediate computation of xDist and yDist respectively
				
				int cc = 0;
				
				for(int k = 0; k <= degree; k++){
					for(int l = 0; l <= degree - k; l++){
						
						val1 = 0;// TODO
						val2 = 0;// TODO
						
						// TODO: fill xDist
						// TODO: fill yDist
						
						cc++;
					}
				}
			}
		}
		
		float val; // variable for intermediate computations of undistorted image
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				// hint: consider the fact that the coordinate origin is in the center of the image
				val = 0;//TODO
				//TODO: fill grid_out
			}
		}
		
		return grid_out;
		
	}
	
	
	
	/**
	 * 
	 * end of the exercise
	 */	

	
	/**
	 * standard constructor
	 */
	public ExerciseGeoU(){
		
		this(0);
	}
		
	/**
	 * parameterized constructor for the ExerciseDPI object
	 * @param caseNo: select one of three images to test your undistortion method
	 */
	public ExerciseGeoU(int caseNo){
		
		switch (caseNo) {
		case 0:
			filename = "frame32.jpg";
			break;
		case 1:
			filename = "undistorted.jpg";
			break;
		case 2:
			filename = "frame90.jpg";
			break;
		default:
			filename = "frame32.jpg";
			break;
		}
		
		String imageDataLoc = System.getProperty("user.dir") + "/data/" + "/mipda/";
	
		originalImage = ImageUtil.wrapImagePlus(IJ.openImage(imageDataLoc + filename)).getSubGrid(0);
	}
	
	public void init(float a, float b, float d) {
		
		// Normalize intensity values to [0,1]
		float max = NumericPointwiseOperators.max(originalImage);
		float min = NumericPointwiseOperators.min(originalImage);
		
		for(int i = 0; i < originalImage.getWidth(); i++){
			for(int j = 0; j < originalImage.getHeight(); j++){
				
				float scaledValue = (originalImage.getAtIndex(i, j) - min) / (max-min);
				originalImage.setAtIndex(i, j, scaledValue);
			}
		}
		
		undistortedImage = new Grid2D(originalImage.getWidth(),originalImage.getHeight()); // initialization with zeros
		
		distortedImage = generateDistortedImage(originalImage,a,b,d);	
	}
	
	/**
	 * method to generate a distorted image
	 * An artificial distortion field is generated. With this field, 
	 * a distorted image is generated from the original image.
	 * Remark: coordinates of the latest distortion simulated are saved in class member variables
	 * @param inputImage: undistorted image on which distortion is simulated
	 * @param a: elliptic extent of the distortion in x-direction
	 * @param b: elliptic extent of the distortion in y-direction
	 * @param d: strength of the distortion
	 * @return: distorted image
	 */
    
	public Grid2D generateDistortedImage(Grid2D inputImage, float a, float b, float d){

		Grid2D grid = new Grid2D(inputImage);
		int imageWidth = grid.getWidth();
		int imageHeight = grid.getHeight();
		
		// generate grids to sample coordinates X and Y of the original image
		Grid2D X = new Grid2D(imageWidth,imageHeight); // x-coordinates with respect to origin in image center, spacing = 1 [unit]
		Grid2D Y = new Grid2D(imageWidth,imageHeight); // y-coordinates with respect to origin in image center, spacing = 1 [unit]
		
		float halfWidth = imageWidth / 2.0f;
		float halfHeight = imageHeight / 2.0f;
		
		for(int i = 0; i < X.getWidth(); i++){
			for(int j = 0; j < X.getHeight(); j++){
				
				X.setAtIndex(i, j, i - halfWidth + 0.5f); // assign pixel centers in x-direction
				Y.setAtIndex(i, j, j - halfHeight + 0.5f); // assign pixel center in y-direction
			}
		}
		
		// create an artificial elliptical distortion field R (additive field)
		Grid2D R = new Grid2D(imageWidth,imageHeight);

		for(int i = 0; i < R.getWidth(); i++){
			for(int j = 0; j < R.getHeight(); j++){
				
				// distortion gets stronger with the distance from the image center
				float r = d * (float)(Math.sqrt(
						Math.pow(X.getAtIndex(i, j)/(a*halfWidth),2)
						+ Math.pow(Y.getAtIndex(i, j)/(b*halfHeight),2)));
				R.setAtIndex(i, j, r);
			}
		}
		
		// shifting the positive range to half positive/half negative range
		float maxR = NumericPointwiseOperators.max(R);
		NumericPointwiseOperators.subtractBy(R, maxR * 0.5f);

		// create the distorted image coordinates:
		// distorted image coordinates = undistorted image points + artificial distortion field

		// distorted image coordinates Xd, Yd
		Grid2D Xd = new Grid2D(X);
		Grid2D Yd = new Grid2D(Y);
		
		NumericPointwiseOperators.addBy(Xd, R);
		NumericPointwiseOperators.addBy(Yd, R);
		
		// create the distorted image:
		// re-sample the original input image at the distorted image points (Xd,Yd) 
		// to create artificial distortion
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float distortedValue = InterpolationOperators.interpolateLinear(
						inputImage,
						Xd.getAtIndex(i, j) + halfWidth - 0.5f, // remember: coordinate origin was set to image center
						Yd.getAtIndex(i, j) + halfHeight - 0.5f);
				grid.setAtIndex(i, j, distortedValue);
			}
		}

		xprime = X;
		yprime = Y;
		x = Xd;
		y = Yd;
		
		return grid;	
	}	
	
	//getters for members
	// variables which are checked (DO NOT CHANGE!)
	
	public static int get_caseNo() {
		return caseNo;
	}
	
	public Grid2D get_originalImage() {
		return originalImage;
	}
	
	public Grid2D get_distortedImage() {
		return distortedImage;
	}
	
	public Grid2D get_undistortedImage() {
		return undistortedImage;
	}
	
	public int get_nx() {
		return nx;
	}
	
	public int get_ny() {
		return ny;
	}
	
	public float get_fx() {
		return fx;
	}
	
	public float get_fy() {
		return fy;
	}
	
	public SimpleMatrix get_Xu() {
		return Xu;
	}
	
	public SimpleMatrix get_Yu() {
		return Yu;
	}
	
	public SimpleMatrix get_Xd() {
		return Xd;
	}
	
	public SimpleMatrix get_Yd() {
		return Yd;
	}
	
	public int get_numCoeff() {
		return numCoeff;
	}
	
	public int get_numCorresp() {
		return numCorresp;
	}
	
	public SimpleMatrix get_A() {
		return A;
	}
	
	public DecompositionSVD get_svd() {
		return svd;
	}
	
	public SimpleMatrix get_A_pseudoinverse() {
		return A_pseudoinverse;
	}
	
	public SimpleVector get_u_vec() {
		return u_vec;
	}
	
	public SimpleVector get_v_vec() {
		return v_vec;
	}
	
	public SimpleVector get_XuVector() {
		return XuVector;
	}
	
	public SimpleVector get_YuVector() {
		return YuVector;
	}
	
	public SimpleVector get_XdVector() {
		return XdVector;
	}
	
	public SimpleVector get_YdVector() {
		return YdVector;
	}
	
	public Grid2D get_xDist() {
		return xDist;
	}
	
	public Grid2D get_yDist() {
		return yDist;
	}
	
	public Grid2D get_xprime() {
		return xprime;
	}
	
	public Grid2D get_yprime() {
		return yprime;
	}
	
	public Grid2D get_x() {
		return x;
	}
	
	public Grid2D get_y() {
		return y;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-15 23:56:42.585
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-15 23:56:42.586
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-15 23:56:44.098
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package edu.stanford.rsl.tutorial.mipda;

import edu.stanford.rsl.conrad.data.numeric.Grid2D;
import edu.stanford.rsl.conrad.data.numeric.NumericPointwiseOperators;
import edu.stanford.rsl.conrad.utils.ImageUtil;
//import edu.stanford.rsl.conrad.utils.VisualizationUtil;
import ij.IJ;
import ij.ImageJ;
import edu.stanford.rsl.conrad.data.numeric.InterpolationOperators;
//import edu.stanford.rsl.conrad.data.numeric.NumericGridOperator;
import edu.stanford.rsl.conrad.numerics.SimpleMatrix;
import edu.stanford.rsl.conrad.numerics.SimpleOperators;
import edu.stanford.rsl.conrad.numerics.SimpleVector;
import edu.stanford.rsl.conrad.numerics.DecompositionSVD;

/**
 * Geometric Undistortion
 * Programming exercise 1 for module "Defect Pixel Interpolation"
 * of the course "Medical Image Processing for Diagnostic Applications (MIPDA)"
 * @author Frank Schebesch, Ashwini Jadhav, Anna Gebhard, Mena Abdelmalek
 *
 */

public class ExerciseGeoU {

	final static int caseNo = 1; // choose 0, 1, or 2 for different test images

	final static float a = 0.6f; // a: spread among x-direction
	final static float b = 0.3f; // b: spread among y-direction
	final static float d = 5.0f; // d: d/2 value of distortion field at level set for (X/a)^2+(Y/b)^2=1
	
	String filename; // do not edit, choose a number in the main method instead
	Grid2D originalImage; // do not edit, read from filename when instantiating the object
	Grid2D distortedImage; // do not edit, generated in the main method
	Grid2D undistortedImage; // do not edit, member variable for the output image
	
	// number of lattice points
	final int nx = 8;//TODO: define the number of lattice point: nx (Positive number and less than 20)
	final int ny = 8;//TODO: define the number of lattice point: ny (Positive number and less than 20)
	
	float fx;
	float fy;
	SimpleMatrix Xu; 
	SimpleMatrix Yu;
	SimpleMatrix Xd;
	SimpleMatrix Yd;
	int numCoeff; 
	int numCorresp; 
	SimpleMatrix A;
	DecompositionSVD svd;
	SimpleMatrix A_pseudoinverse;
	SimpleVector u_vec;
	SimpleVector v_vec;
	SimpleVector XuVector;
	SimpleVector YuVector;
	SimpleVector XdVector;
	SimpleVector YdVector;
	Grid2D xDist;  
	Grid2D yDist;
	Grid2D xprime; // x-coordinates of point correspondences in the undistorted image
	Grid2D yprime; // y-coordinates of point correspondences in the undistorted image
	Grid2D x; // x-coordinates of point correspondences in the distorted image
	Grid2D y; // y-coordinates of point correspondences in the distorted image
	
	
	/** 
	 * main method
	 * Here you can choose the image, and set the distortion parameters
	 */
	public static void main(String[] args) {
		
		new ImageJ();
		
		// generate distorted image
		ExerciseGeoU exObj = new ExerciseGeoU(caseNo);
		exObj.init(a,b,d);
		
		// TASK: go to the method doImageUndistortion(...) and complete it 
		exObj.undistortedImage = exObj.doImageUndistortion(exObj.distortedImage);
		
		exObj.originalImage.show("Original Image");
		exObj.distortedImage.show("Distorted Image");
		exObj.undistortedImage.show("Undistorted Image");
		
		Grid2D differenceImage = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.originalImage, exObj.undistortedImage);
		
		differenceImage.show("Difference Original vs. Undistorted");
		
		Grid2D distortedVSundistorted = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.undistortedImage, exObj.distortedImage);
		
		distortedVSundistorted.show("Difference Undistorted vs. Distorted");
	}
	
	public Grid2D doImageUndistortion(Grid2D distortedImage){
		
		Grid2D grid = new Grid2D(distortedImage);
		
		// check if image distortion routine has been run
		if (distortedImage == null || undistortedImage == null
				|| xprime == null || yprime == null
				|| x == null || y == null) {
			
			System.err.println("Error in doImageUndistortion(): called before initialization of members.");
			return grid;
		}
		
		
		getLatticePoints(distortedImage);// There are TODOs here 
		
		
		int degree = 5; // polynomial's degree: 2,...,10
		calcPolynomial(degree, Xd);// There are TODOs here
		
		
		
		computeMatrixA(degree, numCorresp, numCoeff);// There are TODOs here
		
		
		computeDistortionCoeff(A, XuVector, YuVector);// There are TODOs here
		
		
		grid = computeDistortedGrid(distortedImage, grid, degree);// There are TODOs here
		
		return grid;
	}
	
	
	
	/** 1. Number of lattice points (this only works for symmetric images):
	 *  nx, ny feature points: usually provided by tracking point
	 *  correspondences in the phantom during the calibration step.
	 *  Here, we use the distorted and undistorted coordinates generated
	 *  in the course of the distortion simulation.
	 */ 
	public void getLatticePoints (Grid2D distortedImage){
		
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		// step size
		// calculate the step size of the lattice points: fx and fy 
		fx = imageWidth/nx; //TODO
		fy = imageHeight/ny; //TODO
		
		// fill the distorted and undistorted lattice points 
		// with data from the given correspondences
		// matrix = number of rows (y) x number of columns (x)
		Xu = new SimpleMatrix(ny,nx);
		Yu = new SimpleMatrix(ny,nx);
		Xd = new SimpleMatrix(ny,nx);
		Yd = new SimpleMatrix(ny,nx);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){

				// sample the distorted and undistorted grid points at the lattice points
				  Xu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx), j + int(fy)));//TODO: fill matrix Xu
				  Yu.setElementValue(i, j, fy);//TODO: fill matrix Yu
				  Xd.setElementValue(i, j, fx);//TODO: fill matrix Xd
				  Yd.setElementValue(i, j, fy)//TODO: fill matrix Yd
			}
		}
	}
	
	/** 2. Polynomial of degree d
	 * Polynomial of degree d -> (d-1): extrema (e.g., d=5: 4 extrema)
	 * d=0: constant (horizontal line with y-intercept a_0 -> f(x)=a_0)
	 * d=1: oblique line with y-intercept a_0 & slope a_1 -> f(x)=a_0 + a_1 x
	 * d=2: parabola
	 * d>=2: continuous non-linear curve
	 * ...
	 * d = 10 -> NumCoeff: 66 -> but only 64 lattice points are known (nx, ny = 8)
	 */
	
	public void calcPolynomial(int degree, SimpleMatrix Xd){
		
		// number of coefficients: numCoeff
		// (hint: this is NOT the total number of multiplications!)
		numCoeff = 0; //TODO
		
		// number of correspondences: numCorresp
		numCorresp =  0; //TODO
		
		// Printout of the used parameters
		System.out.println("Polynom of degree: " + degree);
		System.out.println("Number of Coefficients: " + numCoeff);
		System.out.println("Number of Correspondences: " + numCorresp);
		
	}
	
	/**
	 * 3. Create the matrix A
	 */
	
	public void computeMatrixA(int degree, int numCorresp, int numCoeff){
		
		A = new SimpleMatrix(numCorresp, numCoeff);
		if (numCorresp <= 0 && numCoeff <= 0)
			return;
		A.zeros();
		
		// Realign the grid matrix into a vector for easier access in the next step
		XuVector = new SimpleVector(numCorresp);
		YuVector = new SimpleVector(numCorresp);
		XdVector = new SimpleVector(numCorresp);
		YdVector = new SimpleVector(numCorresp);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){
				
				XuVector.setElementValue(i*ny + j, Xu.getElement(j, i));
				YuVector.setElementValue(i*ny + j, Yu.getElement(j, i));
				XdVector.setElementValue(i*ny + j, Xd.getElement(j, i));
				YdVector.setElementValue(i*ny + j, Yd.getElement(j, i));
			}
		}
		
		// Compute matrix A (coordinates from distorted image)
		for(int r = 0; r < numCorresp; r++){
			
			int cc = 0;
			
			for(int k = 0; k <= degree; k++){
				for(int l = 0; l <= (degree-k); l++){
					
					// TODO: fill matrix A
					cc++;
					
				}
			}
		}
	}
	
	public void computeDistortionCoeff(SimpleMatrix A, SimpleVector XuVector, SimpleVector YuVector){
		
		// Compute the pseudo-inverse of A with the help of the SVD (class: DecompositionSVD)
		svd = null; // TODO
	    A_pseudoinverse = null; // TODO
	  
		// Compute the distortion coefficients (solve for known corresponding undistorted points)
		u_vec = null;// TODO
		v_vec = null;// TODO
	}
	
	/**
	 * 4. Compute the distorted grid points (xDist, yDist) which are used to sample the
	 * distorted image to get the undistorted image
	 * (xprime,yprime) is the position in the undistorted image
	 * (xDist,yDist) is the position in the distorted (observed) X-ray image.
	 */
	public Grid2D computeDistortedGrid(Grid2D distortedImage, Grid2D grid_out, int degree){
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		xDist = new Grid2D(imageWidth,imageHeight);  
		yDist = new Grid2D(imageWidth,imageHeight); 
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float val1, val2; //variables Val1 and Val2 are used for intermediate computation of xDist and yDist respectively
				
				int cc = 0;
				
				for(int k = 0; k <= degree; k++){
					for(int l = 0; l <= degree - k; l++){
						
						val1 = 0;// TODO
						val2 = 0;// TODO
						
						// TODO: fill xDist
						// TODO: fill yDist
						
						cc++;
					}
				}
			}
		}
		
		float val; // variable for intermediate computations of undistorted image
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				// hint: consider the fact that the coordinate origin is in the center of the image
				val = 0;//TODO
				//TODO: fill grid_out
			}
		}
		
		return grid_out;
		
	}
	
	
	
	/**
	 * 
	 * end of the exercise
	 */	

	
	/**
	 * standard constructor
	 */
	public ExerciseGeoU(){
		
		this(0);
	}
		
	/**
	 * parameterized constructor for the ExerciseDPI object
	 * @param caseNo: select one of three images to test your undistortion method
	 */
	public ExerciseGeoU(int caseNo){
		
		switch (caseNo) {
		case 0:
			filename = "frame32.jpg";
			break;
		case 1:
			filename = "undistorted.jpg";
			break;
		case 2:
			filename = "frame90.jpg";
			break;
		default:
			filename = "frame32.jpg";
			break;
		}
		
		String imageDataLoc = System.getProperty("user.dir") + "/data/" + "/mipda/";
	
		originalImage = ImageUtil.wrapImagePlus(IJ.openImage(imageDataLoc + filename)).getSubGrid(0);
	}
	
	public void init(float a, float b, float d) {
		
		// Normalize intensity values to [0,1]
		float max = NumericPointwiseOperators.max(originalImage);
		float min = NumericPointwiseOperators.min(originalImage);
		
		for(int i = 0; i < originalImage.getWidth(); i++){
			for(int j = 0; j < originalImage.getHeight(); j++){
				
				float scaledValue = (originalImage.getAtIndex(i, j) - min) / (max-min);
				originalImage.setAtIndex(i, j, scaledValue);
			}
		}
		
		undistortedImage = new Grid2D(originalImage.getWidth(),originalImage.getHeight()); // initialization with zeros
		
		distortedImage = generateDistortedImage(originalImage,a,b,d);	
	}
	
	/**
	 * method to generate a distorted image
	 * An artificial distortion field is generated. With this field, 
	 * a distorted image is generated from the original image.
	 * Remark: coordinates of the latest distortion simulated are saved in class member variables
	 * @param inputImage: undistorted image on which distortion is simulated
	 * @param a: elliptic extent of the distortion in x-direction
	 * @param b: elliptic extent of the distortion in y-direction
	 * @param d: strength of the distortion
	 * @return: distorted image
	 */
    
	public Grid2D generateDistortedImage(Grid2D inputImage, float a, float b, float d){

		Grid2D grid = new Grid2D(inputImage);
		int imageWidth = grid.getWidth();
		int imageHeight = grid.getHeight();
		
		// generate grids to sample coordinates X and Y of the original image
		Grid2D X = new Grid2D(imageWidth,imageHeight); // x-coordinates with respect to origin in image center, spacing = 1 [unit]
		Grid2D Y = new Grid2D(imageWidth,imageHeight); // y-coordinates with respect to origin in image center, spacing = 1 [unit]
		
		float halfWidth = imageWidth / 2.0f;
		float halfHeight = imageHeight / 2.0f;
		
		for(int i = 0; i < X.getWidth(); i++){
			for(int j = 0; j < X.getHeight(); j++){
				
				X.setAtIndex(i, j, i - halfWidth + 0.5f); // assign pixel centers in x-direction
				Y.setAtIndex(i, j, j - halfHeight + 0.5f); // assign pixel center in y-direction
			}
		}
		
		// create an artificial elliptical distortion field R (additive field)
		Grid2D R = new Grid2D(imageWidth,imageHeight);

		for(int i = 0; i < R.getWidth(); i++){
			for(int j = 0; j < R.getHeight(); j++){
				
				// distortion gets stronger with the distance from the image center
				float r = d * (float)(Math.sqrt(
						Math.pow(X.getAtIndex(i, j)/(a*halfWidth),2)
						+ Math.pow(Y.getAtIndex(i, j)/(b*halfHeight),2)));
				R.setAtIndex(i, j, r);
			}
		}
		
		// shifting the positive range to half positive/half negative range
		float maxR = NumericPointwiseOperators.max(R);
		NumericPointwiseOperators.subtractBy(R, maxR * 0.5f);

		// create the distorted image coordinates:
		// distorted image coordinates = undistorted image points + artificial distortion field

		// distorted image coordinates Xd, Yd
		Grid2D Xd = new Grid2D(X);
		Grid2D Yd = new Grid2D(Y);
		
		NumericPointwiseOperators.addBy(Xd, R);
		NumericPointwiseOperators.addBy(Yd, R);
		
		// create the distorted image:
		// re-sample the original input image at the distorted image points (Xd,Yd) 
		// to create artificial distortion
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float distortedValue = InterpolationOperators.interpolateLinear(
						inputImage,
						Xd.getAtIndex(i, j) + halfWidth - 0.5f, // remember: coordinate origin was set to image center
						Yd.getAtIndex(i, j) + halfHeight - 0.5f);
				grid.setAtIndex(i, j, distortedValue);
			}
		}

		xprime = X;
		yprime = Y;
		x = Xd;
		y = Yd;
		
		return grid;	
	}	
	
	//getters for members
	// variables which are checked (DO NOT CHANGE!)
	
	public static int get_caseNo() {
		return caseNo;
	}
	
	public Grid2D get_originalImage() {
		return originalImage;
	}
	
	public Grid2D get_distortedImage() {
		return distortedImage;
	}
	
	public Grid2D get_undistortedImage() {
		return undistortedImage;
	}
	
	public int get_nx() {
		return nx;
	}
	
	public int get_ny() {
		return ny;
	}
	
	public float get_fx() {
		return fx;
	}
	
	public float get_fy() {
		return fy;
	}
	
	public SimpleMatrix get_Xu() {
		return Xu;
	}
	
	public SimpleMatrix get_Yu() {
		return Yu;
	}
	
	public SimpleMatrix get_Xd() {
		return Xd;
	}
	
	public SimpleMatrix get_Yd() {
		return Yd;
	}
	
	public int get_numCoeff() {
		return numCoeff;
	}
	
	public int get_numCorresp() {
		return numCorresp;
	}
	
	public SimpleMatrix get_A() {
		return A;
	}
	
	public DecompositionSVD get_svd() {
		return svd;
	}
	
	public SimpleMatrix get_A_pseudoinverse() {
		return A_pseudoinverse;
	}
	
	public SimpleVector get_u_vec() {
		return u_vec;
	}
	
	public SimpleVector get_v_vec() {
		return v_vec;
	}
	
	public SimpleVector get_XuVector() {
		return XuVector;
	}
	
	public SimpleVector get_YuVector() {
		return YuVector;
	}
	
	public SimpleVector get_XdVector() {
		return XdVector;
	}
	
	public SimpleVector get_YdVector() {
		return YdVector;
	}
	
	public Grid2D get_xDist() {
		return xDist;
	}
	
	public Grid2D get_yDist() {
		return yDist;
	}
	
	public Grid2D get_xprime() {
		return xprime;
	}
	
	public Grid2D get_yprime() {
		return yprime;
	}
	
	public Grid2D get_x() {
		return x;
	}
	
	public Grid2D get_y() {
		return y;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-15 23:56:44.098
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-15 23:56:44.099
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-15 23:56:46.629
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package edu.stanford.rsl.tutorial.mipda;

import edu.stanford.rsl.conrad.data.numeric.Grid2D;
import edu.stanford.rsl.conrad.data.numeric.NumericPointwiseOperators;
import edu.stanford.rsl.conrad.utils.ImageUtil;
//import edu.stanford.rsl.conrad.utils.VisualizationUtil;
import ij.IJ;
import ij.ImageJ;
import edu.stanford.rsl.conrad.data.numeric.InterpolationOperators;
//import edu.stanford.rsl.conrad.data.numeric.NumericGridOperator;
import edu.stanford.rsl.conrad.numerics.SimpleMatrix;
import edu.stanford.rsl.conrad.numerics.SimpleOperators;
import edu.stanford.rsl.conrad.numerics.SimpleVector;
import edu.stanford.rsl.conrad.numerics.DecompositionSVD;

/**
 * Geometric Undistortion
 * Programming exercise 1 for module "Defect Pixel Interpolation"
 * of the course "Medical Image Processing for Diagnostic Applications (MIPDA)"
 * @author Frank Schebesch, Ashwini Jadhav, Anna Gebhard, Mena Abdelmalek
 *
 */

public class ExerciseGeoU {

	final static int caseNo = 1; // choose 0, 1, or 2 for different test images

	final static float a = 0.6f; // a: spread among x-direction
	final static float b = 0.3f; // b: spread among y-direction
	final static float d = 5.0f; // d: d/2 value of distortion field at level set for (X/a)^2+(Y/b)^2=1
	
	String filename; // do not edit, choose a number in the main method instead
	Grid2D originalImage; // do not edit, read from filename when instantiating the object
	Grid2D distortedImage; // do not edit, generated in the main method
	Grid2D undistortedImage; // do not edit, member variable for the output image
	
	// number of lattice points
	final int nx = 8;//TODO: define the number of lattice point: nx (Positive number and less than 20)
	final int ny = 8;//TODO: define the number of lattice point: ny (Positive number and less than 20)
	
	float fx;
	float fy;
	SimpleMatrix Xu; 
	SimpleMatrix Yu;
	SimpleMatrix Xd;
	SimpleMatrix Yd;
	int numCoeff; 
	int numCorresp; 
	SimpleMatrix A;
	DecompositionSVD svd;
	SimpleMatrix A_pseudoinverse;
	SimpleVector u_vec;
	SimpleVector v_vec;
	SimpleVector XuVector;
	SimpleVector YuVector;
	SimpleVector XdVector;
	SimpleVector YdVector;
	Grid2D xDist;  
	Grid2D yDist;
	Grid2D xprime; // x-coordinates of point correspondences in the undistorted image
	Grid2D yprime; // y-coordinates of point correspondences in the undistorted image
	Grid2D x; // x-coordinates of point correspondences in the distorted image
	Grid2D y; // y-coordinates of point correspondences in the distorted image
	
	
	/** 
	 * main method
	 * Here you can choose the image, and set the distortion parameters
	 */
	public static void main(String[] args) {
		
		new ImageJ();
		
		// generate distorted image
		ExerciseGeoU exObj = new ExerciseGeoU(caseNo);
		exObj.init(a,b,d);
		
		// TASK: go to the method doImageUndistortion(...) and complete it 
		exObj.undistortedImage = exObj.doImageUndistortion(exObj.distortedImage);
		
		exObj.originalImage.show("Original Image");
		exObj.distortedImage.show("Distorted Image");
		exObj.undistortedImage.show("Undistorted Image");
		
		Grid2D differenceImage = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.originalImage, exObj.undistortedImage);
		
		differenceImage.show("Difference Original vs. Undistorted");
		
		Grid2D distortedVSundistorted = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.undistortedImage, exObj.distortedImage);
		
		distortedVSundistorted.show("Difference Undistorted vs. Distorted");
	}
	
	public Grid2D doImageUndistortion(Grid2D distortedImage){
		
		Grid2D grid = new Grid2D(distortedImage);
		
		// check if image distortion routine has been run
		if (distortedImage == null || undistortedImage == null
				|| xprime == null || yprime == null
				|| x == null || y == null) {
			
			System.err.println("Error in doImageUndistortion(): called before initialization of members.");
			return grid;
		}
		
		
		getLatticePoints(distortedImage);// There are TODOs here 
		
		
		int degree = 5; // polynomial's degree: 2,...,10
		calcPolynomial(degree, Xd);// There are TODOs here
		
		
		
		computeMatrixA(degree, numCorresp, numCoeff);// There are TODOs here
		
		
		computeDistortionCoeff(A, XuVector, YuVector);// There are TODOs here
		
		
		grid = computeDistortedGrid(distortedImage, grid, degree);// There are TODOs here
		
		return grid;
	}
	
	
	
	/** 1. Number of lattice points (this only works for symmetric images):
	 *  nx, ny feature points: usually provided by tracking point
	 *  correspondences in the phantom during the calibration step.
	 *  Here, we use the distorted and undistorted coordinates generated
	 *  in the course of the distortion simulation.
	 */ 
	public void getLatticePoints (Grid2D distortedImage){
		
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		// step size
		// calculate the step size of the lattice points: fx and fy 
		fx = imageWidth/nx; //TODO
		fy = imageHeight/ny; //TODO
		
		// fill the distorted and undistorted lattice points 
		// with data from the given correspondences
		// matrix = number of rows (y) x number of columns (x)
		Xu = new SimpleMatrix(ny,nx);
		Yu = new SimpleMatrix(ny,nx);
		Xd = new SimpleMatrix(ny,nx);
		Yd = new SimpleMatrix(ny,nx);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){

				// sample the distorted and undistorted grid points at the lattice points
				  Xu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx), j + int(fy)));//TODO: fill matrix Xu
				  Yu.setElementValue(i, j, fy);//TODO: fill matrix Yu
				  Xd.setElementValue(i, j, fx);//TODO: fill matrix Xd
				  Yd.setElementValue(i, j, fy)//TODO: fill matrix Yd
			}
		}
	}
	
	/** 2. Polynomial of degree d
	 * Polynomial of degree d -> (d-1): extrema (e.g., d=5: 4 extrema)
	 * d=0: constant (horizontal line with y-intercept a_0 -> f(x)=a_0)
	 * d=1: oblique line with y-intercept a_0 & slope a_1 -> f(x)=a_0 + a_1 x
	 * d=2: parabola
	 * d>=2: continuous non-linear curve
	 * ...
	 * d = 10 -> NumCoeff: 66 -> but only 64 lattice points are known (nx, ny = 8)
	 */
	
	public void calcPolynomial(int degree, SimpleMatrix Xd){
		
		// number of coefficients: numCoeff
		// (hint: this is NOT the total number of multiplications!)
		numCoeff = 0; //TODO
		
		// number of correspondences: numCorresp
		numCorresp =  0; //TODO
		
		// Printout of the used parameters
		System.out.println("Polynom of degree: " + degree);
		System.out.println("Number of Coefficients: " + numCoeff);
		System.out.println("Number of Correspondences: " + numCorresp);
		
	}
	
	/**
	 * 3. Create the matrix A
	 */
	
	public void computeMatrixA(int degree, int numCorresp, int numCoeff){
		
		A = new SimpleMatrix(numCorresp, numCoeff);
		if (numCorresp <= 0 && numCoeff <= 0)
			return;
		A.zeros();
		
		// Realign the grid matrix into a vector for easier access in the next step
		XuVector = new SimpleVector(numCorresp);
		YuVector = new SimpleVector(numCorresp);
		XdVector = new SimpleVector(numCorresp);
		YdVector = new SimpleVector(numCorresp);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){
				
				XuVector.setElementValue(i*ny + j, Xu.getElement(j, i));
				YuVector.setElementValue(i*ny + j, Yu.getElement(j, i));
				XdVector.setElementValue(i*ny + j, Xd.getElement(j, i));
				YdVector.setElementValue(i*ny + j, Yd.getElement(j, i));
			}
		}
		
		// Compute matrix A (coordinates from distorted image)
		for(int r = 0; r < numCorresp; r++){
			
			int cc = 0;
			
			for(int k = 0; k <= degree; k++){
				for(int l = 0; l <= (degree-k); l++){
					
					// TODO: fill matrix A
					cc++;
					
				}
			}
		}
	}
	
	public void computeDistortionCoeff(SimpleMatrix A, SimpleVector XuVector, SimpleVector YuVector){
		
		// Compute the pseudo-inverse of A with the help of the SVD (class: DecompositionSVD)
		svd = null; // TODO
	    A_pseudoinverse = null; // TODO
	  
		// Compute the distortion coefficients (solve for known corresponding undistorted points)
		u_vec = null;// TODO
		v_vec = null;// TODO
	}
	
	/**
	 * 4. Compute the distorted grid points (xDist, yDist) which are used to sample the
	 * distorted image to get the undistorted image
	 * (xprime,yprime) is the position in the undistorted image
	 * (xDist,yDist) is the position in the distorted (observed) X-ray image.
	 */
	public Grid2D computeDistortedGrid(Grid2D distortedImage, Grid2D grid_out, int degree){
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		xDist = new Grid2D(imageWidth,imageHeight);  
		yDist = new Grid2D(imageWidth,imageHeight); 
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float val1, val2; //variables Val1 and Val2 are used for intermediate computation of xDist and yDist respectively
				
				int cc = 0;
				
				for(int k = 0; k <= degree; k++){
					for(int l = 0; l <= degree - k; l++){
						
						val1 = 0;// TODO
						val2 = 0;// TODO
						
						// TODO: fill xDist
						// TODO: fill yDist
						
						cc++;
					}
				}
			}
		}
		
		float val; // variable for intermediate computations of undistorted image
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				// hint: consider the fact that the coordinate origin is in the center of the image
				val = 0;//TODO
				//TODO: fill grid_out
			}
		}
		
		return grid_out;
		
	}
	
	
	
	/**
	 * 
	 * end of the exercise
	 */	

	
	/**
	 * standard constructor
	 */
	public ExerciseGeoU(){
		
		this(0);
	}
		
	/**
	 * parameterized constructor for the ExerciseDPI object
	 * @param caseNo: select one of three images to test your undistortion method
	 */
	public ExerciseGeoU(int caseNo){
		
		switch (caseNo) {
		case 0:
			filename = "frame32.jpg";
			break;
		case 1:
			filename = "undistorted.jpg";
			break;
		case 2:
			filename = "frame90.jpg";
			break;
		default:
			filename = "frame32.jpg";
			break;
		}
		
		String imageDataLoc = System.getProperty("user.dir") + "/data/" + "/mipda/";
	
		originalImage = ImageUtil.wrapImagePlus(IJ.openImage(imageDataLoc + filename)).getSubGrid(0);
	}
	
	public void init(float a, float b, float d) {
		
		// Normalize intensity values to [0,1]
		float max = NumericPointwiseOperators.max(originalImage);
		float min = NumericPointwiseOperators.min(originalImage);
		
		for(int i = 0; i < originalImage.getWidth(); i++){
			for(int j = 0; j < originalImage.getHeight(); j++){
				
				float scaledValue = (originalImage.getAtIndex(i, j) - min) / (max-min);
				originalImage.setAtIndex(i, j, scaledValue);
			}
		}
		
		undistortedImage = new Grid2D(originalImage.getWidth(),originalImage.getHeight()); // initialization with zeros
		
		distortedImage = generateDistortedImage(originalImage,a,b,d);	
	}
	
	/**
	 * method to generate a distorted image
	 * An artificial distortion field is generated. With this field, 
	 * a distorted image is generated from the original image.
	 * Remark: coordinates of the latest distortion simulated are saved in class member variables
	 * @param inputImage: undistorted image on which distortion is simulated
	 * @param a: elliptic extent of the distortion in x-direction
	 * @param b: elliptic extent of the distortion in y-direction
	 * @param d: strength of the distortion
	 * @return: distorted image
	 */
    
	public Grid2D generateDistortedImage(Grid2D inputImage, float a, float b, float d){

		Grid2D grid = new Grid2D(inputImage);
		int imageWidth = grid.getWidth();
		int imageHeight = grid.getHeight();
		
		// generate grids to sample coordinates X and Y of the original image
		Grid2D X = new Grid2D(imageWidth,imageHeight); // x-coordinates with respect to origin in image center, spacing = 1 [unit]
		Grid2D Y = new Grid2D(imageWidth,imageHeight); // y-coordinates with respect to origin in image center, spacing = 1 [unit]
		
		float halfWidth = imageWidth / 2.0f;
		float halfHeight = imageHeight / 2.0f;
		
		for(int i = 0; i < X.getWidth(); i++){
			for(int j = 0; j < X.getHeight(); j++){
				
				X.setAtIndex(i, j, i - halfWidth + 0.5f); // assign pixel centers in x-direction
				Y.setAtIndex(i, j, j - halfHeight + 0.5f); // assign pixel center in y-direction
			}
		}
		
		// create an artificial elliptical distortion field R (additive field)
		Grid2D R = new Grid2D(imageWidth,imageHeight);

		for(int i = 0; i < R.getWidth(); i++){
			for(int j = 0; j < R.getHeight(); j++){
				
				// distortion gets stronger with the distance from the image center
				float r = d * (float)(Math.sqrt(
						Math.pow(X.getAtIndex(i, j)/(a*halfWidth),2)
						+ Math.pow(Y.getAtIndex(i, j)/(b*halfHeight),2)));
				R.setAtIndex(i, j, r);
			}
		}
		
		// shifting the positive range to half positive/half negative range
		float maxR = NumericPointwiseOperators.max(R);
		NumericPointwiseOperators.subtractBy(R, maxR * 0.5f);

		// create the distorted image coordinates:
		// distorted image coordinates = undistorted image points + artificial distortion field

		// distorted image coordinates Xd, Yd
		Grid2D Xd = new Grid2D(X);
		Grid2D Yd = new Grid2D(Y);
		
		NumericPointwiseOperators.addBy(Xd, R);
		NumericPointwiseOperators.addBy(Yd, R);
		
		// create the distorted image:
		// re-sample the original input image at the distorted image points (Xd,Yd) 
		// to create artificial distortion
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float distortedValue = InterpolationOperators.interpolateLinear(
						inputImage,
						Xd.getAtIndex(i, j) + halfWidth - 0.5f, // remember: coordinate origin was set to image center
						Yd.getAtIndex(i, j) + halfHeight - 0.5f);
				grid.setAtIndex(i, j, distortedValue);
			}
		}

		xprime = X;
		yprime = Y;
		x = Xd;
		y = Yd;
		
		return grid;	
	}	
	
	//getters for members
	// variables which are checked (DO NOT CHANGE!)
	
	public static int get_caseNo() {
		return caseNo;
	}
	
	public Grid2D get_originalImage() {
		return originalImage;
	}
	
	public Grid2D get_distortedImage() {
		return distortedImage;
	}
	
	public Grid2D get_undistortedImage() {
		return undistortedImage;
	}
	
	public int get_nx() {
		return nx;
	}
	
	public int get_ny() {
		return ny;
	}
	
	public float get_fx() {
		return fx;
	}
	
	public float get_fy() {
		return fy;
	}
	
	public SimpleMatrix get_Xu() {
		return Xu;
	}
	
	public SimpleMatrix get_Yu() {
		return Yu;
	}
	
	public SimpleMatrix get_Xd() {
		return Xd;
	}
	
	public SimpleMatrix get_Yd() {
		return Yd;
	}
	
	public int get_numCoeff() {
		return numCoeff;
	}
	
	public int get_numCorresp() {
		return numCorresp;
	}
	
	public SimpleMatrix get_A() {
		return A;
	}
	
	public DecompositionSVD get_svd() {
		return svd;
	}
	
	public SimpleMatrix get_A_pseudoinverse() {
		return A_pseudoinverse;
	}
	
	public SimpleVector get_u_vec() {
		return u_vec;
	}
	
	public SimpleVector get_v_vec() {
		return v_vec;
	}
	
	public SimpleVector get_XuVector() {
		return XuVector;
	}
	
	public SimpleVector get_YuVector() {
		return YuVector;
	}
	
	public SimpleVector get_XdVector() {
		return XdVector;
	}
	
	public SimpleVector get_YdVector() {
		return YdVector;
	}
	
	public Grid2D get_xDist() {
		return xDist;
	}
	
	public Grid2D get_yDist() {
		return yDist;
	}
	
	public Grid2D get_xprime() {
		return xprime;
	}
	
	public Grid2D get_yprime() {
		return yprime;
	}
	
	public Grid2D get_x() {
		return x;
	}
	
	public Grid2D get_y() {
		return y;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-15 23:56:46.629
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-15 23:56:46.630
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-15 23:57:24.274
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package edu.stanford.rsl.tutorial.mipda;

import edu.stanford.rsl.conrad.data.numeric.Grid2D;
import edu.stanford.rsl.conrad.data.numeric.NumericPointwiseOperators;
import edu.stanford.rsl.conrad.utils.ImageUtil;
//import edu.stanford.rsl.conrad.utils.VisualizationUtil;
import ij.IJ;
import ij.ImageJ;
import edu.stanford.rsl.conrad.data.numeric.InterpolationOperators;
//import edu.stanford.rsl.conrad.data.numeric.NumericGridOperator;
import edu.stanford.rsl.conrad.numerics.SimpleMatrix;
import edu.stanford.rsl.conrad.numerics.SimpleOperators;
import edu.stanford.rsl.conrad.numerics.SimpleVector;
import edu.stanford.rsl.conrad.numerics.DecompositionSVD;

/**
 * Geometric Undistortion
 * Programming exercise 1 for module "Defect Pixel Interpolation"
 * of the course "Medical Image Processing for Diagnostic Applications (MIPDA)"
 * @author Frank Schebesch, Ashwini Jadhav, Anna Gebhard, Mena Abdelmalek
 *
 */

public class ExerciseGeoU {

	final static int caseNo = 1; // choose 0, 1, or 2 for different test images

	final static float a = 0.6f; // a: spread among x-direction
	final static float b = 0.3f; // b: spread among y-direction
	final static float d = 5.0f; // d: d/2 value of distortion field at level set for (X/a)^2+(Y/b)^2=1
	
	String filename; // do not edit, choose a number in the main method instead
	Grid2D originalImage; // do not edit, read from filename when instantiating the object
	Grid2D distortedImage; // do not edit, generated in the main method
	Grid2D undistortedImage; // do not edit, member variable for the output image
	
	// number of lattice points
	final int nx = 8;//TODO: define the number of lattice point: nx (Positive number and less than 20)
	final int ny = 8;//TODO: define the number of lattice point: ny (Positive number and less than 20)
	
	float fx;
	float fy;
	SimpleMatrix Xu; 
	SimpleMatrix Yu;
	SimpleMatrix Xd;
	SimpleMatrix Yd;
	int numCoeff; 
	int numCorresp; 
	SimpleMatrix A;
	DecompositionSVD svd;
	SimpleMatrix A_pseudoinverse;
	SimpleVector u_vec;
	SimpleVector v_vec;
	SimpleVector XuVector;
	SimpleVector YuVector;
	SimpleVector XdVector;
	SimpleVector YdVector;
	Grid2D xDist;  
	Grid2D yDist;
	Grid2D xprime; // x-coordinates of point correspondences in the undistorted image
	Grid2D yprime; // y-coordinates of point correspondences in the undistorted image
	Grid2D x; // x-coordinates of point correspondences in the distorted image
	Grid2D y; // y-coordinates of point correspondences in the distorted image
	
	
	/** 
	 * main method
	 * Here you can choose the image, and set the distortion parameters
	 */
	public static void main(String[] args) {
		
		new ImageJ();
		
		// generate distorted image
		ExerciseGeoU exObj = new ExerciseGeoU(caseNo);
		exObj.init(a,b,d);
		
		// TASK: go to the method doImageUndistortion(...) and complete it 
		exObj.undistortedImage = exObj.doImageUndistortion(exObj.distortedImage);
		
		exObj.originalImage.show("Original Image");
		exObj.distortedImage.show("Distorted Image");
		exObj.undistortedImage.show("Undistorted Image");
		
		Grid2D differenceImage = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.originalImage, exObj.undistortedImage);
		
		differenceImage.show("Difference Original vs. Undistorted");
		
		Grid2D distortedVSundistorted = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.undistortedImage, exObj.distortedImage);
		
		distortedVSundistorted.show("Difference Undistorted vs. Distorted");
	}
	
	public Grid2D doImageUndistortion(Grid2D distortedImage){
		
		Grid2D grid = new Grid2D(distortedImage);
		
		// check if image distortion routine has been run
		if (distortedImage == null || undistortedImage == null
				|| xprime == null || yprime == null
				|| x == null || y == null) {
			
			System.err.println("Error in doImageUndistortion(): called before initialization of members.");
			return grid;
		}
		
		
		getLatticePoints(distortedImage);// There are TODOs here 
		
		
		int degree = 5; // polynomial's degree: 2,...,10
		calcPolynomial(degree, Xd);// There are TODOs here
		
		
		
		computeMatrixA(degree, numCorresp, numCoeff);// There are TODOs here
		
		
		computeDistortionCoeff(A, XuVector, YuVector);// There are TODOs here
		
		
		grid = computeDistortedGrid(distortedImage, grid, degree);// There are TODOs here
		
		return grid;
	}
	
	
	
	/** 1. Number of lattice points (this only works for symmetric images):
	 *  nx, ny feature points: usually provided by tracking point
	 *  correspondences in the phantom during the calibration step.
	 *  Here, we use the distorted and undistorted coordinates generated
	 *  in the course of the distortion simulation.
	 */ 
	public void getLatticePoints (Grid2D distortedImage){
		
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		// step size
		// calculate the step size of the lattice points: fx and fy 
		fx = imageWidth/nx; //TODO
		fy = imageHeight/ny; //TODO
		
		// fill the distorted and undistorted lattice points 
		// with data from the given correspondences
		// matrix = number of rows (y) x number of columns (x)
		Xu = new SimpleMatrix(ny,nx);
		Yu = new SimpleMatrix(ny,nx);
		Xd = new SimpleMatrix(ny,nx);
		Yd = new SimpleMatrix(ny,nx);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){

				// sample the distorted and undistorted grid points at the lattice points
				  Xu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx), j + int(fy)));//TODO: fill matrix Xu
				  Yu.setElementValue(i, j, fy);//TODO: fill matrix Yu
				  Xd.setElementValue(i, j, fx);//TODO: fill matrix Xd
				  Yd.setElementValue(i, j, fy)//TODO: fill matrix Yd
			}
		}
	}
	
	/** 2. Polynomial of degree d
	 * Polynomial of degree d -> (d-1): extrema (e.g., d=5: 4 extrema)
	 * d=0: constant (horizontal line with y-intercept a_0 -> f(x)=a_0)
	 * d=1: oblique line with y-intercept a_0 & slope a_1 -> f(x)=a_0 + a_1 x
	 * d=2: parabola
	 * d>=2: continuous non-linear curve
	 * ...
	 * d = 10 -> NumCoeff: 66 -> but only 64 lattice points are known (nx, ny = 8)
	 */
	
	public void calcPolynomial(int degree, SimpleMatrix Xd){
		
		// number of coefficients: numCoeff
		// (hint: this is NOT the total number of multiplications!)
		numCoeff = 0; //TODO
		
		// number of correspondences: numCorresp
		numCorresp =  0; //TODO
		
		// Printout of the used parameters
		System.out.println("Polynom of degree: " + degree);
		System.out.println("Number of Coefficients: " + numCoeff);
		System.out.println("Number of Correspondences: " + numCorresp);
		
	}
	
	/**
	 * 3. Create the matrix A
	 */
	
	public void computeMatrixA(int degree, int numCorresp, int numCoeff){
		
		A = new SimpleMatrix(numCorresp, numCoeff);
		if (numCorresp <= 0 && numCoeff <= 0)
			return;
		A.zeros();
		
		// Realign the grid matrix into a vector for easier access in the next step
		XuVector = new SimpleVector(numCorresp);
		YuVector = new SimpleVector(numCorresp);
		XdVector = new SimpleVector(numCorresp);
		YdVector = new SimpleVector(numCorresp);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){
				
				XuVector.setElementValue(i*ny + j, Xu.getElement(j, i));
				YuVector.setElementValue(i*ny + j, Yu.getElement(j, i));
				XdVector.setElementValue(i*ny + j, Xd.getElement(j, i));
				YdVector.setElementValue(i*ny + j, Yd.getElement(j, i));
			}
		}
		
		// Compute matrix A (coordinates from distorted image)
		for(int r = 0; r < numCorresp; r++){
			
			int cc = 0;
			
			for(int k = 0; k <= degree; k++){
				for(int l = 0; l <= (degree-k); l++){
					
					// TODO: fill matrix A
					cc++;
					
				}
			}
		}
	}
	
	public void computeDistortionCoeff(SimpleMatrix A, SimpleVector XuVector, SimpleVector YuVector){
		
		// Compute the pseudo-inverse of A with the help of the SVD (class: DecompositionSVD)
		svd = null; // TODO
	    A_pseudoinverse = null; // TODO
	  
		// Compute the distortion coefficients (solve for known corresponding undistorted points)
		u_vec = null;// TODO
		v_vec = null;// TODO
	}
	
	/**
	 * 4. Compute the distorted grid points (xDist, yDist) which are used to sample the
	 * distorted image to get the undistorted image
	 * (xprime,yprime) is the position in the undistorted image
	 * (xDist,yDist) is the position in the distorted (observed) X-ray image.
	 */
	public Grid2D computeDistortedGrid(Grid2D distortedImage, Grid2D grid_out, int degree){
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		xDist = new Grid2D(imageWidth,imageHeight);  
		yDist = new Grid2D(imageWidth,imageHeight); 
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float val1, val2; //variables Val1 and Val2 are used for intermediate computation of xDist and yDist respectively
				
				int cc = 0;
				
				for(int k = 0; k <= degree; k++){
					for(int l = 0; l <= degree - k; l++){
						
						val1 = 0;// TODO
						val2 = 0;// TODO
						
						// TODO: fill xDist
						// TODO: fill yDist
						
						cc++;
					}
				}
			}
		}
		
		float val; // variable for intermediate computations of undistorted image
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				// hint: consider the fact that the coordinate origin is in the center of the image
				val = 0;//TODO
				//TODO: fill grid_out
			}
		}
		
		return grid_out;
		
	}
	
	
	
	/**
	 * 
	 * end of the exercise
	 */	

	
	/**
	 * standard constructor
	 */
	public ExerciseGeoU(){
		
		this(0);
	}
		
	/**
	 * parameterized constructor for the ExerciseDPI object
	 * @param caseNo: select one of three images to test your undistortion method
	 */
	public ExerciseGeoU(int caseNo){
		
		switch (caseNo) {
		case 0:
			filename = "frame32.jpg";
			break;
		case 1:
			filename = "undistorted.jpg";
			break;
		case 2:
			filename = "frame90.jpg";
			break;
		default:
			filename = "frame32.jpg";
			break;
		}
		
		String imageDataLoc = System.getProperty("user.dir") + "/data/" + "/mipda/";
	
		originalImage = ImageUtil.wrapImagePlus(IJ.openImage(imageDataLoc + filename)).getSubGrid(0);
	}
	
	public void init(float a, float b, float d) {
		
		// Normalize intensity values to [0,1]
		float max = NumericPointwiseOperators.max(originalImage);
		float min = NumericPointwiseOperators.min(originalImage);
		
		for(int i = 0; i < originalImage.getWidth(); i++){
			for(int j = 0; j < originalImage.getHeight(); j++){
				
				float scaledValue = (originalImage.getAtIndex(i, j) - min) / (max-min);
				originalImage.setAtIndex(i, j, scaledValue);
			}
		}
		
		undistortedImage = new Grid2D(originalImage.getWidth(),originalImage.getHeight()); // initialization with zeros
		
		distortedImage = generateDistortedImage(originalImage,a,b,d);	
	}
	
	/**
	 * method to generate a distorted image
	 * An artificial distortion field is generated. With this field, 
	 * a distorted image is generated from the original image.
	 * Remark: coordinates of the latest distortion simulated are saved in class member variables
	 * @param inputImage: undistorted image on which distortion is simulated
	 * @param a: elliptic extent of the distortion in x-direction
	 * @param b: elliptic extent of the distortion in y-direction
	 * @param d: strength of the distortion
	 * @return: distorted image
	 */
    
	public Grid2D generateDistortedImage(Grid2D inputImage, float a, float b, float d){

		Grid2D grid = new Grid2D(inputImage);
		int imageWidth = grid.getWidth();
		int imageHeight = grid.getHeight();
		
		// generate grids to sample coordinates X and Y of the original image
		Grid2D X = new Grid2D(imageWidth,imageHeight); // x-coordinates with respect to origin in image center, spacing = 1 [unit]
		Grid2D Y = new Grid2D(imageWidth,imageHeight); // y-coordinates with respect to origin in image center, spacing = 1 [unit]
		
		float halfWidth = imageWidth / 2.0f;
		float halfHeight = imageHeight / 2.0f;
		
		for(int i = 0; i < X.getWidth(); i++){
			for(int j = 0; j < X.getHeight(); j++){
				
				X.setAtIndex(i, j, i - halfWidth + 0.5f); // assign pixel centers in x-direction
				Y.setAtIndex(i, j, j - halfHeight + 0.5f); // assign pixel center in y-direction
			}
		}
		
		// create an artificial elliptical distortion field R (additive field)
		Grid2D R = new Grid2D(imageWidth,imageHeight);

		for(int i = 0; i < R.getWidth(); i++){
			for(int j = 0; j < R.getHeight(); j++){
				
				// distortion gets stronger with the distance from the image center
				float r = d * (float)(Math.sqrt(
						Math.pow(X.getAtIndex(i, j)/(a*halfWidth),2)
						+ Math.pow(Y.getAtIndex(i, j)/(b*halfHeight),2)));
				R.setAtIndex(i, j, r);
			}
		}
		
		// shifting the positive range to half positive/half negative range
		float maxR = NumericPointwiseOperators.max(R);
		NumericPointwiseOperators.subtractBy(R, maxR * 0.5f);

		// create the distorted image coordinates:
		// distorted image coordinates = undistorted image points + artificial distortion field

		// distorted image coordinates Xd, Yd
		Grid2D Xd = new Grid2D(X);
		Grid2D Yd = new Grid2D(Y);
		
		NumericPointwiseOperators.addBy(Xd, R);
		NumericPointwiseOperators.addBy(Yd, R);
		
		// create the distorted image:
		// re-sample the original input image at the distorted image points (Xd,Yd) 
		// to create artificial distortion
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float distortedValue = InterpolationOperators.interpolateLinear(
						inputImage,
						Xd.getAtIndex(i, j) + halfWidth - 0.5f, // remember: coordinate origin was set to image center
						Yd.getAtIndex(i, j) + halfHeight - 0.5f);
				grid.setAtIndex(i, j, distortedValue);
			}
		}

		xprime = X;
		yprime = Y;
		x = Xd;
		y = Yd;
		
		return grid;	
	}	
	
	//getters for members
	// variables which are checked (DO NOT CHANGE!)
	
	public static int get_caseNo() {
		return caseNo;
	}
	
	public Grid2D get_originalImage() {
		return originalImage;
	}
	
	public Grid2D get_distortedImage() {
		return distortedImage;
	}
	
	public Grid2D get_undistortedImage() {
		return undistortedImage;
	}
	
	public int get_nx() {
		return nx;
	}
	
	public int get_ny() {
		return ny;
	}
	
	public float get_fx() {
		return fx;
	}
	
	public float get_fy() {
		return fy;
	}
	
	public SimpleMatrix get_Xu() {
		return Xu;
	}
	
	public SimpleMatrix get_Yu() {
		return Yu;
	}
	
	public SimpleMatrix get_Xd() {
		return Xd;
	}
	
	public SimpleMatrix get_Yd() {
		return Yd;
	}
	
	public int get_numCoeff() {
		return numCoeff;
	}
	
	public int get_numCorresp() {
		return numCorresp;
	}
	
	public SimpleMatrix get_A() {
		return A;
	}
	
	public DecompositionSVD get_svd() {
		return svd;
	}
	
	public SimpleMatrix get_A_pseudoinverse() {
		return A_pseudoinverse;
	}
	
	public SimpleVector get_u_vec() {
		return u_vec;
	}
	
	public SimpleVector get_v_vec() {
		return v_vec;
	}
	
	public SimpleVector get_XuVector() {
		return XuVector;
	}
	
	public SimpleVector get_YuVector() {
		return YuVector;
	}
	
	public SimpleVector get_XdVector() {
		return XdVector;
	}
	
	public SimpleVector get_YdVector() {
		return YdVector;
	}
	
	public Grid2D get_xDist() {
		return xDist;
	}
	
	public Grid2D get_yDist() {
		return yDist;
	}
	
	public Grid2D get_xprime() {
		return xprime;
	}
	
	public Grid2D get_yprime() {
		return yprime;
	}
	
	public Grid2D get_x() {
		return x;
	}
	
	public Grid2D get_y() {
		return y;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-15 23:57:24.275
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-15 23:57:24.275
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-15 23:57:25.554
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package edu.stanford.rsl.tutorial.mipda;

import edu.stanford.rsl.conrad.data.numeric.Grid2D;
import edu.stanford.rsl.conrad.data.numeric.NumericPointwiseOperators;
import edu.stanford.rsl.conrad.utils.ImageUtil;
//import edu.stanford.rsl.conrad.utils.VisualizationUtil;
import ij.IJ;
import ij.ImageJ;
import edu.stanford.rsl.conrad.data.numeric.InterpolationOperators;
//import edu.stanford.rsl.conrad.data.numeric.NumericGridOperator;
import edu.stanford.rsl.conrad.numerics.SimpleMatrix;
import edu.stanford.rsl.conrad.numerics.SimpleOperators;
import edu.stanford.rsl.conrad.numerics.SimpleVector;
import edu.stanford.rsl.conrad.numerics.DecompositionSVD;

/**
 * Geometric Undistortion
 * Programming exercise 1 for module "Defect Pixel Interpolation"
 * of the course "Medical Image Processing for Diagnostic Applications (MIPDA)"
 * @author Frank Schebesch, Ashwini Jadhav, Anna Gebhard, Mena Abdelmalek
 *
 */

public class ExerciseGeoU {

	final static int caseNo = 1; // choose 0, 1, or 2 for different test images

	final static float a = 0.6f; // a: spread among x-direction
	final static float b = 0.3f; // b: spread among y-direction
	final static float d = 5.0f; // d: d/2 value of distortion field at level set for (X/a)^2+(Y/b)^2=1
	
	String filename; // do not edit, choose a number in the main method instead
	Grid2D originalImage; // do not edit, read from filename when instantiating the object
	Grid2D distortedImage; // do not edit, generated in the main method
	Grid2D undistortedImage; // do not edit, member variable for the output image
	
	// number of lattice points
	final int nx = 8;//TODO: define the number of lattice point: nx (Positive number and less than 20)
	final int ny = 8;//TODO: define the number of lattice point: ny (Positive number and less than 20)
	
	float fx;
	float fy;
	SimpleMatrix Xu; 
	SimpleMatrix Yu;
	SimpleMatrix Xd;
	SimpleMatrix Yd;
	int numCoeff; 
	int numCorresp; 
	SimpleMatrix A;
	DecompositionSVD svd;
	SimpleMatrix A_pseudoinverse;
	SimpleVector u_vec;
	SimpleVector v_vec;
	SimpleVector XuVector;
	SimpleVector YuVector;
	SimpleVector XdVector;
	SimpleVector YdVector;
	Grid2D xDist;  
	Grid2D yDist;
	Grid2D xprime; // x-coordinates of point correspondences in the undistorted image
	Grid2D yprime; // y-coordinates of point correspondences in the undistorted image
	Grid2D x; // x-coordinates of point correspondences in the distorted image
	Grid2D y; // y-coordinates of point correspondences in the distorted image
	
	
	/** 
	 * main method
	 * Here you can choose the image, and set the distortion parameters
	 */
	public static void main(String[] args) {
		
		new ImageJ();
		
		// generate distorted image
		ExerciseGeoU exObj = new ExerciseGeoU(caseNo);
		exObj.init(a,b,d);
		
		// TASK: go to the method doImageUndistortion(...) and complete it 
		exObj.undistortedImage = exObj.doImageUndistortion(exObj.distortedImage);
		
		exObj.originalImage.show("Original Image");
		exObj.distortedImage.show("Distorted Image");
		exObj.undistortedImage.show("Undistorted Image");
		
		Grid2D differenceImage = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.originalImage, exObj.undistortedImage);
		
		differenceImage.show("Difference Original vs. Undistorted");
		
		Grid2D distortedVSundistorted = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.undistortedImage, exObj.distortedImage);
		
		distortedVSundistorted.show("Difference Undistorted vs. Distorted");
	}
	
	public Grid2D doImageUndistortion(Grid2D distortedImage){
		
		Grid2D grid = new Grid2D(distortedImage);
		
		// check if image distortion routine has been run
		if (distortedImage == null || undistortedImage == null
				|| xprime == null || yprime == null
				|| x == null || y == null) {
			
			System.err.println("Error in doImageUndistortion(): called before initialization of members.");
			return grid;
		}
		
		
		getLatticePoints(distortedImage);// There are TODOs here 
		
		
		int degree = 5; // polynomial's degree: 2,...,10
		calcPolynomial(degree, Xd);// There are TODOs here
		
		
		
		computeMatrixA(degree, numCorresp, numCoeff);// There are TODOs here
		
		
		computeDistortionCoeff(A, XuVector, YuVector);// There are TODOs here
		
		
		grid = computeDistortedGrid(distortedImage, grid, degree);// There are TODOs here
		
		return grid;
	}
	
	
	
	/** 1. Number of lattice points (this only works for symmetric images):
	 *  nx, ny feature points: usually provided by tracking point
	 *  correspondences in the phantom during the calibration step.
	 *  Here, we use the distorted and undistorted coordinates generated
	 *  in the course of the distortion simulation.
	 */ 
	public void getLatticePoints (Grid2D distortedImage){
		
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		// step size
		// calculate the step size of the lattice points: fx and fy 
		fx = imageWidth/nx; //TODO
		fy = imageHeight/ny; //TODO
		
		// fill the distorted and undistorted lattice points 
		// with data from the given correspondences
		// matrix = number of rows (y) x number of columns (x)
		Xu = new SimpleMatrix(ny,nx);
		Yu = new SimpleMatrix(ny,nx);
		Xd = new SimpleMatrix(ny,nx);
		Yd = new SimpleMatrix(ny,nx);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){

				// sample the distorted and undistorted grid points at the lattice points
				  Xu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx), j + int(fy)));//TODO: fill matrix Xu
				  Yu.setElementValue(i, j, fy);//TODO: fill matrix Yu
				  Xd.setElementValue(i, j, fx);//TODO: fill matrix Xd
				  Yd.setElementValue(i, j, fy)//TODO: fill matrix Yd
			}
		}
	}
	
	/** 2. Polynomial of degree d
	 * Polynomial of degree d -> (d-1): extrema (e.g., d=5: 4 extrema)
	 * d=0: constant (horizontal line with y-intercept a_0 -> f(x)=a_0)
	 * d=1: oblique line with y-intercept a_0 & slope a_1 -> f(x)=a_0 + a_1 x
	 * d=2: parabola
	 * d>=2: continuous non-linear curve
	 * ...
	 * d = 10 -> NumCoeff: 66 -> but only 64 lattice points are known (nx, ny = 8)
	 */
	
	public void calcPolynomial(int degree, SimpleMatrix Xd){
		
		// number of coefficients: numCoeff
		// (hint: this is NOT the total number of multiplications!)
		numCoeff = 0; //TODO
		
		// number of correspondences: numCorresp
		numCorresp =  0; //TODO
		
		// Printout of the used parameters
		System.out.println("Polynom of degree: " + degree);
		System.out.println("Number of Coefficients: " + numCoeff);
		System.out.println("Number of Correspondences: " + numCorresp);
		
	}
	
	/**
	 * 3. Create the matrix A
	 */
	
	public void computeMatrixA(int degree, int numCorresp, int numCoeff){
		
		A = new SimpleMatrix(numCorresp, numCoeff);
		if (numCorresp <= 0 && numCoeff <= 0)
			return;
		A.zeros();
		
		// Realign the grid matrix into a vector for easier access in the next step
		XuVector = new SimpleVector(numCorresp);
		YuVector = new SimpleVector(numCorresp);
		XdVector = new SimpleVector(numCorresp);
		YdVector = new SimpleVector(numCorresp);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){
				
				XuVector.setElementValue(i*ny + j, Xu.getElement(j, i));
				YuVector.setElementValue(i*ny + j, Yu.getElement(j, i));
				XdVector.setElementValue(i*ny + j, Xd.getElement(j, i));
				YdVector.setElementValue(i*ny + j, Yd.getElement(j, i));
			}
		}
		
		// Compute matrix A (coordinates from distorted image)
		for(int r = 0; r < numCorresp; r++){
			
			int cc = 0;
			
			for(int k = 0; k <= degree; k++){
				for(int l = 0; l <= (degree-k); l++){
					
					// TODO: fill matrix A
					cc++;
					
				}
			}
		}
	}
	
	public void computeDistortionCoeff(SimpleMatrix A, SimpleVector XuVector, SimpleVector YuVector){
		
		// Compute the pseudo-inverse of A with the help of the SVD (class: DecompositionSVD)
		svd = null; // TODO
	    A_pseudoinverse = null; // TODO
	  
		// Compute the distortion coefficients (solve for known corresponding undistorted points)
		u_vec = null;// TODO
		v_vec = null;// TODO
	}
	
	/**
	 * 4. Compute the distorted grid points (xDist, yDist) which are used to sample the
	 * distorted image to get the undistorted image
	 * (xprime,yprime) is the position in the undistorted image
	 * (xDist,yDist) is the position in the distorted (observed) X-ray image.
	 */
	public Grid2D computeDistortedGrid(Grid2D distortedImage, Grid2D grid_out, int degree){
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		xDist = new Grid2D(imageWidth,imageHeight);  
		yDist = new Grid2D(imageWidth,imageHeight); 
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float val1, val2; //variables Val1 and Val2 are used for intermediate computation of xDist and yDist respectively
				
				int cc = 0;
				
				for(int k = 0; k <= degree; k++){
					for(int l = 0; l <= degree - k; l++){
						
						val1 = 0;// TODO
						val2 = 0;// TODO
						
						// TODO: fill xDist
						// TODO: fill yDist
						
						cc++;
					}
				}
			}
		}
		
		float val; // variable for intermediate computations of undistorted image
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				// hint: consider the fact that the coordinate origin is in the center of the image
				val = 0;//TODO
				//TODO: fill grid_out
			}
		}
		
		return grid_out;
		
	}
	
	
	
	/**
	 * 
	 * end of the exercise
	 */	

	
	/**
	 * standard constructor
	 */
	public ExerciseGeoU(){
		
		this(0);
	}
		
	/**
	 * parameterized constructor for the ExerciseDPI object
	 * @param caseNo: select one of three images to test your undistortion method
	 */
	public ExerciseGeoU(int caseNo){
		
		switch (caseNo) {
		case 0:
			filename = "frame32.jpg";
			break;
		case 1:
			filename = "undistorted.jpg";
			break;
		case 2:
			filename = "frame90.jpg";
			break;
		default:
			filename = "frame32.jpg";
			break;
		}
		
		String imageDataLoc = System.getProperty("user.dir") + "/data/" + "/mipda/";
	
		originalImage = ImageUtil.wrapImagePlus(IJ.openImage(imageDataLoc + filename)).getSubGrid(0);
	}
	
	public void init(float a, float b, float d) {
		
		// Normalize intensity values to [0,1]
		float max = NumericPointwiseOperators.max(originalImage);
		float min = NumericPointwiseOperators.min(originalImage);
		
		for(int i = 0; i < originalImage.getWidth(); i++){
			for(int j = 0; j < originalImage.getHeight(); j++){
				
				float scaledValue = (originalImage.getAtIndex(i, j) - min) / (max-min);
				originalImage.setAtIndex(i, j, scaledValue);
			}
		}
		
		undistortedImage = new Grid2D(originalImage.getWidth(),originalImage.getHeight()); // initialization with zeros
		
		distortedImage = generateDistortedImage(originalImage,a,b,d);	
	}
	
	/**
	 * method to generate a distorted image
	 * An artificial distortion field is generated. With this field, 
	 * a distorted image is generated from the original image.
	 * Remark: coordinates of the latest distortion simulated are saved in class member variables
	 * @param inputImage: undistorted image on which distortion is simulated
	 * @param a: elliptic extent of the distortion in x-direction
	 * @param b: elliptic extent of the distortion in y-direction
	 * @param d: strength of the distortion
	 * @return: distorted image
	 */
    
	public Grid2D generateDistortedImage(Grid2D inputImage, float a, float b, float d){

		Grid2D grid = new Grid2D(inputImage);
		int imageWidth = grid.getWidth();
		int imageHeight = grid.getHeight();
		
		// generate grids to sample coordinates X and Y of the original image
		Grid2D X = new Grid2D(imageWidth,imageHeight); // x-coordinates with respect to origin in image center, spacing = 1 [unit]
		Grid2D Y = new Grid2D(imageWidth,imageHeight); // y-coordinates with respect to origin in image center, spacing = 1 [unit]
		
		float halfWidth = imageWidth / 2.0f;
		float halfHeight = imageHeight / 2.0f;
		
		for(int i = 0; i < X.getWidth(); i++){
			for(int j = 0; j < X.getHeight(); j++){
				
				X.setAtIndex(i, j, i - halfWidth + 0.5f); // assign pixel centers in x-direction
				Y.setAtIndex(i, j, j - halfHeight + 0.5f); // assign pixel center in y-direction
			}
		}
		
		// create an artificial elliptical distortion field R (additive field)
		Grid2D R = new Grid2D(imageWidth,imageHeight);

		for(int i = 0; i < R.getWidth(); i++){
			for(int j = 0; j < R.getHeight(); j++){
				
				// distortion gets stronger with the distance from the image center
				float r = d * (float)(Math.sqrt(
						Math.pow(X.getAtIndex(i, j)/(a*halfWidth),2)
						+ Math.pow(Y.getAtIndex(i, j)/(b*halfHeight),2)));
				R.setAtIndex(i, j, r);
			}
		}
		
		// shifting the positive range to half positive/half negative range
		float maxR = NumericPointwiseOperators.max(R);
		NumericPointwiseOperators.subtractBy(R, maxR * 0.5f);

		// create the distorted image coordinates:
		// distorted image coordinates = undistorted image points + artificial distortion field

		// distorted image coordinates Xd, Yd
		Grid2D Xd = new Grid2D(X);
		Grid2D Yd = new Grid2D(Y);
		
		NumericPointwiseOperators.addBy(Xd, R);
		NumericPointwiseOperators.addBy(Yd, R);
		
		// create the distorted image:
		// re-sample the original input image at the distorted image points (Xd,Yd) 
		// to create artificial distortion
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float distortedValue = InterpolationOperators.interpolateLinear(
						inputImage,
						Xd.getAtIndex(i, j) + halfWidth - 0.5f, // remember: coordinate origin was set to image center
						Yd.getAtIndex(i, j) + halfHeight - 0.5f);
				grid.setAtIndex(i, j, distortedValue);
			}
		}

		xprime = X;
		yprime = Y;
		x = Xd;
		y = Yd;
		
		return grid;	
	}	
	
	//getters for members
	// variables which are checked (DO NOT CHANGE!)
	
	public static int get_caseNo() {
		return caseNo;
	}
	
	public Grid2D get_originalImage() {
		return originalImage;
	}
	
	public Grid2D get_distortedImage() {
		return distortedImage;
	}
	
	public Grid2D get_undistortedImage() {
		return undistortedImage;
	}
	
	public int get_nx() {
		return nx;
	}
	
	public int get_ny() {
		return ny;
	}
	
	public float get_fx() {
		return fx;
	}
	
	public float get_fy() {
		return fy;
	}
	
	public SimpleMatrix get_Xu() {
		return Xu;
	}
	
	public SimpleMatrix get_Yu() {
		return Yu;
	}
	
	public SimpleMatrix get_Xd() {
		return Xd;
	}
	
	public SimpleMatrix get_Yd() {
		return Yd;
	}
	
	public int get_numCoeff() {
		return numCoeff;
	}
	
	public int get_numCorresp() {
		return numCorresp;
	}
	
	public SimpleMatrix get_A() {
		return A;
	}
	
	public DecompositionSVD get_svd() {
		return svd;
	}
	
	public SimpleMatrix get_A_pseudoinverse() {
		return A_pseudoinverse;
	}
	
	public SimpleVector get_u_vec() {
		return u_vec;
	}
	
	public SimpleVector get_v_vec() {
		return v_vec;
	}
	
	public SimpleVector get_XuVector() {
		return XuVector;
	}
	
	public SimpleVector get_YuVector() {
		return YuVector;
	}
	
	public SimpleVector get_XdVector() {
		return XdVector;
	}
	
	public SimpleVector get_YdVector() {
		return YdVector;
	}
	
	public Grid2D get_xDist() {
		return xDist;
	}
	
	public Grid2D get_yDist() {
		return yDist;
	}
	
	public Grid2D get_xprime() {
		return xprime;
	}
	
	public Grid2D get_yprime() {
		return yprime;
	}
	
	public Grid2D get_x() {
		return x;
	}
	
	public Grid2D get_y() {
		return y;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-15 23:57:25.555
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-15 23:57:25.555
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-15 23:57:33.691
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package edu.stanford.rsl.tutorial.mipda;

import edu.stanford.rsl.conrad.data.numeric.Grid2D;
import edu.stanford.rsl.conrad.data.numeric.NumericPointwiseOperators;
import edu.stanford.rsl.conrad.utils.ImageUtil;
//import edu.stanford.rsl.conrad.utils.VisualizationUtil;
import ij.IJ;
import ij.ImageJ;
import edu.stanford.rsl.conrad.data.numeric.InterpolationOperators;
//import edu.stanford.rsl.conrad.data.numeric.NumericGridOperator;
import edu.stanford.rsl.conrad.numerics.SimpleMatrix;
import edu.stanford.rsl.conrad.numerics.SimpleOperators;
import edu.stanford.rsl.conrad.numerics.SimpleVector;
import edu.stanford.rsl.conrad.numerics.DecompositionSVD;

/**
 * Geometric Undistortion
 * Programming exercise 1 for module "Defect Pixel Interpolation"
 * of the course "Medical Image Processing for Diagnostic Applications (MIPDA)"
 * @author Frank Schebesch, Ashwini Jadhav, Anna Gebhard, Mena Abdelmalek
 *
 */

public class ExerciseGeoU {

	final static int caseNo = 1; // choose 0, 1, or 2 for different test images

	final static float a = 0.6f; // a: spread among x-direction
	final static float b = 0.3f; // b: spread among y-direction
	final static float d = 5.0f; // d: d/2 value of distortion field at level set for (X/a)^2+(Y/b)^2=1
	
	String filename; // do not edit, choose a number in the main method instead
	Grid2D originalImage; // do not edit, read from filename when instantiating the object
	Grid2D distortedImage; // do not edit, generated in the main method
	Grid2D undistortedImage; // do not edit, member variable for the output image
	
	// number of lattice points
	final int nx = 8;//TODO: define the number of lattice point: nx (Positive number and less than 20)
	final int ny = 8;//TODO: define the number of lattice point: ny (Positive number and less than 20)
	
	float fx;
	float fy;
	SimpleMatrix Xu; 
	SimpleMatrix Yu;
	SimpleMatrix Xd;
	SimpleMatrix Yd;
	int numCoeff; 
	int numCorresp; 
	SimpleMatrix A;
	DecompositionSVD svd;
	SimpleMatrix A_pseudoinverse;
	SimpleVector u_vec;
	SimpleVector v_vec;
	SimpleVector XuVector;
	SimpleVector YuVector;
	SimpleVector XdVector;
	SimpleVector YdVector;
	Grid2D xDist;  
	Grid2D yDist;
	Grid2D xprime; // x-coordinates of point correspondences in the undistorted image
	Grid2D yprime; // y-coordinates of point correspondences in the undistorted image
	Grid2D x; // x-coordinates of point correspondences in the distorted image
	Grid2D y; // y-coordinates of point correspondences in the distorted image
	
	
	/** 
	 * main method
	 * Here you can choose the image, and set the distortion parameters
	 */
	public static void main(String[] args) {
		
		new ImageJ();
		
		// generate distorted image
		ExerciseGeoU exObj = new ExerciseGeoU(caseNo);
		exObj.init(a,b,d);
		
		// TASK: go to the method doImageUndistortion(...) and complete it 
		exObj.undistortedImage = exObj.doImageUndistortion(exObj.distortedImage);
		
		exObj.originalImage.show("Original Image");
		exObj.distortedImage.show("Distorted Image");
		exObj.undistortedImage.show("Undistorted Image");
		
		Grid2D differenceImage = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.originalImage, exObj.undistortedImage);
		
		differenceImage.show("Difference Original vs. Undistorted");
		
		Grid2D distortedVSundistorted = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.undistortedImage, exObj.distortedImage);
		
		distortedVSundistorted.show("Difference Undistorted vs. Distorted");
	}
	
	public Grid2D doImageUndistortion(Grid2D distortedImage){
		
		Grid2D grid = new Grid2D(distortedImage);
		
		// check if image distortion routine has been run
		if (distortedImage == null || undistortedImage == null
				|| xprime == null || yprime == null
				|| x == null || y == null) {
			
			System.err.println("Error in doImageUndistortion(): called before initialization of members.");
			return grid;
		}
		
		
		getLatticePoints(distortedImage);// There are TODOs here 
		
		
		int degree = 5; // polynomial's degree: 2,...,10
		calcPolynomial(degree, Xd);// There are TODOs here
		
		
		
		computeMatrixA(degree, numCorresp, numCoeff);// There are TODOs here
		
		
		computeDistortionCoeff(A, XuVector, YuVector);// There are TODOs here
		
		
		grid = computeDistortedGrid(distortedImage, grid, degree);// There are TODOs here
		
		return grid;
	}
	
	
	
	/** 1. Number of lattice points (this only works for symmetric images):
	 *  nx, ny feature points: usually provided by tracking point
	 *  correspondences in the phantom during the calibration step.
	 *  Here, we use the distorted and undistorted coordinates generated
	 *  in the course of the distortion simulation.
	 */ 
	public void getLatticePoints (Grid2D distortedImage){
		
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		// step size
		// calculate the step size of the lattice points: fx and fy 
		fx = imageWidth/nx; //TODO
		fy = imageHeight/ny; //TODO
		
		// fill the distorted and undistorted lattice points 
		// with data from the given correspondences
		// matrix = number of rows (y) x number of columns (x)
		Xu = new SimpleMatrix(ny,nx);
		Yu = new SimpleMatrix(ny,nx);
		Xd = new SimpleMatrix(ny,nx);
		Yd = new SimpleMatrix(ny,nx);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){

				// sample the distorted and undistorted grid points at the lattice points
				  Xu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx), j + int(fy)));//TODO: fill matrix Xu
				  Yu.setElementValue(i, j, fy);//TODO: fill matrix Yu
				  Xd.setElementValue(i, j, fx);//TODO: fill matrix Xd
				  Yd.setElementValue(i, j, fy)//TODO: fill matrix Yd
			}
		}
	}
	
	/** 2. Polynomial of degree d
	 * Polynomial of degree d -> (d-1): extrema (e.g., d=5: 4 extrema)
	 * d=0: constant (horizontal line with y-intercept a_0 -> f(x)=a_0)
	 * d=1: oblique line with y-intercept a_0 & slope a_1 -> f(x)=a_0 + a_1 x
	 * d=2: parabola
	 * d>=2: continuous non-linear curve
	 * ...
	 * d = 10 -> NumCoeff: 66 -> but only 64 lattice points are known (nx, ny = 8)
	 */
	
	public void calcPolynomial(int degree, SimpleMatrix Xd){
		
		// number of coefficients: numCoeff
		// (hint: this is NOT the total number of multiplications!)
		numCoeff = 0; //TODO
		
		// number of correspondences: numCorresp
		numCorresp =  0; //TODO
		
		// Printout of the used parameters
		System.out.println("Polynom of degree: " + degree);
		System.out.println("Number of Coefficients: " + numCoeff);
		System.out.println("Number of Correspondences: " + numCorresp);
		
	}
	
	/**
	 * 3. Create the matrix A
	 */
	
	public void computeMatrixA(int degree, int numCorresp, int numCoeff){
		
		A = new SimpleMatrix(numCorresp, numCoeff);
		if (numCorresp <= 0 && numCoeff <= 0)
			return;
		A.zeros();
		
		// Realign the grid matrix into a vector for easier access in the next step
		XuVector = new SimpleVector(numCorresp);
		YuVector = new SimpleVector(numCorresp);
		XdVector = new SimpleVector(numCorresp);
		YdVector = new SimpleVector(numCorresp);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){
				
				XuVector.setElementValue(i*ny + j, Xu.getElement(j, i));
				YuVector.setElementValue(i*ny + j, Yu.getElement(j, i));
				XdVector.setElementValue(i*ny + j, Xd.getElement(j, i));
				YdVector.setElementValue(i*ny + j, Yd.getElement(j, i));
			}
		}
		
		// Compute matrix A (coordinates from distorted image)
		for(int r = 0; r < numCorresp; r++){
			
			int cc = 0;
			
			for(int k = 0; k <= degree; k++){
				for(int l = 0; l <= (degree-k); l++){
					
					// TODO: fill matrix A
					cc++;
					
				}
			}
		}
	}
	
	public void computeDistortionCoeff(SimpleMatrix A, SimpleVector XuVector, SimpleVector YuVector){
		
		// Compute the pseudo-inverse of A with the help of the SVD (class: DecompositionSVD)
		svd = null; // TODO
	    A_pseudoinverse = null; // TODO
	  
		// Compute the distortion coefficients (solve for known corresponding undistorted points)
		u_vec = null;// TODO
		v_vec = null;// TODO
	}
	
	/**
	 * 4. Compute the distorted grid points (xDist, yDist) which are used to sample the
	 * distorted image to get the undistorted image
	 * (xprime,yprime) is the position in the undistorted image
	 * (xDist,yDist) is the position in the distorted (observed) X-ray image.
	 */
	public Grid2D computeDistortedGrid(Grid2D distortedImage, Grid2D grid_out, int degree){
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		xDist = new Grid2D(imageWidth,imageHeight);  
		yDist = new Grid2D(imageWidth,imageHeight); 
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float val1, val2; //variables Val1 and Val2 are used for intermediate computation of xDist and yDist respectively
				
				int cc = 0;
				
				for(int k = 0; k <= degree; k++){
					for(int l = 0; l <= degree - k; l++){
						
						val1 = 0;// TODO
						val2 = 0;// TODO
						
						// TODO: fill xDist
						// TODO: fill yDist
						
						cc++;
					}
				}
			}
		}
		
		float val; // variable for intermediate computations of undistorted image
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				// hint: consider the fact that the coordinate origin is in the center of the image
				val = 0;//TODO
				//TODO: fill grid_out
			}
		}
		
		return grid_out;
		
	}
	
	
	
	/**
	 * 
	 * end of the exercise
	 */	

	
	/**
	 * standard constructor
	 */
	public ExerciseGeoU(){
		
		this(0);
	}
		
	/**
	 * parameterized constructor for the ExerciseDPI object
	 * @param caseNo: select one of three images to test your undistortion method
	 */
	public ExerciseGeoU(int caseNo){
		
		switch (caseNo) {
		case 0:
			filename = "frame32.jpg";
			break;
		case 1:
			filename = "undistorted.jpg";
			break;
		case 2:
			filename = "frame90.jpg";
			break;
		default:
			filename = "frame32.jpg";
			break;
		}
		
		String imageDataLoc = System.getProperty("user.dir") + "/data/" + "/mipda/";
	
		originalImage = ImageUtil.wrapImagePlus(IJ.openImage(imageDataLoc + filename)).getSubGrid(0);
	}
	
	public void init(float a, float b, float d) {
		
		// Normalize intensity values to [0,1]
		float max = NumericPointwiseOperators.max(originalImage);
		float min = NumericPointwiseOperators.min(originalImage);
		
		for(int i = 0; i < originalImage.getWidth(); i++){
			for(int j = 0; j < originalImage.getHeight(); j++){
				
				float scaledValue = (originalImage.getAtIndex(i, j) - min) / (max-min);
				originalImage.setAtIndex(i, j, scaledValue);
			}
		}
		
		undistortedImage = new Grid2D(originalImage.getWidth(),originalImage.getHeight()); // initialization with zeros
		
		distortedImage = generateDistortedImage(originalImage,a,b,d);	
	}
	
	/**
	 * method to generate a distorted image
	 * An artificial distortion field is generated. With this field, 
	 * a distorted image is generated from the original image.
	 * Remark: coordinates of the latest distortion simulated are saved in class member variables
	 * @param inputImage: undistorted image on which distortion is simulated
	 * @param a: elliptic extent of the distortion in x-direction
	 * @param b: elliptic extent of the distortion in y-direction
	 * @param d: strength of the distortion
	 * @return: distorted image
	 */
    
	public Grid2D generateDistortedImage(Grid2D inputImage, float a, float b, float d){

		Grid2D grid = new Grid2D(inputImage);
		int imageWidth = grid.getWidth();
		int imageHeight = grid.getHeight();
		
		// generate grids to sample coordinates X and Y of the original image
		Grid2D X = new Grid2D(imageWidth,imageHeight); // x-coordinates with respect to origin in image center, spacing = 1 [unit]
		Grid2D Y = new Grid2D(imageWidth,imageHeight); // y-coordinates with respect to origin in image center, spacing = 1 [unit]
		
		float halfWidth = imageWidth / 2.0f;
		float halfHeight = imageHeight / 2.0f;
		
		for(int i = 0; i < X.getWidth(); i++){
			for(int j = 0; j < X.getHeight(); j++){
				
				X.setAtIndex(i, j, i - halfWidth + 0.5f); // assign pixel centers in x-direction
				Y.setAtIndex(i, j, j - halfHeight + 0.5f); // assign pixel center in y-direction
			}
		}
		
		// create an artificial elliptical distortion field R (additive field)
		Grid2D R = new Grid2D(imageWidth,imageHeight);

		for(int i = 0; i < R.getWidth(); i++){
			for(int j = 0; j < R.getHeight(); j++){
				
				// distortion gets stronger with the distance from the image center
				float r = d * (float)(Math.sqrt(
						Math.pow(X.getAtIndex(i, j)/(a*halfWidth),2)
						+ Math.pow(Y.getAtIndex(i, j)/(b*halfHeight),2)));
				R.setAtIndex(i, j, r);
			}
		}
		
		// shifting the positive range to half positive/half negative range
		float maxR = NumericPointwiseOperators.max(R);
		NumericPointwiseOperators.subtractBy(R, maxR * 0.5f);

		// create the distorted image coordinates:
		// distorted image coordinates = undistorted image points + artificial distortion field

		// distorted image coordinates Xd, Yd
		Grid2D Xd = new Grid2D(X);
		Grid2D Yd = new Grid2D(Y);
		
		NumericPointwiseOperators.addBy(Xd, R);
		NumericPointwiseOperators.addBy(Yd, R);
		
		// create the distorted image:
		// re-sample the original input image at the distorted image points (Xd,Yd) 
		// to create artificial distortion
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float distortedValue = InterpolationOperators.interpolateLinear(
						inputImage,
						Xd.getAtIndex(i, j) + halfWidth - 0.5f, // remember: coordinate origin was set to image center
						Yd.getAtIndex(i, j) + halfHeight - 0.5f);
				grid.setAtIndex(i, j, distortedValue);
			}
		}

		xprime = X;
		yprime = Y;
		x = Xd;
		y = Yd;
		
		return grid;	
	}	
	
	//getters for members
	// variables which are checked (DO NOT CHANGE!)
	
	public static int get_caseNo() {
		return caseNo;
	}
	
	public Grid2D get_originalImage() {
		return originalImage;
	}
	
	public Grid2D get_distortedImage() {
		return distortedImage;
	}
	
	public Grid2D get_undistortedImage() {
		return undistortedImage;
	}
	
	public int get_nx() {
		return nx;
	}
	
	public int get_ny() {
		return ny;
	}
	
	public float get_fx() {
		return fx;
	}
	
	public float get_fy() {
		return fy;
	}
	
	public SimpleMatrix get_Xu() {
		return Xu;
	}
	
	public SimpleMatrix get_Yu() {
		return Yu;
	}
	
	public SimpleMatrix get_Xd() {
		return Xd;
	}
	
	public SimpleMatrix get_Yd() {
		return Yd;
	}
	
	public int get_numCoeff() {
		return numCoeff;
	}
	
	public int get_numCorresp() {
		return numCorresp;
	}
	
	public SimpleMatrix get_A() {
		return A;
	}
	
	public DecompositionSVD get_svd() {
		return svd;
	}
	
	public SimpleMatrix get_A_pseudoinverse() {
		return A_pseudoinverse;
	}
	
	public SimpleVector get_u_vec() {
		return u_vec;
	}
	
	public SimpleVector get_v_vec() {
		return v_vec;
	}
	
	public SimpleVector get_XuVector() {
		return XuVector;
	}
	
	public SimpleVector get_YuVector() {
		return YuVector;
	}
	
	public SimpleVector get_XdVector() {
		return XdVector;
	}
	
	public SimpleVector get_YdVector() {
		return YdVector;
	}
	
	public Grid2D get_xDist() {
		return xDist;
	}
	
	public Grid2D get_yDist() {
		return yDist;
	}
	
	public Grid2D get_xprime() {
		return xprime;
	}
	
	public Grid2D get_yprime() {
		return yprime;
	}
	
	public Grid2D get_x() {
		return x;
	}
	
	public Grid2D get_y() {
		return y;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-15 23:57:33.691
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-15 23:57:33.692
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-15 23:57:34.297
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package edu.stanford.rsl.tutorial.mipda;

import edu.stanford.rsl.conrad.data.numeric.Grid2D;
import edu.stanford.rsl.conrad.data.numeric.NumericPointwiseOperators;
import edu.stanford.rsl.conrad.utils.ImageUtil;
//import edu.stanford.rsl.conrad.utils.VisualizationUtil;
import ij.IJ;
import ij.ImageJ;
import edu.stanford.rsl.conrad.data.numeric.InterpolationOperators;
//import edu.stanford.rsl.conrad.data.numeric.NumericGridOperator;
import edu.stanford.rsl.conrad.numerics.SimpleMatrix;
import edu.stanford.rsl.conrad.numerics.SimpleOperators;
import edu.stanford.rsl.conrad.numerics.SimpleVector;
import edu.stanford.rsl.conrad.numerics.DecompositionSVD;

/**
 * Geometric Undistortion
 * Programming exercise 1 for module "Defect Pixel Interpolation"
 * of the course "Medical Image Processing for Diagnostic Applications (MIPDA)"
 * @author Frank Schebesch, Ashwini Jadhav, Anna Gebhard, Mena Abdelmalek
 *
 */

public class ExerciseGeoU {

	final static int caseNo = 1; // choose 0, 1, or 2 for different test images

	final static float a = 0.6f; // a: spread among x-direction
	final static float b = 0.3f; // b: spread among y-direction
	final static float d = 5.0f; // d: d/2 value of distortion field at level set for (X/a)^2+(Y/b)^2=1
	
	String filename; // do not edit, choose a number in the main method instead
	Grid2D originalImage; // do not edit, read from filename when instantiating the object
	Grid2D distortedImage; // do not edit, generated in the main method
	Grid2D undistortedImage; // do not edit, member variable for the output image
	
	// number of lattice points
	final int nx = 8;//TODO: define the number of lattice point: nx (Positive number and less than 20)
	final int ny = 8;//TODO: define the number of lattice point: ny (Positive number and less than 20)
	
	float fx;
	float fy;
	SimpleMatrix Xu; 
	SimpleMatrix Yu;
	SimpleMatrix Xd;
	SimpleMatrix Yd;
	int numCoeff; 
	int numCorresp; 
	SimpleMatrix A;
	DecompositionSVD svd;
	SimpleMatrix A_pseudoinverse;
	SimpleVector u_vec;
	SimpleVector v_vec;
	SimpleVector XuVector;
	SimpleVector YuVector;
	SimpleVector XdVector;
	SimpleVector YdVector;
	Grid2D xDist;  
	Grid2D yDist;
	Grid2D xprime; // x-coordinates of point correspondences in the undistorted image
	Grid2D yprime; // y-coordinates of point correspondences in the undistorted image
	Grid2D x; // x-coordinates of point correspondences in the distorted image
	Grid2D y; // y-coordinates of point correspondences in the distorted image
	
	
	/** 
	 * main method
	 * Here you can choose the image, and set the distortion parameters
	 */
	public static void main(String[] args) {
		
		new ImageJ();
		
		// generate distorted image
		ExerciseGeoU exObj = new ExerciseGeoU(caseNo);
		exObj.init(a,b,d);
		
		// TASK: go to the method doImageUndistortion(...) and complete it 
		exObj.undistortedImage = exObj.doImageUndistortion(exObj.distortedImage);
		
		exObj.originalImage.show("Original Image");
		exObj.distortedImage.show("Distorted Image");
		exObj.undistortedImage.show("Undistorted Image");
		
		Grid2D differenceImage = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.originalImage, exObj.undistortedImage);
		
		differenceImage.show("Difference Original vs. Undistorted");
		
		Grid2D distortedVSundistorted = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.undistortedImage, exObj.distortedImage);
		
		distortedVSundistorted.show("Difference Undistorted vs. Distorted");
	}
	
	public Grid2D doImageUndistortion(Grid2D distortedImage){
		
		Grid2D grid = new Grid2D(distortedImage);
		
		// check if image distortion routine has been run
		if (distortedImage == null || undistortedImage == null
				|| xprime == null || yprime == null
				|| x == null || y == null) {
			
			System.err.println("Error in doImageUndistortion(): called before initialization of members.");
			return grid;
		}
		
		
		getLatticePoints(distortedImage);// There are TODOs here 
		
		
		int degree = 5; // polynomial's degree: 2,...,10
		calcPolynomial(degree, Xd);// There are TODOs here
		
		
		
		computeMatrixA(degree, numCorresp, numCoeff);// There are TODOs here
		
		
		computeDistortionCoeff(A, XuVector, YuVector);// There are TODOs here
		
		
		grid = computeDistortedGrid(distortedImage, grid, degree);// There are TODOs here
		
		return grid;
	}
	
	
	
	/** 1. Number of lattice points (this only works for symmetric images):
	 *  nx, ny feature points: usually provided by tracking point
	 *  correspondences in the phantom during the calibration step.
	 *  Here, we use the distorted and undistorted coordinates generated
	 *  in the course of the distortion simulation.
	 */ 
	public void getLatticePoints (Grid2D distortedImage){
		
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		// step size
		// calculate the step size of the lattice points: fx and fy 
		fx = imageWidth/nx; //TODO
		fy = imageHeight/ny; //TODO
		
		// fill the distorted and undistorted lattice points 
		// with data from the given correspondences
		// matrix = number of rows (y) x number of columns (x)
		Xu = new SimpleMatrix(ny,nx);
		Yu = new SimpleMatrix(ny,nx);
		Xd = new SimpleMatrix(ny,nx);
		Yd = new SimpleMatrix(ny,nx);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){

				// sample the distorted and undistorted grid points at the lattice points
				  Xu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx), j + int(fy)));//TODO: fill matrix Xu
				  Yu.setElementValue(i, j, fy);//TODO: fill matrix Yu
				  Xd.setElementValue(i, j, fx);//TODO: fill matrix Xd
				  Yd.setElementValue(i, j, fy)//TODO: fill matrix Yd
			}
		}
	}
	
	/** 2. Polynomial of degree d
	 * Polynomial of degree d -> (d-1): extrema (e.g., d=5: 4 extrema)
	 * d=0: constant (horizontal line with y-intercept a_0 -> f(x)=a_0)
	 * d=1: oblique line with y-intercept a_0 & slope a_1 -> f(x)=a_0 + a_1 x
	 * d=2: parabola
	 * d>=2: continuous non-linear curve
	 * ...
	 * d = 10 -> NumCoeff: 66 -> but only 64 lattice points are known (nx, ny = 8)
	 */
	
	public void calcPolynomial(int degree, SimpleMatrix Xd){
		
		// number of coefficients: numCoeff
		// (hint: this is NOT the total number of multiplications!)
		numCoeff = 0; //TODO
		
		// number of correspondences: numCorresp
		numCorresp =  0; //TODO
		
		// Printout of the used parameters
		System.out.println("Polynom of degree: " + degree);
		System.out.println("Number of Coefficients: " + numCoeff);
		System.out.println("Number of Correspondences: " + numCorresp);
		
	}
	
	/**
	 * 3. Create the matrix A
	 */
	
	public void computeMatrixA(int degree, int numCorresp, int numCoeff){
		
		A = new SimpleMatrix(numCorresp, numCoeff);
		if (numCorresp <= 0 && numCoeff <= 0)
			return;
		A.zeros();
		
		// Realign the grid matrix into a vector for easier access in the next step
		XuVector = new SimpleVector(numCorresp);
		YuVector = new SimpleVector(numCorresp);
		XdVector = new SimpleVector(numCorresp);
		YdVector = new SimpleVector(numCorresp);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){
				
				XuVector.setElementValue(i*ny + j, Xu.getElement(j, i));
				YuVector.setElementValue(i*ny + j, Yu.getElement(j, i));
				XdVector.setElementValue(i*ny + j, Xd.getElement(j, i));
				YdVector.setElementValue(i*ny + j, Yd.getElement(j, i));
			}
		}
		
		// Compute matrix A (coordinates from distorted image)
		for(int r = 0; r < numCorresp; r++){
			
			int cc = 0;
			
			for(int k = 0; k <= degree; k++){
				for(int l = 0; l <= (degree-k); l++){
					
					// TODO: fill matrix A
					cc++;
					
				}
			}
		}
	}
	
	public void computeDistortionCoeff(SimpleMatrix A, SimpleVector XuVector, SimpleVector YuVector){
		
		// Compute the pseudo-inverse of A with the help of the SVD (class: DecompositionSVD)
		svd = null; // TODO
	    A_pseudoinverse = null; // TODO
	  
		// Compute the distortion coefficients (solve for known corresponding undistorted points)
		u_vec = null;// TODO
		v_vec = null;// TODO
	}
	
	/**
	 * 4. Compute the distorted grid points (xDist, yDist) which are used to sample the
	 * distorted image to get the undistorted image
	 * (xprime,yprime) is the position in the undistorted image
	 * (xDist,yDist) is the position in the distorted (observed) X-ray image.
	 */
	public Grid2D computeDistortedGrid(Grid2D distortedImage, Grid2D grid_out, int degree){
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		xDist = new Grid2D(imageWidth,imageHeight);  
		yDist = new Grid2D(imageWidth,imageHeight); 
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float val1, val2; //variables Val1 and Val2 are used for intermediate computation of xDist and yDist respectively
				
				int cc = 0;
				
				for(int k = 0; k <= degree; k++){
					for(int l = 0; l <= degree - k; l++){
						
						val1 = 0;// TODO
						val2 = 0;// TODO
						
						// TODO: fill xDist
						// TODO: fill yDist
						
						cc++;
					}
				}
			}
		}
		
		float val; // variable for intermediate computations of undistorted image
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				// hint: consider the fact that the coordinate origin is in the center of the image
				val = 0;//TODO
				//TODO: fill grid_out
			}
		}
		
		return grid_out;
		
	}
	
	
	
	/**
	 * 
	 * end of the exercise
	 */	

	
	/**
	 * standard constructor
	 */
	public ExerciseGeoU(){
		
		this(0);
	}
		
	/**
	 * parameterized constructor for the ExerciseDPI object
	 * @param caseNo: select one of three images to test your undistortion method
	 */
	public ExerciseGeoU(int caseNo){
		
		switch (caseNo) {
		case 0:
			filename = "frame32.jpg";
			break;
		case 1:
			filename = "undistorted.jpg";
			break;
		case 2:
			filename = "frame90.jpg";
			break;
		default:
			filename = "frame32.jpg";
			break;
		}
		
		String imageDataLoc = System.getProperty("user.dir") + "/data/" + "/mipda/";
	
		originalImage = ImageUtil.wrapImagePlus(IJ.openImage(imageDataLoc + filename)).getSubGrid(0);
	}
	
	public void init(float a, float b, float d) {
		
		// Normalize intensity values to [0,1]
		float max = NumericPointwiseOperators.max(originalImage);
		float min = NumericPointwiseOperators.min(originalImage);
		
		for(int i = 0; i < originalImage.getWidth(); i++){
			for(int j = 0; j < originalImage.getHeight(); j++){
				
				float scaledValue = (originalImage.getAtIndex(i, j) - min) / (max-min);
				originalImage.setAtIndex(i, j, scaledValue);
			}
		}
		
		undistortedImage = new Grid2D(originalImage.getWidth(),originalImage.getHeight()); // initialization with zeros
		
		distortedImage = generateDistortedImage(originalImage,a,b,d);	
	}
	
	/**
	 * method to generate a distorted image
	 * An artificial distortion field is generated. With this field, 
	 * a distorted image is generated from the original image.
	 * Remark: coordinates of the latest distortion simulated are saved in class member variables
	 * @param inputImage: undistorted image on which distortion is simulated
	 * @param a: elliptic extent of the distortion in x-direction
	 * @param b: elliptic extent of the distortion in y-direction
	 * @param d: strength of the distortion
	 * @return: distorted image
	 */
    
	public Grid2D generateDistortedImage(Grid2D inputImage, float a, float b, float d){

		Grid2D grid = new Grid2D(inputImage);
		int imageWidth = grid.getWidth();
		int imageHeight = grid.getHeight();
		
		// generate grids to sample coordinates X and Y of the original image
		Grid2D X = new Grid2D(imageWidth,imageHeight); // x-coordinates with respect to origin in image center, spacing = 1 [unit]
		Grid2D Y = new Grid2D(imageWidth,imageHeight); // y-coordinates with respect to origin in image center, spacing = 1 [unit]
		
		float halfWidth = imageWidth / 2.0f;
		float halfHeight = imageHeight / 2.0f;
		
		for(int i = 0; i < X.getWidth(); i++){
			for(int j = 0; j < X.getHeight(); j++){
				
				X.setAtIndex(i, j, i - halfWidth + 0.5f); // assign pixel centers in x-direction
				Y.setAtIndex(i, j, j - halfHeight + 0.5f); // assign pixel center in y-direction
			}
		}
		
		// create an artificial elliptical distortion field R (additive field)
		Grid2D R = new Grid2D(imageWidth,imageHeight);

		for(int i = 0; i < R.getWidth(); i++){
			for(int j = 0; j < R.getHeight(); j++){
				
				// distortion gets stronger with the distance from the image center
				float r = d * (float)(Math.sqrt(
						Math.pow(X.getAtIndex(i, j)/(a*halfWidth),2)
						+ Math.pow(Y.getAtIndex(i, j)/(b*halfHeight),2)));
				R.setAtIndex(i, j, r);
			}
		}
		
		// shifting the positive range to half positive/half negative range
		float maxR = NumericPointwiseOperators.max(R);
		NumericPointwiseOperators.subtractBy(R, maxR * 0.5f);

		// create the distorted image coordinates:
		// distorted image coordinates = undistorted image points + artificial distortion field

		// distorted image coordinates Xd, Yd
		Grid2D Xd = new Grid2D(X);
		Grid2D Yd = new Grid2D(Y);
		
		NumericPointwiseOperators.addBy(Xd, R);
		NumericPointwiseOperators.addBy(Yd, R);
		
		// create the distorted image:
		// re-sample the original input image at the distorted image points (Xd,Yd) 
		// to create artificial distortion
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float distortedValue = InterpolationOperators.interpolateLinear(
						inputImage,
						Xd.getAtIndex(i, j) + halfWidth - 0.5f, // remember: coordinate origin was set to image center
						Yd.getAtIndex(i, j) + halfHeight - 0.5f);
				grid.setAtIndex(i, j, distortedValue);
			}
		}

		xprime = X;
		yprime = Y;
		x = Xd;
		y = Yd;
		
		return grid;	
	}	
	
	//getters for members
	// variables which are checked (DO NOT CHANGE!)
	
	public static int get_caseNo() {
		return caseNo;
	}
	
	public Grid2D get_originalImage() {
		return originalImage;
	}
	
	public Grid2D get_distortedImage() {
		return distortedImage;
	}
	
	public Grid2D get_undistortedImage() {
		return undistortedImage;
	}
	
	public int get_nx() {
		return nx;
	}
	
	public int get_ny() {
		return ny;
	}
	
	public float get_fx() {
		return fx;
	}
	
	public float get_fy() {
		return fy;
	}
	
	public SimpleMatrix get_Xu() {
		return Xu;
	}
	
	public SimpleMatrix get_Yu() {
		return Yu;
	}
	
	public SimpleMatrix get_Xd() {
		return Xd;
	}
	
	public SimpleMatrix get_Yd() {
		return Yd;
	}
	
	public int get_numCoeff() {
		return numCoeff;
	}
	
	public int get_numCorresp() {
		return numCorresp;
	}
	
	public SimpleMatrix get_A() {
		return A;
	}
	
	public DecompositionSVD get_svd() {
		return svd;
	}
	
	public SimpleMatrix get_A_pseudoinverse() {
		return A_pseudoinverse;
	}
	
	public SimpleVector get_u_vec() {
		return u_vec;
	}
	
	public SimpleVector get_v_vec() {
		return v_vec;
	}
	
	public SimpleVector get_XuVector() {
		return XuVector;
	}
	
	public SimpleVector get_YuVector() {
		return YuVector;
	}
	
	public SimpleVector get_XdVector() {
		return XdVector;
	}
	
	public SimpleVector get_YdVector() {
		return YdVector;
	}
	
	public Grid2D get_xDist() {
		return xDist;
	}
	
	public Grid2D get_yDist() {
		return yDist;
	}
	
	public Grid2D get_xprime() {
		return xprime;
	}
	
	public Grid2D get_yprime() {
		return yprime;
	}
	
	public Grid2D get_x() {
		return x;
	}
	
	public Grid2D get_y() {
		return y;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-15 23:57:34.298
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-15 23:57:34.299
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-15 23:57:35.300
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package edu.stanford.rsl.tutorial.mipda;

import edu.stanford.rsl.conrad.data.numeric.Grid2D;
import edu.stanford.rsl.conrad.data.numeric.NumericPointwiseOperators;
import edu.stanford.rsl.conrad.utils.ImageUtil;
//import edu.stanford.rsl.conrad.utils.VisualizationUtil;
import ij.IJ;
import ij.ImageJ;
import edu.stanford.rsl.conrad.data.numeric.InterpolationOperators;
//import edu.stanford.rsl.conrad.data.numeric.NumericGridOperator;
import edu.stanford.rsl.conrad.numerics.SimpleMatrix;
import edu.stanford.rsl.conrad.numerics.SimpleOperators;
import edu.stanford.rsl.conrad.numerics.SimpleVector;
import edu.stanford.rsl.conrad.numerics.DecompositionSVD;

/**
 * Geometric Undistortion
 * Programming exercise 1 for module "Defect Pixel Interpolation"
 * of the course "Medical Image Processing for Diagnostic Applications (MIPDA)"
 * @author Frank Schebesch, Ashwini Jadhav, Anna Gebhard, Mena Abdelmalek
 *
 */

public class ExerciseGeoU {

	final static int caseNo = 1; // choose 0, 1, or 2 for different test images

	final static float a = 0.6f; // a: spread among x-direction
	final static float b = 0.3f; // b: spread among y-direction
	final static float d = 5.0f; // d: d/2 value of distortion field at level set for (X/a)^2+(Y/b)^2=1
	
	String filename; // do not edit, choose a number in the main method instead
	Grid2D originalImage; // do not edit, read from filename when instantiating the object
	Grid2D distortedImage; // do not edit, generated in the main method
	Grid2D undistortedImage; // do not edit, member variable for the output image
	
	// number of lattice points
	final int nx = 8;//TODO: define the number of lattice point: nx (Positive number and less than 20)
	final int ny = 8;//TODO: define the number of lattice point: ny (Positive number and less than 20)
	
	float fx;
	float fy;
	SimpleMatrix Xu; 
	SimpleMatrix Yu;
	SimpleMatrix Xd;
	SimpleMatrix Yd;
	int numCoeff; 
	int numCorresp; 
	SimpleMatrix A;
	DecompositionSVD svd;
	SimpleMatrix A_pseudoinverse;
	SimpleVector u_vec;
	SimpleVector v_vec;
	SimpleVector XuVector;
	SimpleVector YuVector;
	SimpleVector XdVector;
	SimpleVector YdVector;
	Grid2D xDist;  
	Grid2D yDist;
	Grid2D xprime; // x-coordinates of point correspondences in the undistorted image
	Grid2D yprime; // y-coordinates of point correspondences in the undistorted image
	Grid2D x; // x-coordinates of point correspondences in the distorted image
	Grid2D y; // y-coordinates of point correspondences in the distorted image
	
	
	/** 
	 * main method
	 * Here you can choose the image, and set the distortion parameters
	 */
	public static void main(String[] args) {
		
		new ImageJ();
		
		// generate distorted image
		ExerciseGeoU exObj = new ExerciseGeoU(caseNo);
		exObj.init(a,b,d);
		
		// TASK: go to the method doImageUndistortion(...) and complete it 
		exObj.undistortedImage = exObj.doImageUndistortion(exObj.distortedImage);
		
		exObj.originalImage.show("Original Image");
		exObj.distortedImage.show("Distorted Image");
		exObj.undistortedImage.show("Undistorted Image");
		
		Grid2D differenceImage = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.originalImage, exObj.undistortedImage);
		
		differenceImage.show("Difference Original vs. Undistorted");
		
		Grid2D distortedVSundistorted = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.undistortedImage, exObj.distortedImage);
		
		distortedVSundistorted.show("Difference Undistorted vs. Distorted");
	}
	
	public Grid2D doImageUndistortion(Grid2D distortedImage){
		
		Grid2D grid = new Grid2D(distortedImage);
		
		// check if image distortion routine has been run
		if (distortedImage == null || undistortedImage == null
				|| xprime == null || yprime == null
				|| x == null || y == null) {
			
			System.err.println("Error in doImageUndistortion(): called before initialization of members.");
			return grid;
		}
		
		
		getLatticePoints(distortedImage);// There are TODOs here 
		
		
		int degree = 5; // polynomial's degree: 2,...,10
		calcPolynomial(degree, Xd);// There are TODOs here
		
		
		
		computeMatrixA(degree, numCorresp, numCoeff);// There are TODOs here
		
		
		computeDistortionCoeff(A, XuVector, YuVector);// There are TODOs here
		
		
		grid = computeDistortedGrid(distortedImage, grid, degree);// There are TODOs here
		
		return grid;
	}
	
	
	
	/** 1. Number of lattice points (this only works for symmetric images):
	 *  nx, ny feature points: usually provided by tracking point
	 *  correspondences in the phantom during the calibration step.
	 *  Here, we use the distorted and undistorted coordinates generated
	 *  in the course of the distortion simulation.
	 */ 
	public void getLatticePoints (Grid2D distortedImage){
		
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		// step size
		// calculate the step size of the lattice points: fx and fy 
		fx = imageWidth/nx; //TODO
		fy = imageHeight/ny; //TODO
		
		// fill the distorted and undistorted lattice points 
		// with data from the given correspondences
		// matrix = number of rows (y) x number of columns (x)
		Xu = new SimpleMatrix(ny,nx);
		Yu = new SimpleMatrix(ny,nx);
		Xd = new SimpleMatrix(ny,nx);
		Yd = new SimpleMatrix(ny,nx);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){

				// sample the distorted and undistorted grid points at the lattice points
				  Xu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx), j + int(fy)));//TODO: fill matrix Xu
				  Yu.setElementValue(i, j, fy);//TODO: fill matrix Yu
				  Xd.setElementValue(i, j, fx);//TODO: fill matrix Xd
				  Yd.setElementValue(i, j, fy)//TODO: fill matrix Yd
			}
		}
	}
	
	/** 2. Polynomial of degree d
	 * Polynomial of degree d -> (d-1): extrema (e.g., d=5: 4 extrema)
	 * d=0: constant (horizontal line with y-intercept a_0 -> f(x)=a_0)
	 * d=1: oblique line with y-intercept a_0 & slope a_1 -> f(x)=a_0 + a_1 x
	 * d=2: parabola
	 * d>=2: continuous non-linear curve
	 * ...
	 * d = 10 -> NumCoeff: 66 -> but only 64 lattice points are known (nx, ny = 8)
	 */
	
	public void calcPolynomial(int degree, SimpleMatrix Xd){
		
		// number of coefficients: numCoeff
		// (hint: this is NOT the total number of multiplications!)
		numCoeff = 0; //TODO
		
		// number of correspondences: numCorresp
		numCorresp =  0; //TODO
		
		// Printout of the used parameters
		System.out.println("Polynom of degree: " + degree);
		System.out.println("Number of Coefficients: " + numCoeff);
		System.out.println("Number of Correspondences: " + numCorresp);
		
	}
	
	/**
	 * 3. Create the matrix A
	 */
	
	public void computeMatrixA(int degree, int numCorresp, int numCoeff){
		
		A = new SimpleMatrix(numCorresp, numCoeff);
		if (numCorresp <= 0 && numCoeff <= 0)
			return;
		A.zeros();
		
		// Realign the grid matrix into a vector for easier access in the next step
		XuVector = new SimpleVector(numCorresp);
		YuVector = new SimpleVector(numCorresp);
		XdVector = new SimpleVector(numCorresp);
		YdVector = new SimpleVector(numCorresp);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){
				
				XuVector.setElementValue(i*ny + j, Xu.getElement(j, i));
				YuVector.setElementValue(i*ny + j, Yu.getElement(j, i));
				XdVector.setElementValue(i*ny + j, Xd.getElement(j, i));
				YdVector.setElementValue(i*ny + j, Yd.getElement(j, i));
			}
		}
		
		// Compute matrix A (coordinates from distorted image)
		for(int r = 0; r < numCorresp; r++){
			
			int cc = 0;
			
			for(int k = 0; k <= degree; k++){
				for(int l = 0; l <= (degree-k); l++){
					
					// TODO: fill matrix A
					cc++;
					
				}
			}
		}
	}
	
	public void computeDistortionCoeff(SimpleMatrix A, SimpleVector XuVector, SimpleVector YuVector){
		
		// Compute the pseudo-inverse of A with the help of the SVD (class: DecompositionSVD)
		svd = null; // TODO
	    A_pseudoinverse = null; // TODO
	  
		// Compute the distortion coefficients (solve for known corresponding undistorted points)
		u_vec = null;// TODO
		v_vec = null;// TODO
	}
	
	/**
	 * 4. Compute the distorted grid points (xDist, yDist) which are used to sample the
	 * distorted image to get the undistorted image
	 * (xprime,yprime) is the position in the undistorted image
	 * (xDist,yDist) is the position in the distorted (observed) X-ray image.
	 */
	public Grid2D computeDistortedGrid(Grid2D distortedImage, Grid2D grid_out, int degree){
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		xDist = new Grid2D(imageWidth,imageHeight);  
		yDist = new Grid2D(imageWidth,imageHeight); 
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float val1, val2; //variables Val1 and Val2 are used for intermediate computation of xDist and yDist respectively
				
				int cc = 0;
				
				for(int k = 0; k <= degree; k++){
					for(int l = 0; l <= degree - k; l++){
						
						val1 = 0;// TODO
						val2 = 0;// TODO
						
						// TODO: fill xDist
						// TODO: fill yDist
						
						cc++;
					}
				}
			}
		}
		
		float val; // variable for intermediate computations of undistorted image
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				// hint: consider the fact that the coordinate origin is in the center of the image
				val = 0;//TODO
				//TODO: fill grid_out
			}
		}
		
		return grid_out;
		
	}
	
	
	
	/**
	 * 
	 * end of the exercise
	 */	

	
	/**
	 * standard constructor
	 */
	public ExerciseGeoU(){
		
		this(0);
	}
		
	/**
	 * parameterized constructor for the ExerciseDPI object
	 * @param caseNo: select one of three images to test your undistortion method
	 */
	public ExerciseGeoU(int caseNo){
		
		switch (caseNo) {
		case 0:
			filename = "frame32.jpg";
			break;
		case 1:
			filename = "undistorted.jpg";
			break;
		case 2:
			filename = "frame90.jpg";
			break;
		default:
			filename = "frame32.jpg";
			break;
		}
		
		String imageDataLoc = System.getProperty("user.dir") + "/data/" + "/mipda/";
	
		originalImage = ImageUtil.wrapImagePlus(IJ.openImage(imageDataLoc + filename)).getSubGrid(0);
	}
	
	public void init(float a, float b, float d) {
		
		// Normalize intensity values to [0,1]
		float max = NumericPointwiseOperators.max(originalImage);
		float min = NumericPointwiseOperators.min(originalImage);
		
		for(int i = 0; i < originalImage.getWidth(); i++){
			for(int j = 0; j < originalImage.getHeight(); j++){
				
				float scaledValue = (originalImage.getAtIndex(i, j) - min) / (max-min);
				originalImage.setAtIndex(i, j, scaledValue);
			}
		}
		
		undistortedImage = new Grid2D(originalImage.getWidth(),originalImage.getHeight()); // initialization with zeros
		
		distortedImage = generateDistortedImage(originalImage,a,b,d);	
	}
	
	/**
	 * method to generate a distorted image
	 * An artificial distortion field is generated. With this field, 
	 * a distorted image is generated from the original image.
	 * Remark: coordinates of the latest distortion simulated are saved in class member variables
	 * @param inputImage: undistorted image on which distortion is simulated
	 * @param a: elliptic extent of the distortion in x-direction
	 * @param b: elliptic extent of the distortion in y-direction
	 * @param d: strength of the distortion
	 * @return: distorted image
	 */
    
	public Grid2D generateDistortedImage(Grid2D inputImage, float a, float b, float d){

		Grid2D grid = new Grid2D(inputImage);
		int imageWidth = grid.getWidth();
		int imageHeight = grid.getHeight();
		
		// generate grids to sample coordinates X and Y of the original image
		Grid2D X = new Grid2D(imageWidth,imageHeight); // x-coordinates with respect to origin in image center, spacing = 1 [unit]
		Grid2D Y = new Grid2D(imageWidth,imageHeight); // y-coordinates with respect to origin in image center, spacing = 1 [unit]
		
		float halfWidth = imageWidth / 2.0f;
		float halfHeight = imageHeight / 2.0f;
		
		for(int i = 0; i < X.getWidth(); i++){
			for(int j = 0; j < X.getHeight(); j++){
				
				X.setAtIndex(i, j, i - halfWidth + 0.5f); // assign pixel centers in x-direction
				Y.setAtIndex(i, j, j - halfHeight + 0.5f); // assign pixel center in y-direction
			}
		}
		
		// create an artificial elliptical distortion field R (additive field)
		Grid2D R = new Grid2D(imageWidth,imageHeight);

		for(int i = 0; i < R.getWidth(); i++){
			for(int j = 0; j < R.getHeight(); j++){
				
				// distortion gets stronger with the distance from the image center
				float r = d * (float)(Math.sqrt(
						Math.pow(X.getAtIndex(i, j)/(a*halfWidth),2)
						+ Math.pow(Y.getAtIndex(i, j)/(b*halfHeight),2)));
				R.setAtIndex(i, j, r);
			}
		}
		
		// shifting the positive range to half positive/half negative range
		float maxR = NumericPointwiseOperators.max(R);
		NumericPointwiseOperators.subtractBy(R, maxR * 0.5f);

		// create the distorted image coordinates:
		// distorted image coordinates = undistorted image points + artificial distortion field

		// distorted image coordinates Xd, Yd
		Grid2D Xd = new Grid2D(X);
		Grid2D Yd = new Grid2D(Y);
		
		NumericPointwiseOperators.addBy(Xd, R);
		NumericPointwiseOperators.addBy(Yd, R);
		
		// create the distorted image:
		// re-sample the original input image at the distorted image points (Xd,Yd) 
		// to create artificial distortion
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float distortedValue = InterpolationOperators.interpolateLinear(
						inputImage,
						Xd.getAtIndex(i, j) + halfWidth - 0.5f, // remember: coordinate origin was set to image center
						Yd.getAtIndex(i, j) + halfHeight - 0.5f);
				grid.setAtIndex(i, j, distortedValue);
			}
		}

		xprime = X;
		yprime = Y;
		x = Xd;
		y = Yd;
		
		return grid;	
	}	
	
	//getters for members
	// variables which are checked (DO NOT CHANGE!)
	
	public static int get_caseNo() {
		return caseNo;
	}
	
	public Grid2D get_originalImage() {
		return originalImage;
	}
	
	public Grid2D get_distortedImage() {
		return distortedImage;
	}
	
	public Grid2D get_undistortedImage() {
		return undistortedImage;
	}
	
	public int get_nx() {
		return nx;
	}
	
	public int get_ny() {
		return ny;
	}
	
	public float get_fx() {
		return fx;
	}
	
	public float get_fy() {
		return fy;
	}
	
	public SimpleMatrix get_Xu() {
		return Xu;
	}
	
	public SimpleMatrix get_Yu() {
		return Yu;
	}
	
	public SimpleMatrix get_Xd() {
		return Xd;
	}
	
	public SimpleMatrix get_Yd() {
		return Yd;
	}
	
	public int get_numCoeff() {
		return numCoeff;
	}
	
	public int get_numCorresp() {
		return numCorresp;
	}
	
	public SimpleMatrix get_A() {
		return A;
	}
	
	public DecompositionSVD get_svd() {
		return svd;
	}
	
	public SimpleMatrix get_A_pseudoinverse() {
		return A_pseudoinverse;
	}
	
	public SimpleVector get_u_vec() {
		return u_vec;
	}
	
	public SimpleVector get_v_vec() {
		return v_vec;
	}
	
	public SimpleVector get_XuVector() {
		return XuVector;
	}
	
	public SimpleVector get_YuVector() {
		return YuVector;
	}
	
	public SimpleVector get_XdVector() {
		return XdVector;
	}
	
	public SimpleVector get_YdVector() {
		return YdVector;
	}
	
	public Grid2D get_xDist() {
		return xDist;
	}
	
	public Grid2D get_yDist() {
		return yDist;
	}
	
	public Grid2D get_xprime() {
		return xprime;
	}
	
	public Grid2D get_yprime() {
		return yprime;
	}
	
	public Grid2D get_x() {
		return x;
	}
	
	public Grid2D get_y() {
		return y;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-15 23:57:35.301
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-15 23:57:35.301
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-15 23:57:38.190
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package edu.stanford.rsl.tutorial.mipda;

import edu.stanford.rsl.conrad.data.numeric.Grid2D;
import edu.stanford.rsl.conrad.data.numeric.NumericPointwiseOperators;
import edu.stanford.rsl.conrad.utils.ImageUtil;
//import edu.stanford.rsl.conrad.utils.VisualizationUtil;
import ij.IJ;
import ij.ImageJ;
import edu.stanford.rsl.conrad.data.numeric.InterpolationOperators;
//import edu.stanford.rsl.conrad.data.numeric.NumericGridOperator;
import edu.stanford.rsl.conrad.numerics.SimpleMatrix;
import edu.stanford.rsl.conrad.numerics.SimpleOperators;
import edu.stanford.rsl.conrad.numerics.SimpleVector;
import edu.stanford.rsl.conrad.numerics.DecompositionSVD;

/**
 * Geometric Undistortion
 * Programming exercise 1 for module "Defect Pixel Interpolation"
 * of the course "Medical Image Processing for Diagnostic Applications (MIPDA)"
 * @author Frank Schebesch, Ashwini Jadhav, Anna Gebhard, Mena Abdelmalek
 *
 */

public class ExerciseGeoU {

	final static int caseNo = 1; // choose 0, 1, or 2 for different test images

	final static float a = 0.6f; // a: spread among x-direction
	final static float b = 0.3f; // b: spread among y-direction
	final static float d = 5.0f; // d: d/2 value of distortion field at level set for (X/a)^2+(Y/b)^2=1
	
	String filename; // do not edit, choose a number in the main method instead
	Grid2D originalImage; // do not edit, read from filename when instantiating the object
	Grid2D distortedImage; // do not edit, generated in the main method
	Grid2D undistortedImage; // do not edit, member variable for the output image
	
	// number of lattice points
	final int nx = 8;//TODO: define the number of lattice point: nx (Positive number and less than 20)
	final int ny = 8;//TODO: define the number of lattice point: ny (Positive number and less than 20)
	
	float fx;
	float fy;
	SimpleMatrix Xu; 
	SimpleMatrix Yu;
	SimpleMatrix Xd;
	SimpleMatrix Yd;
	int numCoeff; 
	int numCorresp; 
	SimpleMatrix A;
	DecompositionSVD svd;
	SimpleMatrix A_pseudoinverse;
	SimpleVector u_vec;
	SimpleVector v_vec;
	SimpleVector XuVector;
	SimpleVector YuVector;
	SimpleVector XdVector;
	SimpleVector YdVector;
	Grid2D xDist;  
	Grid2D yDist;
	Grid2D xprime; // x-coordinates of point correspondences in the undistorted image
	Grid2D yprime; // y-coordinates of point correspondences in the undistorted image
	Grid2D x; // x-coordinates of point correspondences in the distorted image
	Grid2D y; // y-coordinates of point correspondences in the distorted image
	
	
	/** 
	 * main method
	 * Here you can choose the image, and set the distortion parameters
	 */
	public static void main(String[] args) {
		
		new ImageJ();
		
		// generate distorted image
		ExerciseGeoU exObj = new ExerciseGeoU(caseNo);
		exObj.init(a,b,d);
		
		// TASK: go to the method doImageUndistortion(...) and complete it 
		exObj.undistortedImage = exObj.doImageUndistortion(exObj.distortedImage);
		
		exObj.originalImage.show("Original Image");
		exObj.distortedImage.show("Distorted Image");
		exObj.undistortedImage.show("Undistorted Image");
		
		Grid2D differenceImage = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.originalImage, exObj.undistortedImage);
		
		differenceImage.show("Difference Original vs. Undistorted");
		
		Grid2D distortedVSundistorted = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.undistortedImage, exObj.distortedImage);
		
		distortedVSundistorted.show("Difference Undistorted vs. Distorted");
	}
	
	public Grid2D doImageUndistortion(Grid2D distortedImage){
		
		Grid2D grid = new Grid2D(distortedImage);
		
		// check if image distortion routine has been run
		if (distortedImage == null || undistortedImage == null
				|| xprime == null || yprime == null
				|| x == null || y == null) {
			
			System.err.println("Error in doImageUndistortion(): called before initialization of members.");
			return grid;
		}
		
		
		getLatticePoints(distortedImage);// There are TODOs here 
		
		
		int degree = 5; // polynomial's degree: 2,...,10
		calcPolynomial(degree, Xd);// There are TODOs here
		
		
		
		computeMatrixA(degree, numCorresp, numCoeff);// There are TODOs here
		
		
		computeDistortionCoeff(A, XuVector, YuVector);// There are TODOs here
		
		
		grid = computeDistortedGrid(distortedImage, grid, degree);// There are TODOs here
		
		return grid;
	}
	
	
	
	/** 1. Number of lattice points (this only works for symmetric images):
	 *  nx, ny feature points: usually provided by tracking point
	 *  correspondences in the phantom during the calibration step.
	 *  Here, we use the distorted and undistorted coordinates generated
	 *  in the course of the distortion simulation.
	 */ 
	public void getLatticePoints (Grid2D distortedImage){
		
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		// step size
		// calculate the step size of the lattice points: fx and fy 
		fx = imageWidth/nx; //TODO
		fy = imageHeight/ny; //TODO
		
		// fill the distorted and undistorted lattice points 
		// with data from the given correspondences
		// matrix = number of rows (y) x number of columns (x)
		Xu = new SimpleMatrix(ny,nx);
		Yu = new SimpleMatrix(ny,nx);
		Xd = new SimpleMatrix(ny,nx);
		Yd = new SimpleMatrix(ny,nx);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){

				// sample the distorted and undistorted grid points at the lattice points
				  Xu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx), j + int(fy)));//TODO: fill matrix Xu
				  Yu.setElementValue(i, j, fy);//TODO: fill matrix Yu
				  Xd.setElementValue(i, j, fx);//TODO: fill matrix Xd
				  Yd.setElementValue(i, j, fy)//TODO: fill matrix Yd
			}
		}
	}
	
	/** 2. Polynomial of degree d
	 * Polynomial of degree d -> (d-1): extrema (e.g., d=5: 4 extrema)
	 * d=0: constant (horizontal line with y-intercept a_0 -> f(x)=a_0)
	 * d=1: oblique line with y-intercept a_0 & slope a_1 -> f(x)=a_0 + a_1 x
	 * d=2: parabola
	 * d>=2: continuous non-linear curve
	 * ...
	 * d = 10 -> NumCoeff: 66 -> but only 64 lattice points are known (nx, ny = 8)
	 */
	
	public void calcPolynomial(int degree, SimpleMatrix Xd){
		
		// number of coefficients: numCoeff
		// (hint: this is NOT the total number of multiplications!)
		numCoeff = 0; //TODO
		
		// number of correspondences: numCorresp
		numCorresp =  0; //TODO
		
		// Printout of the used parameters
		System.out.println("Polynom of degree: " + degree);
		System.out.println("Number of Coefficients: " + numCoeff);
		System.out.println("Number of Correspondences: " + numCorresp);
		
	}
	
	/**
	 * 3. Create the matrix A
	 */
	
	public void computeMatrixA(int degree, int numCorresp, int numCoeff){
		
		A = new SimpleMatrix(numCorresp, numCoeff);
		if (numCorresp <= 0 && numCoeff <= 0)
			return;
		A.zeros();
		
		// Realign the grid matrix into a vector for easier access in the next step
		XuVector = new SimpleVector(numCorresp);
		YuVector = new SimpleVector(numCorresp);
		XdVector = new SimpleVector(numCorresp);
		YdVector = new SimpleVector(numCorresp);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){
				
				XuVector.setElementValue(i*ny + j, Xu.getElement(j, i));
				YuVector.setElementValue(i*ny + j, Yu.getElement(j, i));
				XdVector.setElementValue(i*ny + j, Xd.getElement(j, i));
				YdVector.setElementValue(i*ny + j, Yd.getElement(j, i));
			}
		}
		
		// Compute matrix A (coordinates from distorted image)
		for(int r = 0; r < numCorresp; r++){
			
			int cc = 0;
			
			for(int k = 0; k <= degree; k++){
				for(int l = 0; l <= (degree-k); l++){
					
					// TODO: fill matrix A
					cc++;
					
				}
			}
		}
	}
	
	public void computeDistortionCoeff(SimpleMatrix A, SimpleVector XuVector, SimpleVector YuVector){
		
		// Compute the pseudo-inverse of A with the help of the SVD (class: DecompositionSVD)
		svd = null; // TODO
	    A_pseudoinverse = null; // TODO
	  
		// Compute the distortion coefficients (solve for known corresponding undistorted points)
		u_vec = null;// TODO
		v_vec = null;// TODO
	}
	
	/**
	 * 4. Compute the distorted grid points (xDist, yDist) which are used to sample the
	 * distorted image to get the undistorted image
	 * (xprime,yprime) is the position in the undistorted image
	 * (xDist,yDist) is the position in the distorted (observed) X-ray image.
	 */
	public Grid2D computeDistortedGrid(Grid2D distortedImage, Grid2D grid_out, int degree){
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		xDist = new Grid2D(imageWidth,imageHeight);  
		yDist = new Grid2D(imageWidth,imageHeight); 
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float val1, val2; //variables Val1 and Val2 are used for intermediate computation of xDist and yDist respectively
				
				int cc = 0;
				
				for(int k = 0; k <= degree; k++){
					for(int l = 0; l <= degree - k; l++){
						
						val1 = 0;// TODO
						val2 = 0;// TODO
						
						// TODO: fill xDist
						// TODO: fill yDist
						
						cc++;
					}
				}
			}
		}
		
		float val; // variable for intermediate computations of undistorted image
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				// hint: consider the fact that the coordinate origin is in the center of the image
				val = 0;//TODO
				//TODO: fill grid_out
			}
		}
		
		return grid_out;
		
	}
	
	
	
	/**
	 * 
	 * end of the exercise
	 */	

	
	/**
	 * standard constructor
	 */
	public ExerciseGeoU(){
		
		this(0);
	}
		
	/**
	 * parameterized constructor for the ExerciseDPI object
	 * @param caseNo: select one of three images to test your undistortion method
	 */
	public ExerciseGeoU(int caseNo){
		
		switch (caseNo) {
		case 0:
			filename = "frame32.jpg";
			break;
		case 1:
			filename = "undistorted.jpg";
			break;
		case 2:
			filename = "frame90.jpg";
			break;
		default:
			filename = "frame32.jpg";
			break;
		}
		
		String imageDataLoc = System.getProperty("user.dir") + "/data/" + "/mipda/";
	
		originalImage = ImageUtil.wrapImagePlus(IJ.openImage(imageDataLoc + filename)).getSubGrid(0);
	}
	
	public void init(float a, float b, float d) {
		
		// Normalize intensity values to [0,1]
		float max = NumericPointwiseOperators.max(originalImage);
		float min = NumericPointwiseOperators.min(originalImage);
		
		for(int i = 0; i < originalImage.getWidth(); i++){
			for(int j = 0; j < originalImage.getHeight(); j++){
				
				float scaledValue = (originalImage.getAtIndex(i, j) - min) / (max-min);
				originalImage.setAtIndex(i, j, scaledValue);
			}
		}
		
		undistortedImage = new Grid2D(originalImage.getWidth(),originalImage.getHeight()); // initialization with zeros
		
		distortedImage = generateDistortedImage(originalImage,a,b,d);	
	}
	
	/**
	 * method to generate a distorted image
	 * An artificial distortion field is generated. With this field, 
	 * a distorted image is generated from the original image.
	 * Remark: coordinates of the latest distortion simulated are saved in class member variables
	 * @param inputImage: undistorted image on which distortion is simulated
	 * @param a: elliptic extent of the distortion in x-direction
	 * @param b: elliptic extent of the distortion in y-direction
	 * @param d: strength of the distortion
	 * @return: distorted image
	 */
    
	public Grid2D generateDistortedImage(Grid2D inputImage, float a, float b, float d){

		Grid2D grid = new Grid2D(inputImage);
		int imageWidth = grid.getWidth();
		int imageHeight = grid.getHeight();
		
		// generate grids to sample coordinates X and Y of the original image
		Grid2D X = new Grid2D(imageWidth,imageHeight); // x-coordinates with respect to origin in image center, spacing = 1 [unit]
		Grid2D Y = new Grid2D(imageWidth,imageHeight); // y-coordinates with respect to origin in image center, spacing = 1 [unit]
		
		float halfWidth = imageWidth / 2.0f;
		float halfHeight = imageHeight / 2.0f;
		
		for(int i = 0; i < X.getWidth(); i++){
			for(int j = 0; j < X.getHeight(); j++){
				
				X.setAtIndex(i, j, i - halfWidth + 0.5f); // assign pixel centers in x-direction
				Y.setAtIndex(i, j, j - halfHeight + 0.5f); // assign pixel center in y-direction
			}
		}
		
		// create an artificial elliptical distortion field R (additive field)
		Grid2D R = new Grid2D(imageWidth,imageHeight);

		for(int i = 0; i < R.getWidth(); i++){
			for(int j = 0; j < R.getHeight(); j++){
				
				// distortion gets stronger with the distance from the image center
				float r = d * (float)(Math.sqrt(
						Math.pow(X.getAtIndex(i, j)/(a*halfWidth),2)
						+ Math.pow(Y.getAtIndex(i, j)/(b*halfHeight),2)));
				R.setAtIndex(i, j, r);
			}
		}
		
		// shifting the positive range to half positive/half negative range
		float maxR = NumericPointwiseOperators.max(R);
		NumericPointwiseOperators.subtractBy(R, maxR * 0.5f);

		// create the distorted image coordinates:
		// distorted image coordinates = undistorted image points + artificial distortion field

		// distorted image coordinates Xd, Yd
		Grid2D Xd = new Grid2D(X);
		Grid2D Yd = new Grid2D(Y);
		
		NumericPointwiseOperators.addBy(Xd, R);
		NumericPointwiseOperators.addBy(Yd, R);
		
		// create the distorted image:
		// re-sample the original input image at the distorted image points (Xd,Yd) 
		// to create artificial distortion
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float distortedValue = InterpolationOperators.interpolateLinear(
						inputImage,
						Xd.getAtIndex(i, j) + halfWidth - 0.5f, // remember: coordinate origin was set to image center
						Yd.getAtIndex(i, j) + halfHeight - 0.5f);
				grid.setAtIndex(i, j, distortedValue);
			}
		}

		xprime = X;
		yprime = Y;
		x = Xd;
		y = Yd;
		
		return grid;	
	}	
	
	//getters for members
	// variables which are checked (DO NOT CHANGE!)
	
	public static int get_caseNo() {
		return caseNo;
	}
	
	public Grid2D get_originalImage() {
		return originalImage;
	}
	
	public Grid2D get_distortedImage() {
		return distortedImage;
	}
	
	public Grid2D get_undistortedImage() {
		return undistortedImage;
	}
	
	public int get_nx() {
		return nx;
	}
	
	public int get_ny() {
		return ny;
	}
	
	public float get_fx() {
		return fx;
	}
	
	public float get_fy() {
		return fy;
	}
	
	public SimpleMatrix get_Xu() {
		return Xu;
	}
	
	public SimpleMatrix get_Yu() {
		return Yu;
	}
	
	public SimpleMatrix get_Xd() {
		return Xd;
	}
	
	public SimpleMatrix get_Yd() {
		return Yd;
	}
	
	public int get_numCoeff() {
		return numCoeff;
	}
	
	public int get_numCorresp() {
		return numCorresp;
	}
	
	public SimpleMatrix get_A() {
		return A;
	}
	
	public DecompositionSVD get_svd() {
		return svd;
	}
	
	public SimpleMatrix get_A_pseudoinverse() {
		return A_pseudoinverse;
	}
	
	public SimpleVector get_u_vec() {
		return u_vec;
	}
	
	public SimpleVector get_v_vec() {
		return v_vec;
	}
	
	public SimpleVector get_XuVector() {
		return XuVector;
	}
	
	public SimpleVector get_YuVector() {
		return YuVector;
	}
	
	public SimpleVector get_XdVector() {
		return XdVector;
	}
	
	public SimpleVector get_YdVector() {
		return YdVector;
	}
	
	public Grid2D get_xDist() {
		return xDist;
	}
	
	public Grid2D get_yDist() {
		return yDist;
	}
	
	public Grid2D get_xprime() {
		return xprime;
	}
	
	public Grid2D get_yprime() {
		return yprime;
	}
	
	public Grid2D get_x() {
		return x;
	}
	
	public Grid2D get_y() {
		return y;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:479)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:406)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:365)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:286)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1270)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1059)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1111)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1107)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1536)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4875)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4753)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4958)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-15 23:57:38.191
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:479)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:406)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:365)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:286)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1270)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1059)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1111)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1107)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1536)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4875)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4753)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4958)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-15 23:57:38.191
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:479)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:406)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:365)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:286)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1270)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1059)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1069)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1111)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1107)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1536)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4875)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4753)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4958)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-15 23:57:39.999
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package edu.stanford.rsl.tutorial.mipda;

import edu.stanford.rsl.conrad.data.numeric.Grid2D;
import edu.stanford.rsl.conrad.data.numeric.NumericPointwiseOperators;
import edu.stanford.rsl.conrad.utils.ImageUtil;
//import edu.stanford.rsl.conrad.utils.VisualizationUtil;
import ij.IJ;
import ij.ImageJ;
import edu.stanford.rsl.conrad.data.numeric.InterpolationOperators;
//import edu.stanford.rsl.conrad.data.numeric.NumericGridOperator;
import edu.stanford.rsl.conrad.numerics.SimpleMatrix;
import edu.stanford.rsl.conrad.numerics.SimpleOperators;
import edu.stanford.rsl.conrad.numerics.SimpleVector;
import edu.stanford.rsl.conrad.numerics.DecompositionSVD;

/**
 * Geometric Undistortion
 * Programming exercise 1 for module "Defect Pixel Interpolation"
 * of the course "Medical Image Processing for Diagnostic Applications (MIPDA)"
 * @author Frank Schebesch, Ashwini Jadhav, Anna Gebhard, Mena Abdelmalek
 *
 */

public class ExerciseGeoU {

	final static int caseNo = 1; // choose 0, 1, or 2 for different test images

	final static float a = 0.6f; // a: spread among x-direction
	final static float b = 0.3f; // b: spread among y-direction
	final static float d = 5.0f; // d: d/2 value of distortion field at level set for (X/a)^2+(Y/b)^2=1
	
	String filename; // do not edit, choose a number in the main method instead
	Grid2D originalImage; // do not edit, read from filename when instantiating the object
	Grid2D distortedImage; // do not edit, generated in the main method
	Grid2D undistortedImage; // do not edit, member variable for the output image
	
	// number of lattice points
	final int nx = 8;//TODO: define the number of lattice point: nx (Positive number and less than 20)
	final int ny = 8;//TODO: define the number of lattice point: ny (Positive number and less than 20)
	
	float fx;
	float fy;
	SimpleMatrix Xu; 
	SimpleMatrix Yu;
	SimpleMatrix Xd;
	SimpleMatrix Yd;
	int numCoeff; 
	int numCorresp; 
	SimpleMatrix A;
	DecompositionSVD svd;
	SimpleMatrix A_pseudoinverse;
	SimpleVector u_vec;
	SimpleVector v_vec;
	SimpleVector XuVector;
	SimpleVector YuVector;
	SimpleVector XdVector;
	SimpleVector YdVector;
	Grid2D xDist;  
	Grid2D yDist;
	Grid2D xprime; // x-coordinates of point correspondences in the undistorted image
	Grid2D yprime; // y-coordinates of point correspondences in the undistorted image
	Grid2D x; // x-coordinates of point correspondences in the distorted image
	Grid2D y; // y-coordinates of point correspondences in the distorted image
	
	
	/** 
	 * main method
	 * Here you can choose the image, and set the distortion parameters
	 */
	public static void main(String[] args) {
		
		new ImageJ();
		
		// generate distorted image
		ExerciseGeoU exObj = new ExerciseGeoU(caseNo);
		exObj.init(a,b,d);
		
		// TASK: go to the method doImageUndistortion(...) and complete it 
		exObj.undistortedImage = exObj.doImageUndistortion(exObj.distortedImage);
		
		exObj.originalImage.show("Original Image");
		exObj.distortedImage.show("Distorted Image");
		exObj.undistortedImage.show("Undistorted Image");
		
		Grid2D differenceImage = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.originalImage, exObj.undistortedImage);
		
		differenceImage.show("Difference Original vs. Undistorted");
		
		Grid2D distortedVSundistorted = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.undistortedImage, exObj.distortedImage);
		
		distortedVSundistorted.show("Difference Undistorted vs. Distorted");
	}
	
	public Grid2D doImageUndistortion(Grid2D distortedImage){
		
		Grid2D grid = new Grid2D(distortedImage);
		
		// check if image distortion routine has been run
		if (distortedImage == null || undistortedImage == null
				|| xprime == null || yprime == null
				|| x == null || y == null) {
			
			System.err.println("Error in doImageUndistortion(): called before initialization of members.");
			return grid;
		}
		
		
		getLatticePoints(distortedImage);// There are TODOs here 
		
		
		int degree = 5; // polynomial's degree: 2,...,10
		calcPolynomial(degree, Xd);// There are TODOs here
		
		
		
		computeMatrixA(degree, numCorresp, numCoeff);// There are TODOs here
		
		
		computeDistortionCoeff(A, XuVector, YuVector);// There are TODOs here
		
		
		grid = computeDistortedGrid(distortedImage, grid, degree);// There are TODOs here
		
		return grid;
	}
	
	
	
	/** 1. Number of lattice points (this only works for symmetric images):
	 *  nx, ny feature points: usually provided by tracking point
	 *  correspondences in the phantom during the calibration step.
	 *  Here, we use the distorted and undistorted coordinates generated
	 *  in the course of the distortion simulation.
	 */ 
	public void getLatticePoints (Grid2D distortedImage){
		
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		// step size
		// calculate the step size of the lattice points: fx and fy 
		fx = imageWidth/nx; //TODO
		fy = imageHeight/ny; //TODO
		
		// fill the distorted and undistorted lattice points 
		// with data from the given correspondences
		// matrix = number of rows (y) x number of columns (x)
		Xu = new SimpleMatrix(ny,nx);
		Yu = new SimpleMatrix(ny,nx);
		Xd = new SimpleMatrix(ny,nx);
		Yd = new SimpleMatrix(ny,nx);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){

				// sample the distorted and undistorted grid points at the lattice points
				  Xu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx), j + int(fy)));//TODO: fill matrix Xu
				  Yu.setElementValue(i, j, fy);//TODO: fill matrix Yu
				  Xd.setElementValue(i, j, fx);//TODO: fill matrix Xd
				  Yd.setElementValue(i, j, fy)//TODO: fill matrix Yd
			}
		}
	}
	
	/** 2. Polynomial of degree d
	 * Polynomial of degree d -> (d-1): extrema (e.g., d=5: 4 extrema)
	 * d=0: constant (horizontal line with y-intercept a_0 -> f(x)=a_0)
	 * d=1: oblique line with y-intercept a_0 & slope a_1 -> f(x)=a_0 + a_1 x
	 * d=2: parabola
	 * d>=2: continuous non-linear curve
	 * ...
	 * d = 10 -> NumCoeff: 66 -> but only 64 lattice points are known (nx, ny = 8)
	 */
	
	public void calcPolynomial(int degree, SimpleMatrix Xd){
		
		// number of coefficients: numCoeff
		// (hint: this is NOT the total number of multiplications!)
		numCoeff = 0; //TODO
		
		// number of correspondences: numCorresp
		numCorresp =  0; //TODO
		
		// Printout of the used parameters
		System.out.println("Polynom of degree: " + degree);
		System.out.println("Number of Coefficients: " + numCoeff);
		System.out.println("Number of Correspondences: " + numCorresp);
		
	}
	
	/**
	 * 3. Create the matrix A
	 */
	
	public void computeMatrixA(int degree, int numCorresp, int numCoeff){
		
		A = new SimpleMatrix(numCorresp, numCoeff);
		if (numCorresp <= 0 && numCoeff <= 0)
			return;
		A.zeros();
		
		// Realign the grid matrix into a vector for easier access in the next step
		XuVector = new SimpleVector(numCorresp);
		YuVector = new SimpleVector(numCorresp);
		XdVector = new SimpleVector(numCorresp);
		YdVector = new SimpleVector(numCorresp);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){
				
				XuVector.setElementValue(i*ny + j, Xu.getElement(j, i));
				YuVector.setElementValue(i*ny + j, Yu.getElement(j, i));
				XdVector.setElementValue(i*ny + j, Xd.getElement(j, i));
				YdVector.setElementValue(i*ny + j, Yd.getElement(j, i));
			}
		}
		
		// Compute matrix A (coordinates from distorted image)
		for(int r = 0; r < numCorresp; r++){
			
			int cc = 0;
			
			for(int k = 0; k <= degree; k++){
				for(int l = 0; l <= (degree-k); l++){
					
					// TODO: fill matrix A
					cc++;
					
				}
			}
		}
	}
	
	public void computeDistortionCoeff(SimpleMatrix A, SimpleVector XuVector, SimpleVector YuVector){
		
		// Compute the pseudo-inverse of A with the help of the SVD (class: DecompositionSVD)
		svd = null; // TODO
	    A_pseudoinverse = null; // TODO
	  
		// Compute the distortion coefficients (solve for known corresponding undistorted points)
		u_vec = null;// TODO
		v_vec = null;// TODO
	}
	
	/**
	 * 4. Compute the distorted grid points (xDist, yDist) which are used to sample the
	 * distorted image to get the undistorted image
	 * (xprime,yprime) is the position in the undistorted image
	 * (xDist,yDist) is the position in the distorted (observed) X-ray image.
	 */
	public Grid2D computeDistortedGrid(Grid2D distortedImage, Grid2D grid_out, int degree){
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		xDist = new Grid2D(imageWidth,imageHeight);  
		yDist = new Grid2D(imageWidth,imageHeight); 
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float val1, val2; //variables Val1 and Val2 are used for intermediate computation of xDist and yDist respectively
				
				int cc = 0;
				
				for(int k = 0; k <= degree; k++){
					for(int l = 0; l <= degree - k; l++){
						
						val1 = 0;// TODO
						val2 = 0;// TODO
						
						// TODO: fill xDist
						// TODO: fill yDist
						
						cc++;
					}
				}
			}
		}
		
		float val; // variable for intermediate computations of undistorted image
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				// hint: consider the fact that the coordinate origin is in the center of the image
				val = 0;//TODO
				//TODO: fill grid_out
			}
		}
		
		return grid_out;
		
	}
	
	
	
	/**
	 * 
	 * end of the exercise
	 */	

	
	/**
	 * standard constructor
	 */
	public ExerciseGeoU(){
		
		this(0);
	}
		
	/**
	 * parameterized constructor for the ExerciseDPI object
	 * @param caseNo: select one of three images to test your undistortion method
	 */
	public ExerciseGeoU(int caseNo){
		
		switch (caseNo) {
		case 0:
			filename = "frame32.jpg";
			break;
		case 1:
			filename = "undistorted.jpg";
			break;
		case 2:
			filename = "frame90.jpg";
			break;
		default:
			filename = "frame32.jpg";
			break;
		}
		
		String imageDataLoc = System.getProperty("user.dir") + "/data/" + "/mipda/";
	
		originalImage = ImageUtil.wrapImagePlus(IJ.openImage(imageDataLoc + filename)).getSubGrid(0);
	}
	
	public void init(float a, float b, float d) {
		
		// Normalize intensity values to [0,1]
		float max = NumericPointwiseOperators.max(originalImage);
		float min = NumericPointwiseOperators.min(originalImage);
		
		for(int i = 0; i < originalImage.getWidth(); i++){
			for(int j = 0; j < originalImage.getHeight(); j++){
				
				float scaledValue = (originalImage.getAtIndex(i, j) - min) / (max-min);
				originalImage.setAtIndex(i, j, scaledValue);
			}
		}
		
		undistortedImage = new Grid2D(originalImage.getWidth(),originalImage.getHeight()); // initialization with zeros
		
		distortedImage = generateDistortedImage(originalImage,a,b,d);	
	}
	
	/**
	 * method to generate a distorted image
	 * An artificial distortion field is generated. With this field, 
	 * a distorted image is generated from the original image.
	 * Remark: coordinates of the latest distortion simulated are saved in class member variables
	 * @param inputImage: undistorted image on which distortion is simulated
	 * @param a: elliptic extent of the distortion in x-direction
	 * @param b: elliptic extent of the distortion in y-direction
	 * @param d: strength of the distortion
	 * @return: distorted image
	 */
    
	public Grid2D generateDistortedImage(Grid2D inputImage, float a, float b, float d){

		Grid2D grid = new Grid2D(inputImage);
		int imageWidth = grid.getWidth();
		int imageHeight = grid.getHeight();
		
		// generate grids to sample coordinates X and Y of the original image
		Grid2D X = new Grid2D(imageWidth,imageHeight); // x-coordinates with respect to origin in image center, spacing = 1 [unit]
		Grid2D Y = new Grid2D(imageWidth,imageHeight); // y-coordinates with respect to origin in image center, spacing = 1 [unit]
		
		float halfWidth = imageWidth / 2.0f;
		float halfHeight = imageHeight / 2.0f;
		
		for(int i = 0; i < X.getWidth(); i++){
			for(int j = 0; j < X.getHeight(); j++){
				
				X.setAtIndex(i, j, i - halfWidth + 0.5f); // assign pixel centers in x-direction
				Y.setAtIndex(i, j, j - halfHeight + 0.5f); // assign pixel center in y-direction
			}
		}
		
		// create an artificial elliptical distortion field R (additive field)
		Grid2D R = new Grid2D(imageWidth,imageHeight);

		for(int i = 0; i < R.getWidth(); i++){
			for(int j = 0; j < R.getHeight(); j++){
				
				// distortion gets stronger with the distance from the image center
				float r = d * (float)(Math.sqrt(
						Math.pow(X.getAtIndex(i, j)/(a*halfWidth),2)
						+ Math.pow(Y.getAtIndex(i, j)/(b*halfHeight),2)));
				R.setAtIndex(i, j, r);
			}
		}
		
		// shifting the positive range to half positive/half negative range
		float maxR = NumericPointwiseOperators.max(R);
		NumericPointwiseOperators.subtractBy(R, maxR * 0.5f);

		// create the distorted image coordinates:
		// distorted image coordinates = undistorted image points + artificial distortion field

		// distorted image coordinates Xd, Yd
		Grid2D Xd = new Grid2D(X);
		Grid2D Yd = new Grid2D(Y);
		
		NumericPointwiseOperators.addBy(Xd, R);
		NumericPointwiseOperators.addBy(Yd, R);
		
		// create the distorted image:
		// re-sample the original input image at the distorted image points (Xd,Yd) 
		// to create artificial distortion
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float distortedValue = InterpolationOperators.interpolateLinear(
						inputImage,
						Xd.getAtIndex(i, j) + halfWidth - 0.5f, // remember: coordinate origin was set to image center
						Yd.getAtIndex(i, j) + halfHeight - 0.5f);
				grid.setAtIndex(i, j, distortedValue);
			}
		}

		xprime = X;
		yprime = Y;
		x = Xd;
		y = Yd;
		
		return grid;	
	}	
	
	//getters for members
	// variables which are checked (DO NOT CHANGE!)
	
	public static int get_caseNo() {
		return caseNo;
	}
	
	public Grid2D get_originalImage() {
		return originalImage;
	}
	
	public Grid2D get_distortedImage() {
		return distortedImage;
	}
	
	public Grid2D get_undistortedImage() {
		return undistortedImage;
	}
	
	public int get_nx() {
		return nx;
	}
	
	public int get_ny() {
		return ny;
	}
	
	public float get_fx() {
		return fx;
	}
	
	public float get_fy() {
		return fy;
	}
	
	public SimpleMatrix get_Xu() {
		return Xu;
	}
	
	public SimpleMatrix get_Yu() {
		return Yu;
	}
	
	public SimpleMatrix get_Xd() {
		return Xd;
	}
	
	public SimpleMatrix get_Yd() {
		return Yd;
	}
	
	public int get_numCoeff() {
		return numCoeff;
	}
	
	public int get_numCorresp() {
		return numCorresp;
	}
	
	public SimpleMatrix get_A() {
		return A;
	}
	
	public DecompositionSVD get_svd() {
		return svd;
	}
	
	public SimpleMatrix get_A_pseudoinverse() {
		return A_pseudoinverse;
	}
	
	public SimpleVector get_u_vec() {
		return u_vec;
	}
	
	public SimpleVector get_v_vec() {
		return v_vec;
	}
	
	public SimpleVector get_XuVector() {
		return XuVector;
	}
	
	public SimpleVector get_YuVector() {
		return YuVector;
	}
	
	public SimpleVector get_XdVector() {
		return XdVector;
	}
	
	public SimpleVector get_YdVector() {
		return YdVector;
	}
	
	public Grid2D get_xDist() {
		return xDist;
	}
	
	public Grid2D get_yDist() {
		return yDist;
	}
	
	public Grid2D get_xprime() {
		return xprime;
	}
	
	public Grid2D get_yprime() {
		return yprime;
	}
	
	public Grid2D get_x() {
		return x;
	}
	
	public Grid2D get_y() {
		return y;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-15 23:57:40.000
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-15 23:57:40.001
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-15 23:57:40.024
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package edu.stanford.rsl.tutorial.mipda;

import edu.stanford.rsl.conrad.data.numeric.Grid2D;
import edu.stanford.rsl.conrad.data.numeric.NumericPointwiseOperators;
import edu.stanford.rsl.conrad.utils.ImageUtil;
//import edu.stanford.rsl.conrad.utils.VisualizationUtil;
import ij.IJ;
import ij.ImageJ;
import edu.stanford.rsl.conrad.data.numeric.InterpolationOperators;
//import edu.stanford.rsl.conrad.data.numeric.NumericGridOperator;
import edu.stanford.rsl.conrad.numerics.SimpleMatrix;
import edu.stanford.rsl.conrad.numerics.SimpleOperators;
import edu.stanford.rsl.conrad.numerics.SimpleVector;
import edu.stanford.rsl.conrad.numerics.DecompositionSVD;

/**
 * Geometric Undistortion
 * Programming exercise 1 for module "Defect Pixel Interpolation"
 * of the course "Medical Image Processing for Diagnostic Applications (MIPDA)"
 * @author Frank Schebesch, Ashwini Jadhav, Anna Gebhard, Mena Abdelmalek
 *
 */

public class ExerciseGeoU {

	final static int caseNo = 1; // choose 0, 1, or 2 for different test images

	final static float a = 0.6f; // a: spread among x-direction
	final static float b = 0.3f; // b: spread among y-direction
	final static float d = 5.0f; // d: d/2 value of distortion field at level set for (X/a)^2+(Y/b)^2=1
	
	String filename; // do not edit, choose a number in the main method instead
	Grid2D originalImage; // do not edit, read from filename when instantiating the object
	Grid2D distortedImage; // do not edit, generated in the main method
	Grid2D undistortedImage; // do not edit, member variable for the output image
	
	// number of lattice points
	final int nx = 8;//TODO: define the number of lattice point: nx (Positive number and less than 20)
	final int ny = 8;//TODO: define the number of lattice point: ny (Positive number and less than 20)
	
	float fx;
	float fy;
	SimpleMatrix Xu; 
	SimpleMatrix Yu;
	SimpleMatrix Xd;
	SimpleMatrix Yd;
	int numCoeff; 
	int numCorresp; 
	SimpleMatrix A;
	DecompositionSVD svd;
	SimpleMatrix A_pseudoinverse;
	SimpleVector u_vec;
	SimpleVector v_vec;
	SimpleVector XuVector;
	SimpleVector YuVector;
	SimpleVector XdVector;
	SimpleVector YdVector;
	Grid2D xDist;  
	Grid2D yDist;
	Grid2D xprime; // x-coordinates of point correspondences in the undistorted image
	Grid2D yprime; // y-coordinates of point correspondences in the undistorted image
	Grid2D x; // x-coordinates of point correspondences in the distorted image
	Grid2D y; // y-coordinates of point correspondences in the distorted image
	
	
	/** 
	 * main method
	 * Here you can choose the image, and set the distortion parameters
	 */
	public static void main(String[] args) {
		
		new ImageJ();
		
		// generate distorted image
		ExerciseGeoU exObj = new ExerciseGeoU(caseNo);
		exObj.init(a,b,d);
		
		// TASK: go to the method doImageUndistortion(...) and complete it 
		exObj.undistortedImage = exObj.doImageUndistortion(exObj.distortedImage);
		
		exObj.originalImage.show("Original Image");
		exObj.distortedImage.show("Distorted Image");
		exObj.undistortedImage.show("Undistorted Image");
		
		Grid2D differenceImage = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.originalImage, exObj.undistortedImage);
		
		differenceImage.show("Difference Original vs. Undistorted");
		
		Grid2D distortedVSundistorted = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.undistortedImage, exObj.distortedImage);
		
		distortedVSundistorted.show("Difference Undistorted vs. Distorted");
	}
	
	public Grid2D doImageUndistortion(Grid2D distortedImage){
		
		Grid2D grid = new Grid2D(distortedImage);
		
		// check if image distortion routine has been run
		if (distortedImage == null || undistortedImage == null
				|| xprime == null || yprime == null
				|| x == null || y == null) {
			
			System.err.println("Error in doImageUndistortion(): called before initialization of members.");
			return grid;
		}
		
		
		getLatticePoints(distortedImage);// There are TODOs here 
		
		
		int degree = 5; // polynomial's degree: 2,...,10
		calcPolynomial(degree, Xd);// There are TODOs here
		
		
		
		computeMatrixA(degree, numCorresp, numCoeff);// There are TODOs here
		
		
		computeDistortionCoeff(A, XuVector, YuVector);// There are TODOs here
		
		
		grid = computeDistortedGrid(distortedImage, grid, degree);// There are TODOs here
		
		return grid;
	}
	
	
	
	/** 1. Number of lattice points (this only works for symmetric images):
	 *  nx, ny feature points: usually provided by tracking point
	 *  correspondences in the phantom during the calibration step.
	 *  Here, we use the distorted and undistorted coordinates generated
	 *  in the course of the distortion simulation.
	 */ 
	public void getLatticePoints (Grid2D distortedImage){
		
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		// step size
		// calculate the step size of the lattice points: fx and fy 
		fx = imageWidth/nx; //TODO
		fy = imageHeight/ny; //TODO
		
		// fill the distorted and undistorted lattice points 
		// with data from the given correspondences
		// matrix = number of rows (y) x number of columns (x)
		Xu = new SimpleMatrix(ny,nx);
		Yu = new SimpleMatrix(ny,nx);
		Xd = new SimpleMatrix(ny,nx);
		Yd = new SimpleMatrix(ny,nx);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){

				// sample the distorted and undistorted grid points at the lattice points
				  Xu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx), j + int(fy)));//TODO: fill matrix Xu
				  Yu.setElementValue(i, j, fy);//TODO: fill matrix Yu
				  Xd.setElementValue(i, j, fx);//TODO: fill matrix Xd
				  Yd.setElementValue(i, j, fy)//TODO: fill matrix Yd
			}
		}
	}
	
	/** 2. Polynomial of degree d
	 * Polynomial of degree d -> (d-1): extrema (e.g., d=5: 4 extrema)
	 * d=0: constant (horizontal line with y-intercept a_0 -> f(x)=a_0)
	 * d=1: oblique line with y-intercept a_0 & slope a_1 -> f(x)=a_0 + a_1 x
	 * d=2: parabola
	 * d>=2: continuous non-linear curve
	 * ...
	 * d = 10 -> NumCoeff: 66 -> but only 64 lattice points are known (nx, ny = 8)
	 */
	
	public void calcPolynomial(int degree, SimpleMatrix Xd){
		
		// number of coefficients: numCoeff
		// (hint: this is NOT the total number of multiplications!)
		numCoeff = 0; //TODO
		
		// number of correspondences: numCorresp
		numCorresp =  0; //TODO
		
		// Printout of the used parameters
		System.out.println("Polynom of degree: " + degree);
		System.out.println("Number of Coefficients: " + numCoeff);
		System.out.println("Number of Correspondences: " + numCorresp);
		
	}
	
	/**
	 * 3. Create the matrix A
	 */
	
	public void computeMatrixA(int degree, int numCorresp, int numCoeff){
		
		A = new SimpleMatrix(numCorresp, numCoeff);
		if (numCorresp <= 0 && numCoeff <= 0)
			return;
		A.zeros();
		
		// Realign the grid matrix into a vector for easier access in the next step
		XuVector = new SimpleVector(numCorresp);
		YuVector = new SimpleVector(numCorresp);
		XdVector = new SimpleVector(numCorresp);
		YdVector = new SimpleVector(numCorresp);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){
				
				XuVector.setElementValue(i*ny + j, Xu.getElement(j, i));
				YuVector.setElementValue(i*ny + j, Yu.getElement(j, i));
				XdVector.setElementValue(i*ny + j, Xd.getElement(j, i));
				YdVector.setElementValue(i*ny + j, Yd.getElement(j, i));
			}
		}
		
		// Compute matrix A (coordinates from distorted image)
		for(int r = 0; r < numCorresp; r++){
			
			int cc = 0;
			
			for(int k = 0; k <= degree; k++){
				for(int l = 0; l <= (degree-k); l++){
					
					// TODO: fill matrix A
					cc++;
					
				}
			}
		}
	}
	
	public void computeDistortionCoeff(SimpleMatrix A, SimpleVector XuVector, SimpleVector YuVector){
		
		// Compute the pseudo-inverse of A with the help of the SVD (class: DecompositionSVD)
		svd = null; // TODO
	    A_pseudoinverse = null; // TODO
	  
		// Compute the distortion coefficients (solve for known corresponding undistorted points)
		u_vec = null;// TODO
		v_vec = null;// TODO
	}
	
	/**
	 * 4. Compute the distorted grid points (xDist, yDist) which are used to sample the
	 * distorted image to get the undistorted image
	 * (xprime,yprime) is the position in the undistorted image
	 * (xDist,yDist) is the position in the distorted (observed) X-ray image.
	 */
	public Grid2D computeDistortedGrid(Grid2D distortedImage, Grid2D grid_out, int degree){
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		xDist = new Grid2D(imageWidth,imageHeight);  
		yDist = new Grid2D(imageWidth,imageHeight); 
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float val1, val2; //variables Val1 and Val2 are used for intermediate computation of xDist and yDist respectively
				
				int cc = 0;
				
				for(int k = 0; k <= degree; k++){
					for(int l = 0; l <= degree - k; l++){
						
						val1 = 0;// TODO
						val2 = 0;// TODO
						
						// TODO: fill xDist
						// TODO: fill yDist
						
						cc++;
					}
				}
			}
		}
		
		float val; // variable for intermediate computations of undistorted image
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				// hint: consider the fact that the coordinate origin is in the center of the image
				val = 0;//TODO
				//TODO: fill grid_out
			}
		}
		
		return grid_out;
		
	}
	
	
	
	/**
	 * 
	 * end of the exercise
	 */	

	
	/**
	 * standard constructor
	 */
	public ExerciseGeoU(){
		
		this(0);
	}
		
	/**
	 * parameterized constructor for the ExerciseDPI object
	 * @param caseNo: select one of three images to test your undistortion method
	 */
	public ExerciseGeoU(int caseNo){
		
		switch (caseNo) {
		case 0:
			filename = "frame32.jpg";
			break;
		case 1:
			filename = "undistorted.jpg";
			break;
		case 2:
			filename = "frame90.jpg";
			break;
		default:
			filename = "frame32.jpg";
			break;
		}
		
		String imageDataLoc = System.getProperty("user.dir") + "/data/" + "/mipda/";
	
		originalImage = ImageUtil.wrapImagePlus(IJ.openImage(imageDataLoc + filename)).getSubGrid(0);
	}
	
	public void init(float a, float b, float d) {
		
		// Normalize intensity values to [0,1]
		float max = NumericPointwiseOperators.max(originalImage);
		float min = NumericPointwiseOperators.min(originalImage);
		
		for(int i = 0; i < originalImage.getWidth(); i++){
			for(int j = 0; j < originalImage.getHeight(); j++){
				
				float scaledValue = (originalImage.getAtIndex(i, j) - min) / (max-min);
				originalImage.setAtIndex(i, j, scaledValue);
			}
		}
		
		undistortedImage = new Grid2D(originalImage.getWidth(),originalImage.getHeight()); // initialization with zeros
		
		distortedImage = generateDistortedImage(originalImage,a,b,d);	
	}
	
	/**
	 * method to generate a distorted image
	 * An artificial distortion field is generated. With this field, 
	 * a distorted image is generated from the original image.
	 * Remark: coordinates of the latest distortion simulated are saved in class member variables
	 * @param inputImage: undistorted image on which distortion is simulated
	 * @param a: elliptic extent of the distortion in x-direction
	 * @param b: elliptic extent of the distortion in y-direction
	 * @param d: strength of the distortion
	 * @return: distorted image
	 */
    
	public Grid2D generateDistortedImage(Grid2D inputImage, float a, float b, float d){

		Grid2D grid = new Grid2D(inputImage);
		int imageWidth = grid.getWidth();
		int imageHeight = grid.getHeight();
		
		// generate grids to sample coordinates X and Y of the original image
		Grid2D X = new Grid2D(imageWidth,imageHeight); // x-coordinates with respect to origin in image center, spacing = 1 [unit]
		Grid2D Y = new Grid2D(imageWidth,imageHeight); // y-coordinates with respect to origin in image center, spacing = 1 [unit]
		
		float halfWidth = imageWidth / 2.0f;
		float halfHeight = imageHeight / 2.0f;
		
		for(int i = 0; i < X.getWidth(); i++){
			for(int j = 0; j < X.getHeight(); j++){
				
				X.setAtIndex(i, j, i - halfWidth + 0.5f); // assign pixel centers in x-direction
				Y.setAtIndex(i, j, j - halfHeight + 0.5f); // assign pixel center in y-direction
			}
		}
		
		// create an artificial elliptical distortion field R (additive field)
		Grid2D R = new Grid2D(imageWidth,imageHeight);

		for(int i = 0; i < R.getWidth(); i++){
			for(int j = 0; j < R.getHeight(); j++){
				
				// distortion gets stronger with the distance from the image center
				float r = d * (float)(Math.sqrt(
						Math.pow(X.getAtIndex(i, j)/(a*halfWidth),2)
						+ Math.pow(Y.getAtIndex(i, j)/(b*halfHeight),2)));
				R.setAtIndex(i, j, r);
			}
		}
		
		// shifting the positive range to half positive/half negative range
		float maxR = NumericPointwiseOperators.max(R);
		NumericPointwiseOperators.subtractBy(R, maxR * 0.5f);

		// create the distorted image coordinates:
		// distorted image coordinates = undistorted image points + artificial distortion field

		// distorted image coordinates Xd, Yd
		Grid2D Xd = new Grid2D(X);
		Grid2D Yd = new Grid2D(Y);
		
		NumericPointwiseOperators.addBy(Xd, R);
		NumericPointwiseOperators.addBy(Yd, R);
		
		// create the distorted image:
		// re-sample the original input image at the distorted image points (Xd,Yd) 
		// to create artificial distortion
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float distortedValue = InterpolationOperators.interpolateLinear(
						inputImage,
						Xd.getAtIndex(i, j) + halfWidth - 0.5f, // remember: coordinate origin was set to image center
						Yd.getAtIndex(i, j) + halfHeight - 0.5f);
				grid.setAtIndex(i, j, distortedValue);
			}
		}

		xprime = X;
		yprime = Y;
		x = Xd;
		y = Yd;
		
		return grid;	
	}	
	
	//getters for members
	// variables which are checked (DO NOT CHANGE!)
	
	public static int get_caseNo() {
		return caseNo;
	}
	
	public Grid2D get_originalImage() {
		return originalImage;
	}
	
	public Grid2D get_distortedImage() {
		return distortedImage;
	}
	
	public Grid2D get_undistortedImage() {
		return undistortedImage;
	}
	
	public int get_nx() {
		return nx;
	}
	
	public int get_ny() {
		return ny;
	}
	
	public float get_fx() {
		return fx;
	}
	
	public float get_fy() {
		return fy;
	}
	
	public SimpleMatrix get_Xu() {
		return Xu;
	}
	
	public SimpleMatrix get_Yu() {
		return Yu;
	}
	
	public SimpleMatrix get_Xd() {
		return Xd;
	}
	
	public SimpleMatrix get_Yd() {
		return Yd;
	}
	
	public int get_numCoeff() {
		return numCoeff;
	}
	
	public int get_numCorresp() {
		return numCorresp;
	}
	
	public SimpleMatrix get_A() {
		return A;
	}
	
	public DecompositionSVD get_svd() {
		return svd;
	}
	
	public SimpleMatrix get_A_pseudoinverse() {
		return A_pseudoinverse;
	}
	
	public SimpleVector get_u_vec() {
		return u_vec;
	}
	
	public SimpleVector get_v_vec() {
		return v_vec;
	}
	
	public SimpleVector get_XuVector() {
		return XuVector;
	}
	
	public SimpleVector get_YuVector() {
		return YuVector;
	}
	
	public SimpleVector get_XdVector() {
		return XdVector;
	}
	
	public SimpleVector get_YdVector() {
		return YdVector;
	}
	
	public Grid2D get_xDist() {
		return xDist;
	}
	
	public Grid2D get_yDist() {
		return yDist;
	}
	
	public Grid2D get_xprime() {
		return xprime;
	}
	
	public Grid2D get_yprime() {
		return yprime;
	}
	
	public Grid2D get_x() {
		return x;
	}
	
	public Grid2D get_y() {
		return y;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-15 23:57:40.025
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-15 23:57:40.025
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-15 23:57:40.109
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package edu.stanford.rsl.tutorial.mipda;

import edu.stanford.rsl.conrad.data.numeric.Grid2D;
import edu.stanford.rsl.conrad.data.numeric.NumericPointwiseOperators;
import edu.stanford.rsl.conrad.utils.ImageUtil;
//import edu.stanford.rsl.conrad.utils.VisualizationUtil;
import ij.IJ;
import ij.ImageJ;
import edu.stanford.rsl.conrad.data.numeric.InterpolationOperators;
//import edu.stanford.rsl.conrad.data.numeric.NumericGridOperator;
import edu.stanford.rsl.conrad.numerics.SimpleMatrix;
import edu.stanford.rsl.conrad.numerics.SimpleOperators;
import edu.stanford.rsl.conrad.numerics.SimpleVector;
import edu.stanford.rsl.conrad.numerics.DecompositionSVD;

/**
 * Geometric Undistortion
 * Programming exercise 1 for module "Defect Pixel Interpolation"
 * of the course "Medical Image Processing for Diagnostic Applications (MIPDA)"
 * @author Frank Schebesch, Ashwini Jadhav, Anna Gebhard, Mena Abdelmalek
 *
 */

public class ExerciseGeoU {

	final static int caseNo = 1; // choose 0, 1, or 2 for different test images

	final static float a = 0.6f; // a: spread among x-direction
	final static float b = 0.3f; // b: spread among y-direction
	final static float d = 5.0f; // d: d/2 value of distortion field at level set for (X/a)^2+(Y/b)^2=1
	
	String filename; // do not edit, choose a number in the main method instead
	Grid2D originalImage; // do not edit, read from filename when instantiating the object
	Grid2D distortedImage; // do not edit, generated in the main method
	Grid2D undistortedImage; // do not edit, member variable for the output image
	
	// number of lattice points
	final int nx = 8;//TODO: define the number of lattice point: nx (Positive number and less than 20)
	final int ny = 8;//TODO: define the number of lattice point: ny (Positive number and less than 20)
	
	float fx;
	float fy;
	SimpleMatrix Xu; 
	SimpleMatrix Yu;
	SimpleMatrix Xd;
	SimpleMatrix Yd;
	int numCoeff; 
	int numCorresp; 
	SimpleMatrix A;
	DecompositionSVD svd;
	SimpleMatrix A_pseudoinverse;
	SimpleVector u_vec;
	SimpleVector v_vec;
	SimpleVector XuVector;
	SimpleVector YuVector;
	SimpleVector XdVector;
	SimpleVector YdVector;
	Grid2D xDist;  
	Grid2D yDist;
	Grid2D xprime; // x-coordinates of point correspondences in the undistorted image
	Grid2D yprime; // y-coordinates of point correspondences in the undistorted image
	Grid2D x; // x-coordinates of point correspondences in the distorted image
	Grid2D y; // y-coordinates of point correspondences in the distorted image
	
	
	/** 
	 * main method
	 * Here you can choose the image, and set the distortion parameters
	 */
	public static void main(String[] args) {
		
		new ImageJ();
		
		// generate distorted image
		ExerciseGeoU exObj = new ExerciseGeoU(caseNo);
		exObj.init(a,b,d);
		
		// TASK: go to the method doImageUndistortion(...) and complete it 
		exObj.undistortedImage = exObj.doImageUndistortion(exObj.distortedImage);
		
		exObj.originalImage.show("Original Image");
		exObj.distortedImage.show("Distorted Image");
		exObj.undistortedImage.show("Undistorted Image");
		
		Grid2D differenceImage = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.originalImage, exObj.undistortedImage);
		
		differenceImage.show("Difference Original vs. Undistorted");
		
		Grid2D distortedVSundistorted = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.undistortedImage, exObj.distortedImage);
		
		distortedVSundistorted.show("Difference Undistorted vs. Distorted");
	}
	
	public Grid2D doImageUndistortion(Grid2D distortedImage){
		
		Grid2D grid = new Grid2D(distortedImage);
		
		// check if image distortion routine has been run
		if (distortedImage == null || undistortedImage == null
				|| xprime == null || yprime == null
				|| x == null || y == null) {
			
			System.err.println("Error in doImageUndistortion(): called before initialization of members.");
			return grid;
		}
		
		
		getLatticePoints(distortedImage);// There are TODOs here 
		
		
		int degree = 5; // polynomial's degree: 2,...,10
		calcPolynomial(degree, Xd);// There are TODOs here
		
		
		
		computeMatrixA(degree, numCorresp, numCoeff);// There are TODOs here
		
		
		computeDistortionCoeff(A, XuVector, YuVector);// There are TODOs here
		
		
		grid = computeDistortedGrid(distortedImage, grid, degree);// There are TODOs here
		
		return grid;
	}
	
	
	
	/** 1. Number of lattice points (this only works for symmetric images):
	 *  nx, ny feature points: usually provided by tracking point
	 *  correspondences in the phantom during the calibration step.
	 *  Here, we use the distorted and undistorted coordinates generated
	 *  in the course of the distortion simulation.
	 */ 
	public void getLatticePoints (Grid2D distortedImage){
		
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		// step size
		// calculate the step size of the lattice points: fx and fy 
		fx = imageWidth/nx; //TODO
		fy = imageHeight/ny; //TODO
		
		// fill the distorted and undistorted lattice points 
		// with data from the given correspondences
		// matrix = number of rows (y) x number of columns (x)
		Xu = new SimpleMatrix(ny,nx);
		Yu = new SimpleMatrix(ny,nx);
		Xd = new SimpleMatrix(ny,nx);
		Yd = new SimpleMatrix(ny,nx);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){

				// sample the distorted and undistorted grid points at the lattice points
				  Xu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx), j + int(fy)));//TODO: fill matrix Xu
				  Yu.setElementValue(i, j, fy);//TODO: fill matrix Yu
				  Xd.setElementValue(i, j, fx);//TODO: fill matrix Xd
				  Yd.setElementValue(i, j, fy)//TODO: fill matrix Yd
			}
		}
	}
	
	/** 2. Polynomial of degree d
	 * Polynomial of degree d -> (d-1): extrema (e.g., d=5: 4 extrema)
	 * d=0: constant (horizontal line with y-intercept a_0 -> f(x)=a_0)
	 * d=1: oblique line with y-intercept a_0 & slope a_1 -> f(x)=a_0 + a_1 x
	 * d=2: parabola
	 * d>=2: continuous non-linear curve
	 * ...
	 * d = 10 -> NumCoeff: 66 -> but only 64 lattice points are known (nx, ny = 8)
	 */
	
	public void calcPolynomial(int degree, SimpleMatrix Xd){
		
		// number of coefficients: numCoeff
		// (hint: this is NOT the total number of multiplications!)
		numCoeff = 0; //TODO
		
		// number of correspondences: numCorresp
		numCorresp =  0; //TODO
		
		// Printout of the used parameters
		System.out.println("Polynom of degree: " + degree);
		System.out.println("Number of Coefficients: " + numCoeff);
		System.out.println("Number of Correspondences: " + numCorresp);
		
	}
	
	/**
	 * 3. Create the matrix A
	 */
	
	public void computeMatrixA(int degree, int numCorresp, int numCoeff){
		
		A = new SimpleMatrix(numCorresp, numCoeff);
		if (numCorresp <= 0 && numCoeff <= 0)
			return;
		A.zeros();
		
		// Realign the grid matrix into a vector for easier access in the next step
		XuVector = new SimpleVector(numCorresp);
		YuVector = new SimpleVector(numCorresp);
		XdVector = new SimpleVector(numCorresp);
		YdVector = new SimpleVector(numCorresp);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){
				
				XuVector.setElementValue(i*ny + j, Xu.getElement(j, i));
				YuVector.setElementValue(i*ny + j, Yu.getElement(j, i));
				XdVector.setElementValue(i*ny + j, Xd.getElement(j, i));
				YdVector.setElementValue(i*ny + j, Yd.getElement(j, i));
			}
		}
		
		// Compute matrix A (coordinates from distorted image)
		for(int r = 0; r < numCorresp; r++){
			
			int cc = 0;
			
			for(int k = 0; k <= degree; k++){
				for(int l = 0; l <= (degree-k); l++){
					
					// TODO: fill matrix A
					cc++;
					
				}
			}
		}
	}
	
	public void computeDistortionCoeff(SimpleMatrix A, SimpleVector XuVector, SimpleVector YuVector){
		
		// Compute the pseudo-inverse of A with the help of the SVD (class: DecompositionSVD)
		svd = null; // TODO
	    A_pseudoinverse = null; // TODO
	  
		// Compute the distortion coefficients (solve for known corresponding undistorted points)
		u_vec = null;// TODO
		v_vec = null;// TODO
	}
	
	/**
	 * 4. Compute the distorted grid points (xDist, yDist) which are used to sample the
	 * distorted image to get the undistorted image
	 * (xprime,yprime) is the position in the undistorted image
	 * (xDist,yDist) is the position in the distorted (observed) X-ray image.
	 */
	public Grid2D computeDistortedGrid(Grid2D distortedImage, Grid2D grid_out, int degree){
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		xDist = new Grid2D(imageWidth,imageHeight);  
		yDist = new Grid2D(imageWidth,imageHeight); 
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float val1, val2; //variables Val1 and Val2 are used for intermediate computation of xDist and yDist respectively
				
				int cc = 0;
				
				for(int k = 0; k <= degree; k++){
					for(int l = 0; l <= degree - k; l++){
						
						val1 = 0;// TODO
						val2 = 0;// TODO
						
						// TODO: fill xDist
						// TODO: fill yDist
						
						cc++;
					}
				}
			}
		}
		
		float val; // variable for intermediate computations of undistorted image
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				// hint: consider the fact that the coordinate origin is in the center of the image
				val = 0;//TODO
				//TODO: fill grid_out
			}
		}
		
		return grid_out;
		
	}
	
	
	
	/**
	 * 
	 * end of the exercise
	 */	

	
	/**
	 * standard constructor
	 */
	public ExerciseGeoU(){
		
		this(0);
	}
		
	/**
	 * parameterized constructor for the ExerciseDPI object
	 * @param caseNo: select one of three images to test your undistortion method
	 */
	public ExerciseGeoU(int caseNo){
		
		switch (caseNo) {
		case 0:
			filename = "frame32.jpg";
			break;
		case 1:
			filename = "undistorted.jpg";
			break;
		case 2:
			filename = "frame90.jpg";
			break;
		default:
			filename = "frame32.jpg";
			break;
		}
		
		String imageDataLoc = System.getProperty("user.dir") + "/data/" + "/mipda/";
	
		originalImage = ImageUtil.wrapImagePlus(IJ.openImage(imageDataLoc + filename)).getSubGrid(0);
	}
	
	public void init(float a, float b, float d) {
		
		// Normalize intensity values to [0,1]
		float max = NumericPointwiseOperators.max(originalImage);
		float min = NumericPointwiseOperators.min(originalImage);
		
		for(int i = 0; i < originalImage.getWidth(); i++){
			for(int j = 0; j < originalImage.getHeight(); j++){
				
				float scaledValue = (originalImage.getAtIndex(i, j) - min) / (max-min);
				originalImage.setAtIndex(i, j, scaledValue);
			}
		}
		
		undistortedImage = new Grid2D(originalImage.getWidth(),originalImage.getHeight()); // initialization with zeros
		
		distortedImage = generateDistortedImage(originalImage,a,b,d);	
	}
	
	/**
	 * method to generate a distorted image
	 * An artificial distortion field is generated. With this field, 
	 * a distorted image is generated from the original image.
	 * Remark: coordinates of the latest distortion simulated are saved in class member variables
	 * @param inputImage: undistorted image on which distortion is simulated
	 * @param a: elliptic extent of the distortion in x-direction
	 * @param b: elliptic extent of the distortion in y-direction
	 * @param d: strength of the distortion
	 * @return: distorted image
	 */
    
	public Grid2D generateDistortedImage(Grid2D inputImage, float a, float b, float d){

		Grid2D grid = new Grid2D(inputImage);
		int imageWidth = grid.getWidth();
		int imageHeight = grid.getHeight();
		
		// generate grids to sample coordinates X and Y of the original image
		Grid2D X = new Grid2D(imageWidth,imageHeight); // x-coordinates with respect to origin in image center, spacing = 1 [unit]
		Grid2D Y = new Grid2D(imageWidth,imageHeight); // y-coordinates with respect to origin in image center, spacing = 1 [unit]
		
		float halfWidth = imageWidth / 2.0f;
		float halfHeight = imageHeight / 2.0f;
		
		for(int i = 0; i < X.getWidth(); i++){
			for(int j = 0; j < X.getHeight(); j++){
				
				X.setAtIndex(i, j, i - halfWidth + 0.5f); // assign pixel centers in x-direction
				Y.setAtIndex(i, j, j - halfHeight + 0.5f); // assign pixel center in y-direction
			}
		}
		
		// create an artificial elliptical distortion field R (additive field)
		Grid2D R = new Grid2D(imageWidth,imageHeight);

		for(int i = 0; i < R.getWidth(); i++){
			for(int j = 0; j < R.getHeight(); j++){
				
				// distortion gets stronger with the distance from the image center
				float r = d * (float)(Math.sqrt(
						Math.pow(X.getAtIndex(i, j)/(a*halfWidth),2)
						+ Math.pow(Y.getAtIndex(i, j)/(b*halfHeight),2)));
				R.setAtIndex(i, j, r);
			}
		}
		
		// shifting the positive range to half positive/half negative range
		float maxR = NumericPointwiseOperators.max(R);
		NumericPointwiseOperators.subtractBy(R, maxR * 0.5f);

		// create the distorted image coordinates:
		// distorted image coordinates = undistorted image points + artificial distortion field

		// distorted image coordinates Xd, Yd
		Grid2D Xd = new Grid2D(X);
		Grid2D Yd = new Grid2D(Y);
		
		NumericPointwiseOperators.addBy(Xd, R);
		NumericPointwiseOperators.addBy(Yd, R);
		
		// create the distorted image:
		// re-sample the original input image at the distorted image points (Xd,Yd) 
		// to create artificial distortion
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float distortedValue = InterpolationOperators.interpolateLinear(
						inputImage,
						Xd.getAtIndex(i, j) + halfWidth - 0.5f, // remember: coordinate origin was set to image center
						Yd.getAtIndex(i, j) + halfHeight - 0.5f);
				grid.setAtIndex(i, j, distortedValue);
			}
		}

		xprime = X;
		yprime = Y;
		x = Xd;
		y = Yd;
		
		return grid;	
	}	
	
	//getters for members
	// variables which are checked (DO NOT CHANGE!)
	
	public static int get_caseNo() {
		return caseNo;
	}
	
	public Grid2D get_originalImage() {
		return originalImage;
	}
	
	public Grid2D get_distortedImage() {
		return distortedImage;
	}
	
	public Grid2D get_undistortedImage() {
		return undistortedImage;
	}
	
	public int get_nx() {
		return nx;
	}
	
	public int get_ny() {
		return ny;
	}
	
	public float get_fx() {
		return fx;
	}
	
	public float get_fy() {
		return fy;
	}
	
	public SimpleMatrix get_Xu() {
		return Xu;
	}
	
	public SimpleMatrix get_Yu() {
		return Yu;
	}
	
	public SimpleMatrix get_Xd() {
		return Xd;
	}
	
	public SimpleMatrix get_Yd() {
		return Yd;
	}
	
	public int get_numCoeff() {
		return numCoeff;
	}
	
	public int get_numCorresp() {
		return numCorresp;
	}
	
	public SimpleMatrix get_A() {
		return A;
	}
	
	public DecompositionSVD get_svd() {
		return svd;
	}
	
	public SimpleMatrix get_A_pseudoinverse() {
		return A_pseudoinverse;
	}
	
	public SimpleVector get_u_vec() {
		return u_vec;
	}
	
	public SimpleVector get_v_vec() {
		return v_vec;
	}
	
	public SimpleVector get_XuVector() {
		return XuVector;
	}
	
	public SimpleVector get_YuVector() {
		return YuVector;
	}
	
	public SimpleVector get_XdVector() {
		return XdVector;
	}
	
	public SimpleVector get_YdVector() {
		return YdVector;
	}
	
	public Grid2D get_xDist() {
		return xDist;
	}
	
	public Grid2D get_yDist() {
		return yDist;
	}
	
	public Grid2D get_xprime() {
		return xprime;
	}
	
	public Grid2D get_yprime() {
		return yprime;
	}
	
	public Grid2D get_x() {
		return x;
	}
	
	public Grid2D get_y() {
		return y;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-15 23:57:40.110
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-15 23:57:40.111
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-15 23:57:41.552
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package edu.stanford.rsl.tutorial.mipda;

import edu.stanford.rsl.conrad.data.numeric.Grid2D;
import edu.stanford.rsl.conrad.data.numeric.NumericPointwiseOperators;
import edu.stanford.rsl.conrad.utils.ImageUtil;
//import edu.stanford.rsl.conrad.utils.VisualizationUtil;
import ij.IJ;
import ij.ImageJ;
import edu.stanford.rsl.conrad.data.numeric.InterpolationOperators;
//import edu.stanford.rsl.conrad.data.numeric.NumericGridOperator;
import edu.stanford.rsl.conrad.numerics.SimpleMatrix;
import edu.stanford.rsl.conrad.numerics.SimpleOperators;
import edu.stanford.rsl.conrad.numerics.SimpleVector;
import edu.stanford.rsl.conrad.numerics.DecompositionSVD;

/**
 * Geometric Undistortion
 * Programming exercise 1 for module "Defect Pixel Interpolation"
 * of the course "Medical Image Processing for Diagnostic Applications (MIPDA)"
 * @author Frank Schebesch, Ashwini Jadhav, Anna Gebhard, Mena Abdelmalek
 *
 */

public class ExerciseGeoU {

	final static int caseNo = 1; // choose 0, 1, or 2 for different test images

	final static float a = 0.6f; // a: spread among x-direction
	final static float b = 0.3f; // b: spread among y-direction
	final static float d = 5.0f; // d: d/2 value of distortion field at level set for (X/a)^2+(Y/b)^2=1
	
	String filename; // do not edit, choose a number in the main method instead
	Grid2D originalImage; // do not edit, read from filename when instantiating the object
	Grid2D distortedImage; // do not edit, generated in the main method
	Grid2D undistortedImage; // do not edit, member variable for the output image
	
	// number of lattice points
	final int nx = 8;//TODO: define the number of lattice point: nx (Positive number and less than 20)
	final int ny = 8;//TODO: define the number of lattice point: ny (Positive number and less than 20)
	
	float fx;
	float fy;
	SimpleMatrix Xu; 
	SimpleMatrix Yu;
	SimpleMatrix Xd;
	SimpleMatrix Yd;
	int numCoeff; 
	int numCorresp; 
	SimpleMatrix A;
	DecompositionSVD svd;
	SimpleMatrix A_pseudoinverse;
	SimpleVector u_vec;
	SimpleVector v_vec;
	SimpleVector XuVector;
	SimpleVector YuVector;
	SimpleVector XdVector;
	SimpleVector YdVector;
	Grid2D xDist;  
	Grid2D yDist;
	Grid2D xprime; // x-coordinates of point correspondences in the undistorted image
	Grid2D yprime; // y-coordinates of point correspondences in the undistorted image
	Grid2D x; // x-coordinates of point correspondences in the distorted image
	Grid2D y; // y-coordinates of point correspondences in the distorted image
	
	
	/** 
	 * main method
	 * Here you can choose the image, and set the distortion parameters
	 */
	public static void main(String[] args) {
		
		new ImageJ();
		
		// generate distorted image
		ExerciseGeoU exObj = new ExerciseGeoU(caseNo);
		exObj.init(a,b,d);
		
		// TASK: go to the method doImageUndistortion(...) and complete it 
		exObj.undistortedImage = exObj.doImageUndistortion(exObj.distortedImage);
		
		exObj.originalImage.show("Original Image");
		exObj.distortedImage.show("Distorted Image");
		exObj.undistortedImage.show("Undistorted Image");
		
		Grid2D differenceImage = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.originalImage, exObj.undistortedImage);
		
		differenceImage.show("Difference Original vs. Undistorted");
		
		Grid2D distortedVSundistorted = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.undistortedImage, exObj.distortedImage);
		
		distortedVSundistorted.show("Difference Undistorted vs. Distorted");
	}
	
	public Grid2D doImageUndistortion(Grid2D distortedImage){
		
		Grid2D grid = new Grid2D(distortedImage);
		
		// check if image distortion routine has been run
		if (distortedImage == null || undistortedImage == null
				|| xprime == null || yprime == null
				|| x == null || y == null) {
			
			System.err.println("Error in doImageUndistortion(): called before initialization of members.");
			return grid;
		}
		
		
		getLatticePoints(distortedImage);// There are TODOs here 
		
		
		int degree = 5; // polynomial's degree: 2,...,10
		calcPolynomial(degree, Xd);// There are TODOs here
		
		
		
		computeMatrixA(degree, numCorresp, numCoeff);// There are TODOs here
		
		
		computeDistortionCoeff(A, XuVector, YuVector);// There are TODOs here
		
		
		grid = computeDistortedGrid(distortedImage, grid, degree);// There are TODOs here
		
		return grid;
	}
	
	
	
	/** 1. Number of lattice points (this only works for symmetric images):
	 *  nx, ny feature points: usually provided by tracking point
	 *  correspondences in the phantom during the calibration step.
	 *  Here, we use the distorted and undistorted coordinates generated
	 *  in the course of the distortion simulation.
	 */ 
	public void getLatticePoints (Grid2D distortedImage){
		
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		// step size
		// calculate the step size of the lattice points: fx and fy 
		fx = imageWidth/nx; //TODO
		fy = imageHeight/ny; //TODO
		
		// fill the distorted and undistorted lattice points 
		// with data from the given correspondences
		// matrix = number of rows (y) x number of columns (x)
		Xu = new SimpleMatrix(ny,nx);
		Yu = new SimpleMatrix(ny,nx);
		Xd = new SimpleMatrix(ny,nx);
		Yd = new SimpleMatrix(ny,nx);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){

				// sample the distorted and undistorted grid points at the lattice points
				  Xu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx), j + int(fy)));//TODO: fill matrix Xu
				  Yu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx), j + int(fy));//TODO: fill matrix Yu
				  Xd.setElementValue(i, j, fx);//TODO: fill matrix Xd
				  Yd.setElementValue(i, j, fy)//TODO: fill matrix Yd
			}
		}
	}
	
	/** 2. Polynomial of degree d
	 * Polynomial of degree d -> (d-1): extrema (e.g., d=5: 4 extrema)
	 * d=0: constant (horizontal line with y-intercept a_0 -> f(x)=a_0)
	 * d=1: oblique line with y-intercept a_0 & slope a_1 -> f(x)=a_0 + a_1 x
	 * d=2: parabola
	 * d>=2: continuous non-linear curve
	 * ...
	 * d = 10 -> NumCoeff: 66 -> but only 64 lattice points are known (nx, ny = 8)
	 */
	
	public void calcPolynomial(int degree, SimpleMatrix Xd){
		
		// number of coefficients: numCoeff
		// (hint: this is NOT the total number of multiplications!)
		numCoeff = 0; //TODO
		
		// number of correspondences: numCorresp
		numCorresp =  0; //TODO
		
		// Printout of the used parameters
		System.out.println("Polynom of degree: " + degree);
		System.out.println("Number of Coefficients: " + numCoeff);
		System.out.println("Number of Correspondences: " + numCorresp);
		
	}
	
	/**
	 * 3. Create the matrix A
	 */
	
	public void computeMatrixA(int degree, int numCorresp, int numCoeff){
		
		A = new SimpleMatrix(numCorresp, numCoeff);
		if (numCorresp <= 0 && numCoeff <= 0)
			return;
		A.zeros();
		
		// Realign the grid matrix into a vector for easier access in the next step
		XuVector = new SimpleVector(numCorresp);
		YuVector = new SimpleVector(numCorresp);
		XdVector = new SimpleVector(numCorresp);
		YdVector = new SimpleVector(numCorresp);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){
				
				XuVector.setElementValue(i*ny + j, Xu.getElement(j, i));
				YuVector.setElementValue(i*ny + j, Yu.getElement(j, i));
				XdVector.setElementValue(i*ny + j, Xd.getElement(j, i));
				YdVector.setElementValue(i*ny + j, Yd.getElement(j, i));
			}
		}
		
		// Compute matrix A (coordinates from distorted image)
		for(int r = 0; r < numCorresp; r++){
			
			int cc = 0;
			
			for(int k = 0; k <= degree; k++){
				for(int l = 0; l <= (degree-k); l++){
					
					// TODO: fill matrix A
					cc++;
					
				}
			}
		}
	}
	
	public void computeDistortionCoeff(SimpleMatrix A, SimpleVector XuVector, SimpleVector YuVector){
		
		// Compute the pseudo-inverse of A with the help of the SVD (class: DecompositionSVD)
		svd = null; // TODO
	    A_pseudoinverse = null; // TODO
	  
		// Compute the distortion coefficients (solve for known corresponding undistorted points)
		u_vec = null;// TODO
		v_vec = null;// TODO
	}
	
	/**
	 * 4. Compute the distorted grid points (xDist, yDist) which are used to sample the
	 * distorted image to get the undistorted image
	 * (xprime,yprime) is the position in the undistorted image
	 * (xDist,yDist) is the position in the distorted (observed) X-ray image.
	 */
	public Grid2D computeDistortedGrid(Grid2D distortedImage, Grid2D grid_out, int degree){
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		xDist = new Grid2D(imageWidth,imageHeight);  
		yDist = new Grid2D(imageWidth,imageHeight); 
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float val1, val2; //variables Val1 and Val2 are used for intermediate computation of xDist and yDist respectively
				
				int cc = 0;
				
				for(int k = 0; k <= degree; k++){
					for(int l = 0; l <= degree - k; l++){
						
						val1 = 0;// TODO
						val2 = 0;// TODO
						
						// TODO: fill xDist
						// TODO: fill yDist
						
						cc++;
					}
				}
			}
		}
		
		float val; // variable for intermediate computations of undistorted image
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				// hint: consider the fact that the coordinate origin is in the center of the image
				val = 0;//TODO
				//TODO: fill grid_out
			}
		}
		
		return grid_out;
		
	}
	
	
	
	/**
	 * 
	 * end of the exercise
	 */	

	
	/**
	 * standard constructor
	 */
	public ExerciseGeoU(){
		
		this(0);
	}
		
	/**
	 * parameterized constructor for the ExerciseDPI object
	 * @param caseNo: select one of three images to test your undistortion method
	 */
	public ExerciseGeoU(int caseNo){
		
		switch (caseNo) {
		case 0:
			filename = "frame32.jpg";
			break;
		case 1:
			filename = "undistorted.jpg";
			break;
		case 2:
			filename = "frame90.jpg";
			break;
		default:
			filename = "frame32.jpg";
			break;
		}
		
		String imageDataLoc = System.getProperty("user.dir") + "/data/" + "/mipda/";
	
		originalImage = ImageUtil.wrapImagePlus(IJ.openImage(imageDataLoc + filename)).getSubGrid(0);
	}
	
	public void init(float a, float b, float d) {
		
		// Normalize intensity values to [0,1]
		float max = NumericPointwiseOperators.max(originalImage);
		float min = NumericPointwiseOperators.min(originalImage);
		
		for(int i = 0; i < originalImage.getWidth(); i++){
			for(int j = 0; j < originalImage.getHeight(); j++){
				
				float scaledValue = (originalImage.getAtIndex(i, j) - min) / (max-min);
				originalImage.setAtIndex(i, j, scaledValue);
			}
		}
		
		undistortedImage = new Grid2D(originalImage.getWidth(),originalImage.getHeight()); // initialization with zeros
		
		distortedImage = generateDistortedImage(originalImage,a,b,d);	
	}
	
	/**
	 * method to generate a distorted image
	 * An artificial distortion field is generated. With this field, 
	 * a distorted image is generated from the original image.
	 * Remark: coordinates of the latest distortion simulated are saved in class member variables
	 * @param inputImage: undistorted image on which distortion is simulated
	 * @param a: elliptic extent of the distortion in x-direction
	 * @param b: elliptic extent of the distortion in y-direction
	 * @param d: strength of the distortion
	 * @return: distorted image
	 */
    
	public Grid2D generateDistortedImage(Grid2D inputImage, float a, float b, float d){

		Grid2D grid = new Grid2D(inputImage);
		int imageWidth = grid.getWidth();
		int imageHeight = grid.getHeight();
		
		// generate grids to sample coordinates X and Y of the original image
		Grid2D X = new Grid2D(imageWidth,imageHeight); // x-coordinates with respect to origin in image center, spacing = 1 [unit]
		Grid2D Y = new Grid2D(imageWidth,imageHeight); // y-coordinates with respect to origin in image center, spacing = 1 [unit]
		
		float halfWidth = imageWidth / 2.0f;
		float halfHeight = imageHeight / 2.0f;
		
		for(int i = 0; i < X.getWidth(); i++){
			for(int j = 0; j < X.getHeight(); j++){
				
				X.setAtIndex(i, j, i - halfWidth + 0.5f); // assign pixel centers in x-direction
				Y.setAtIndex(i, j, j - halfHeight + 0.5f); // assign pixel center in y-direction
			}
		}
		
		// create an artificial elliptical distortion field R (additive field)
		Grid2D R = new Grid2D(imageWidth,imageHeight);

		for(int i = 0; i < R.getWidth(); i++){
			for(int j = 0; j < R.getHeight(); j++){
				
				// distortion gets stronger with the distance from the image center
				float r = d * (float)(Math.sqrt(
						Math.pow(X.getAtIndex(i, j)/(a*halfWidth),2)
						+ Math.pow(Y.getAtIndex(i, j)/(b*halfHeight),2)));
				R.setAtIndex(i, j, r);
			}
		}
		
		// shifting the positive range to half positive/half negative range
		float maxR = NumericPointwiseOperators.max(R);
		NumericPointwiseOperators.subtractBy(R, maxR * 0.5f);

		// create the distorted image coordinates:
		// distorted image coordinates = undistorted image points + artificial distortion field

		// distorted image coordinates Xd, Yd
		Grid2D Xd = new Grid2D(X);
		Grid2D Yd = new Grid2D(Y);
		
		NumericPointwiseOperators.addBy(Xd, R);
		NumericPointwiseOperators.addBy(Yd, R);
		
		// create the distorted image:
		// re-sample the original input image at the distorted image points (Xd,Yd) 
		// to create artificial distortion
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float distortedValue = InterpolationOperators.interpolateLinear(
						inputImage,
						Xd.getAtIndex(i, j) + halfWidth - 0.5f, // remember: coordinate origin was set to image center
						Yd.getAtIndex(i, j) + halfHeight - 0.5f);
				grid.setAtIndex(i, j, distortedValue);
			}
		}

		xprime = X;
		yprime = Y;
		x = Xd;
		y = Yd;
		
		return grid;	
	}	
	
	//getters for members
	// variables which are checked (DO NOT CHANGE!)
	
	public static int get_caseNo() {
		return caseNo;
	}
	
	public Grid2D get_originalImage() {
		return originalImage;
	}
	
	public Grid2D get_distortedImage() {
		return distortedImage;
	}
	
	public Grid2D get_undistortedImage() {
		return undistortedImage;
	}
	
	public int get_nx() {
		return nx;
	}
	
	public int get_ny() {
		return ny;
	}
	
	public float get_fx() {
		return fx;
	}
	
	public float get_fy() {
		return fy;
	}
	
	public SimpleMatrix get_Xu() {
		return Xu;
	}
	
	public SimpleMatrix get_Yu() {
		return Yu;
	}
	
	public SimpleMatrix get_Xd() {
		return Xd;
	}
	
	public SimpleMatrix get_Yd() {
		return Yd;
	}
	
	public int get_numCoeff() {
		return numCoeff;
	}
	
	public int get_numCorresp() {
		return numCorresp;
	}
	
	public SimpleMatrix get_A() {
		return A;
	}
	
	public DecompositionSVD get_svd() {
		return svd;
	}
	
	public SimpleMatrix get_A_pseudoinverse() {
		return A_pseudoinverse;
	}
	
	public SimpleVector get_u_vec() {
		return u_vec;
	}
	
	public SimpleVector get_v_vec() {
		return v_vec;
	}
	
	public SimpleVector get_XuVector() {
		return XuVector;
	}
	
	public SimpleVector get_YuVector() {
		return YuVector;
	}
	
	public SimpleVector get_XdVector() {
		return XdVector;
	}
	
	public SimpleVector get_YdVector() {
		return YdVector;
	}
	
	public Grid2D get_xDist() {
		return xDist;
	}
	
	public Grid2D get_yDist() {
		return yDist;
	}
	
	public Grid2D get_xprime() {
		return xprime;
	}
	
	public Grid2D get_yprime() {
		return yprime;
	}
	
	public Grid2D get_x() {
		return x;
	}
	
	public Grid2D get_y() {
		return y;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-15 23:57:41.553
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-15 23:57:41.553
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-15 23:57:41.571
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package edu.stanford.rsl.tutorial.mipda;

import edu.stanford.rsl.conrad.data.numeric.Grid2D;
import edu.stanford.rsl.conrad.data.numeric.NumericPointwiseOperators;
import edu.stanford.rsl.conrad.utils.ImageUtil;
//import edu.stanford.rsl.conrad.utils.VisualizationUtil;
import ij.IJ;
import ij.ImageJ;
import edu.stanford.rsl.conrad.data.numeric.InterpolationOperators;
//import edu.stanford.rsl.conrad.data.numeric.NumericGridOperator;
import edu.stanford.rsl.conrad.numerics.SimpleMatrix;
import edu.stanford.rsl.conrad.numerics.SimpleOperators;
import edu.stanford.rsl.conrad.numerics.SimpleVector;
import edu.stanford.rsl.conrad.numerics.DecompositionSVD;

/**
 * Geometric Undistortion
 * Programming exercise 1 for module "Defect Pixel Interpolation"
 * of the course "Medical Image Processing for Diagnostic Applications (MIPDA)"
 * @author Frank Schebesch, Ashwini Jadhav, Anna Gebhard, Mena Abdelmalek
 *
 */

public class ExerciseGeoU {

	final static int caseNo = 1; // choose 0, 1, or 2 for different test images

	final static float a = 0.6f; // a: spread among x-direction
	final static float b = 0.3f; // b: spread among y-direction
	final static float d = 5.0f; // d: d/2 value of distortion field at level set for (X/a)^2+(Y/b)^2=1
	
	String filename; // do not edit, choose a number in the main method instead
	Grid2D originalImage; // do not edit, read from filename when instantiating the object
	Grid2D distortedImage; // do not edit, generated in the main method
	Grid2D undistortedImage; // do not edit, member variable for the output image
	
	// number of lattice points
	final int nx = 8;//TODO: define the number of lattice point: nx (Positive number and less than 20)
	final int ny = 8;//TODO: define the number of lattice point: ny (Positive number and less than 20)
	
	float fx;
	float fy;
	SimpleMatrix Xu; 
	SimpleMatrix Yu;
	SimpleMatrix Xd;
	SimpleMatrix Yd;
	int numCoeff; 
	int numCorresp; 
	SimpleMatrix A;
	DecompositionSVD svd;
	SimpleMatrix A_pseudoinverse;
	SimpleVector u_vec;
	SimpleVector v_vec;
	SimpleVector XuVector;
	SimpleVector YuVector;
	SimpleVector XdVector;
	SimpleVector YdVector;
	Grid2D xDist;  
	Grid2D yDist;
	Grid2D xprime; // x-coordinates of point correspondences in the undistorted image
	Grid2D yprime; // y-coordinates of point correspondences in the undistorted image
	Grid2D x; // x-coordinates of point correspondences in the distorted image
	Grid2D y; // y-coordinates of point correspondences in the distorted image
	
	
	/** 
	 * main method
	 * Here you can choose the image, and set the distortion parameters
	 */
	public static void main(String[] args) {
		
		new ImageJ();
		
		// generate distorted image
		ExerciseGeoU exObj = new ExerciseGeoU(caseNo);
		exObj.init(a,b,d);
		
		// TASK: go to the method doImageUndistortion(...) and complete it 
		exObj.undistortedImage = exObj.doImageUndistortion(exObj.distortedImage);
		
		exObj.originalImage.show("Original Image");
		exObj.distortedImage.show("Distorted Image");
		exObj.undistortedImage.show("Undistorted Image");
		
		Grid2D differenceImage = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.originalImage, exObj.undistortedImage);
		
		differenceImage.show("Difference Original vs. Undistorted");
		
		Grid2D distortedVSundistorted = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.undistortedImage, exObj.distortedImage);
		
		distortedVSundistorted.show("Difference Undistorted vs. Distorted");
	}
	
	public Grid2D doImageUndistortion(Grid2D distortedImage){
		
		Grid2D grid = new Grid2D(distortedImage);
		
		// check if image distortion routine has been run
		if (distortedImage == null || undistortedImage == null
				|| xprime == null || yprime == null
				|| x == null || y == null) {
			
			System.err.println("Error in doImageUndistortion(): called before initialization of members.");
			return grid;
		}
		
		
		getLatticePoints(distortedImage);// There are TODOs here 
		
		
		int degree = 5; // polynomial's degree: 2,...,10
		calcPolynomial(degree, Xd);// There are TODOs here
		
		
		
		computeMatrixA(degree, numCorresp, numCoeff);// There are TODOs here
		
		
		computeDistortionCoeff(A, XuVector, YuVector);// There are TODOs here
		
		
		grid = computeDistortedGrid(distortedImage, grid, degree);// There are TODOs here
		
		return grid;
	}
	
	
	
	/** 1. Number of lattice points (this only works for symmetric images):
	 *  nx, ny feature points: usually provided by tracking point
	 *  correspondences in the phantom during the calibration step.
	 *  Here, we use the distorted and undistorted coordinates generated
	 *  in the course of the distortion simulation.
	 */ 
	public void getLatticePoints (Grid2D distortedImage){
		
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		// step size
		// calculate the step size of the lattice points: fx and fy 
		fx = imageWidth/nx; //TODO
		fy = imageHeight/ny; //TODO
		
		// fill the distorted and undistorted lattice points 
		// with data from the given correspondences
		// matrix = number of rows (y) x number of columns (x)
		Xu = new SimpleMatrix(ny,nx);
		Yu = new SimpleMatrix(ny,nx);
		Xd = new SimpleMatrix(ny,nx);
		Yd = new SimpleMatrix(ny,nx);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){

				// sample the distorted and undistorted grid points at the lattice points
				  Xu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx), j + int(fy)));//TODO: fill matrix Xu
				  Yu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx), j + int(fy));//TODO: fill matrix Yu
				  Xd.setElementValue(i, j, fx);//TODO: fill matrix Xd
				  Yd.setElementValue(i, j, fy)//TODO: fill matrix Yd
			}
		}
	}
	
	/** 2. Polynomial of degree d
	 * Polynomial of degree d -> (d-1): extrema (e.g., d=5: 4 extrema)
	 * d=0: constant (horizontal line with y-intercept a_0 -> f(x)=a_0)
	 * d=1: oblique line with y-intercept a_0 & slope a_1 -> f(x)=a_0 + a_1 x
	 * d=2: parabola
	 * d>=2: continuous non-linear curve
	 * ...
	 * d = 10 -> NumCoeff: 66 -> but only 64 lattice points are known (nx, ny = 8)
	 */
	
	public void calcPolynomial(int degree, SimpleMatrix Xd){
		
		// number of coefficients: numCoeff
		// (hint: this is NOT the total number of multiplications!)
		numCoeff = 0; //TODO
		
		// number of correspondences: numCorresp
		numCorresp =  0; //TODO
		
		// Printout of the used parameters
		System.out.println("Polynom of degree: " + degree);
		System.out.println("Number of Coefficients: " + numCoeff);
		System.out.println("Number of Correspondences: " + numCorresp);
		
	}
	
	/**
	 * 3. Create the matrix A
	 */
	
	public void computeMatrixA(int degree, int numCorresp, int numCoeff){
		
		A = new SimpleMatrix(numCorresp, numCoeff);
		if (numCorresp <= 0 && numCoeff <= 0)
			return;
		A.zeros();
		
		// Realign the grid matrix into a vector for easier access in the next step
		XuVector = new SimpleVector(numCorresp);
		YuVector = new SimpleVector(numCorresp);
		XdVector = new SimpleVector(numCorresp);
		YdVector = new SimpleVector(numCorresp);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){
				
				XuVector.setElementValue(i*ny + j, Xu.getElement(j, i));
				YuVector.setElementValue(i*ny + j, Yu.getElement(j, i));
				XdVector.setElementValue(i*ny + j, Xd.getElement(j, i));
				YdVector.setElementValue(i*ny + j, Yd.getElement(j, i));
			}
		}
		
		// Compute matrix A (coordinates from distorted image)
		for(int r = 0; r < numCorresp; r++){
			
			int cc = 0;
			
			for(int k = 0; k <= degree; k++){
				for(int l = 0; l <= (degree-k); l++){
					
					// TODO: fill matrix A
					cc++;
					
				}
			}
		}
	}
	
	public void computeDistortionCoeff(SimpleMatrix A, SimpleVector XuVector, SimpleVector YuVector){
		
		// Compute the pseudo-inverse of A with the help of the SVD (class: DecompositionSVD)
		svd = null; // TODO
	    A_pseudoinverse = null; // TODO
	  
		// Compute the distortion coefficients (solve for known corresponding undistorted points)
		u_vec = null;// TODO
		v_vec = null;// TODO
	}
	
	/**
	 * 4. Compute the distorted grid points (xDist, yDist) which are used to sample the
	 * distorted image to get the undistorted image
	 * (xprime,yprime) is the position in the undistorted image
	 * (xDist,yDist) is the position in the distorted (observed) X-ray image.
	 */
	public Grid2D computeDistortedGrid(Grid2D distortedImage, Grid2D grid_out, int degree){
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		xDist = new Grid2D(imageWidth,imageHeight);  
		yDist = new Grid2D(imageWidth,imageHeight); 
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float val1, val2; //variables Val1 and Val2 are used for intermediate computation of xDist and yDist respectively
				
				int cc = 0;
				
				for(int k = 0; k <= degree; k++){
					for(int l = 0; l <= degree - k; l++){
						
						val1 = 0;// TODO
						val2 = 0;// TODO
						
						// TODO: fill xDist
						// TODO: fill yDist
						
						cc++;
					}
				}
			}
		}
		
		float val; // variable for intermediate computations of undistorted image
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				// hint: consider the fact that the coordinate origin is in the center of the image
				val = 0;//TODO
				//TODO: fill grid_out
			}
		}
		
		return grid_out;
		
	}
	
	
	
	/**
	 * 
	 * end of the exercise
	 */	

	
	/**
	 * standard constructor
	 */
	public ExerciseGeoU(){
		
		this(0);
	}
		
	/**
	 * parameterized constructor for the ExerciseDPI object
	 * @param caseNo: select one of three images to test your undistortion method
	 */
	public ExerciseGeoU(int caseNo){
		
		switch (caseNo) {
		case 0:
			filename = "frame32.jpg";
			break;
		case 1:
			filename = "undistorted.jpg";
			break;
		case 2:
			filename = "frame90.jpg";
			break;
		default:
			filename = "frame32.jpg";
			break;
		}
		
		String imageDataLoc = System.getProperty("user.dir") + "/data/" + "/mipda/";
	
		originalImage = ImageUtil.wrapImagePlus(IJ.openImage(imageDataLoc + filename)).getSubGrid(0);
	}
	
	public void init(float a, float b, float d) {
		
		// Normalize intensity values to [0,1]
		float max = NumericPointwiseOperators.max(originalImage);
		float min = NumericPointwiseOperators.min(originalImage);
		
		for(int i = 0; i < originalImage.getWidth(); i++){
			for(int j = 0; j < originalImage.getHeight(); j++){
				
				float scaledValue = (originalImage.getAtIndex(i, j) - min) / (max-min);
				originalImage.setAtIndex(i, j, scaledValue);
			}
		}
		
		undistortedImage = new Grid2D(originalImage.getWidth(),originalImage.getHeight()); // initialization with zeros
		
		distortedImage = generateDistortedImage(originalImage,a,b,d);	
	}
	
	/**
	 * method to generate a distorted image
	 * An artificial distortion field is generated. With this field, 
	 * a distorted image is generated from the original image.
	 * Remark: coordinates of the latest distortion simulated are saved in class member variables
	 * @param inputImage: undistorted image on which distortion is simulated
	 * @param a: elliptic extent of the distortion in x-direction
	 * @param b: elliptic extent of the distortion in y-direction
	 * @param d: strength of the distortion
	 * @return: distorted image
	 */
    
	public Grid2D generateDistortedImage(Grid2D inputImage, float a, float b, float d){

		Grid2D grid = new Grid2D(inputImage);
		int imageWidth = grid.getWidth();
		int imageHeight = grid.getHeight();
		
		// generate grids to sample coordinates X and Y of the original image
		Grid2D X = new Grid2D(imageWidth,imageHeight); // x-coordinates with respect to origin in image center, spacing = 1 [unit]
		Grid2D Y = new Grid2D(imageWidth,imageHeight); // y-coordinates with respect to origin in image center, spacing = 1 [unit]
		
		float halfWidth = imageWidth / 2.0f;
		float halfHeight = imageHeight / 2.0f;
		
		for(int i = 0; i < X.getWidth(); i++){
			for(int j = 0; j < X.getHeight(); j++){
				
				X.setAtIndex(i, j, i - halfWidth + 0.5f); // assign pixel centers in x-direction
				Y.setAtIndex(i, j, j - halfHeight + 0.5f); // assign pixel center in y-direction
			}
		}
		
		// create an artificial elliptical distortion field R (additive field)
		Grid2D R = new Grid2D(imageWidth,imageHeight);

		for(int i = 0; i < R.getWidth(); i++){
			for(int j = 0; j < R.getHeight(); j++){
				
				// distortion gets stronger with the distance from the image center
				float r = d * (float)(Math.sqrt(
						Math.pow(X.getAtIndex(i, j)/(a*halfWidth),2)
						+ Math.pow(Y.getAtIndex(i, j)/(b*halfHeight),2)));
				R.setAtIndex(i, j, r);
			}
		}
		
		// shifting the positive range to half positive/half negative range
		float maxR = NumericPointwiseOperators.max(R);
		NumericPointwiseOperators.subtractBy(R, maxR * 0.5f);

		// create the distorted image coordinates:
		// distorted image coordinates = undistorted image points + artificial distortion field

		// distorted image coordinates Xd, Yd
		Grid2D Xd = new Grid2D(X);
		Grid2D Yd = new Grid2D(Y);
		
		NumericPointwiseOperators.addBy(Xd, R);
		NumericPointwiseOperators.addBy(Yd, R);
		
		// create the distorted image:
		// re-sample the original input image at the distorted image points (Xd,Yd) 
		// to create artificial distortion
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float distortedValue = InterpolationOperators.interpolateLinear(
						inputImage,
						Xd.getAtIndex(i, j) + halfWidth - 0.5f, // remember: coordinate origin was set to image center
						Yd.getAtIndex(i, j) + halfHeight - 0.5f);
				grid.setAtIndex(i, j, distortedValue);
			}
		}

		xprime = X;
		yprime = Y;
		x = Xd;
		y = Yd;
		
		return grid;	
	}	
	
	//getters for members
	// variables which are checked (DO NOT CHANGE!)
	
	public static int get_caseNo() {
		return caseNo;
	}
	
	public Grid2D get_originalImage() {
		return originalImage;
	}
	
	public Grid2D get_distortedImage() {
		return distortedImage;
	}
	
	public Grid2D get_undistortedImage() {
		return undistortedImage;
	}
	
	public int get_nx() {
		return nx;
	}
	
	public int get_ny() {
		return ny;
	}
	
	public float get_fx() {
		return fx;
	}
	
	public float get_fy() {
		return fy;
	}
	
	public SimpleMatrix get_Xu() {
		return Xu;
	}
	
	public SimpleMatrix get_Yu() {
		return Yu;
	}
	
	public SimpleMatrix get_Xd() {
		return Xd;
	}
	
	public SimpleMatrix get_Yd() {
		return Yd;
	}
	
	public int get_numCoeff() {
		return numCoeff;
	}
	
	public int get_numCorresp() {
		return numCorresp;
	}
	
	public SimpleMatrix get_A() {
		return A;
	}
	
	public DecompositionSVD get_svd() {
		return svd;
	}
	
	public SimpleMatrix get_A_pseudoinverse() {
		return A_pseudoinverse;
	}
	
	public SimpleVector get_u_vec() {
		return u_vec;
	}
	
	public SimpleVector get_v_vec() {
		return v_vec;
	}
	
	public SimpleVector get_XuVector() {
		return XuVector;
	}
	
	public SimpleVector get_YuVector() {
		return YuVector;
	}
	
	public SimpleVector get_XdVector() {
		return XdVector;
	}
	
	public SimpleVector get_YdVector() {
		return YdVector;
	}
	
	public Grid2D get_xDist() {
		return xDist;
	}
	
	public Grid2D get_yDist() {
		return yDist;
	}
	
	public Grid2D get_xprime() {
		return xprime;
	}
	
	public Grid2D get_yprime() {
		return yprime;
	}
	
	public Grid2D get_x() {
		return x;
	}
	
	public Grid2D get_y() {
		return y;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-15 23:57:41.572
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-15 23:57:41.573
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-15 23:57:43.243
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package edu.stanford.rsl.tutorial.mipda;

import edu.stanford.rsl.conrad.data.numeric.Grid2D;
import edu.stanford.rsl.conrad.data.numeric.NumericPointwiseOperators;
import edu.stanford.rsl.conrad.utils.ImageUtil;
//import edu.stanford.rsl.conrad.utils.VisualizationUtil;
import ij.IJ;
import ij.ImageJ;
import edu.stanford.rsl.conrad.data.numeric.InterpolationOperators;
//import edu.stanford.rsl.conrad.data.numeric.NumericGridOperator;
import edu.stanford.rsl.conrad.numerics.SimpleMatrix;
import edu.stanford.rsl.conrad.numerics.SimpleOperators;
import edu.stanford.rsl.conrad.numerics.SimpleVector;
import edu.stanford.rsl.conrad.numerics.DecompositionSVD;

/**
 * Geometric Undistortion
 * Programming exercise 1 for module "Defect Pixel Interpolation"
 * of the course "Medical Image Processing for Diagnostic Applications (MIPDA)"
 * @author Frank Schebesch, Ashwini Jadhav, Anna Gebhard, Mena Abdelmalek
 *
 */

public class ExerciseGeoU {

	final static int caseNo = 1; // choose 0, 1, or 2 for different test images

	final static float a = 0.6f; // a: spread among x-direction
	final static float b = 0.3f; // b: spread among y-direction
	final static float d = 5.0f; // d: d/2 value of distortion field at level set for (X/a)^2+(Y/b)^2=1
	
	String filename; // do not edit, choose a number in the main method instead
	Grid2D originalImage; // do not edit, read from filename when instantiating the object
	Grid2D distortedImage; // do not edit, generated in the main method
	Grid2D undistortedImage; // do not edit, member variable for the output image
	
	// number of lattice points
	final int nx = 8;//TODO: define the number of lattice point: nx (Positive number and less than 20)
	final int ny = 8;//TODO: define the number of lattice point: ny (Positive number and less than 20)
	
	float fx;
	float fy;
	SimpleMatrix Xu; 
	SimpleMatrix Yu;
	SimpleMatrix Xd;
	SimpleMatrix Yd;
	int numCoeff; 
	int numCorresp; 
	SimpleMatrix A;
	DecompositionSVD svd;
	SimpleMatrix A_pseudoinverse;
	SimpleVector u_vec;
	SimpleVector v_vec;
	SimpleVector XuVector;
	SimpleVector YuVector;
	SimpleVector XdVector;
	SimpleVector YdVector;
	Grid2D xDist;  
	Grid2D yDist;
	Grid2D xprime; // x-coordinates of point correspondences in the undistorted image
	Grid2D yprime; // y-coordinates of point correspondences in the undistorted image
	Grid2D x; // x-coordinates of point correspondences in the distorted image
	Grid2D y; // y-coordinates of point correspondences in the distorted image
	
	
	/** 
	 * main method
	 * Here you can choose the image, and set the distortion parameters
	 */
	public static void main(String[] args) {
		
		new ImageJ();
		
		// generate distorted image
		ExerciseGeoU exObj = new ExerciseGeoU(caseNo);
		exObj.init(a,b,d);
		
		// TASK: go to the method doImageUndistortion(...) and complete it 
		exObj.undistortedImage = exObj.doImageUndistortion(exObj.distortedImage);
		
		exObj.originalImage.show("Original Image");
		exObj.distortedImage.show("Distorted Image");
		exObj.undistortedImage.show("Undistorted Image");
		
		Grid2D differenceImage = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.originalImage, exObj.undistortedImage);
		
		differenceImage.show("Difference Original vs. Undistorted");
		
		Grid2D distortedVSundistorted = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.undistortedImage, exObj.distortedImage);
		
		distortedVSundistorted.show("Difference Undistorted vs. Distorted");
	}
	
	public Grid2D doImageUndistortion(Grid2D distortedImage){
		
		Grid2D grid = new Grid2D(distortedImage);
		
		// check if image distortion routine has been run
		if (distortedImage == null || undistortedImage == null
				|| xprime == null || yprime == null
				|| x == null || y == null) {
			
			System.err.println("Error in doImageUndistortion(): called before initialization of members.");
			return grid;
		}
		
		
		getLatticePoints(distortedImage);// There are TODOs here 
		
		
		int degree = 5; // polynomial's degree: 2,...,10
		calcPolynomial(degree, Xd);// There are TODOs here
		
		
		
		computeMatrixA(degree, numCorresp, numCoeff);// There are TODOs here
		
		
		computeDistortionCoeff(A, XuVector, YuVector);// There are TODOs here
		
		
		grid = computeDistortedGrid(distortedImage, grid, degree);// There are TODOs here
		
		return grid;
	}
	
	
	
	/** 1. Number of lattice points (this only works for symmetric images):
	 *  nx, ny feature points: usually provided by tracking point
	 *  correspondences in the phantom during the calibration step.
	 *  Here, we use the distorted and undistorted coordinates generated
	 *  in the course of the distortion simulation.
	 */ 
	public void getLatticePoints (Grid2D distortedImage){
		
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		// step size
		// calculate the step size of the lattice points: fx and fy 
		fx = imageWidth/nx; //TODO
		fy = imageHeight/ny; //TODO
		
		// fill the distorted and undistorted lattice points 
		// with data from the given correspondences
		// matrix = number of rows (y) x number of columns (x)
		Xu = new SimpleMatrix(ny,nx);
		Yu = new SimpleMatrix(ny,nx);
		Xd = new SimpleMatrix(ny,nx);
		Yd = new SimpleMatrix(ny,nx);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){

				// sample the distorted and undistorted grid points at the lattice points
				  Xu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx), j + int(fy)));//TODO: fill matrix Xu
				  Yu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx), j + int(fy));//TODO: fill matrix Yu
				  Xd.setElementValue(i, j, fx);//TODO: fill matrix Xd
				  Yd.setElementValue(i, j, fy)//TODO: fill matrix Yd
			}
		}
	}
	
	/** 2. Polynomial of degree d
	 * Polynomial of degree d -> (d-1): extrema (e.g., d=5: 4 extrema)
	 * d=0: constant (horizontal line with y-intercept a_0 -> f(x)=a_0)
	 * d=1: oblique line with y-intercept a_0 & slope a_1 -> f(x)=a_0 + a_1 x
	 * d=2: parabola
	 * d>=2: continuous non-linear curve
	 * ...
	 * d = 10 -> NumCoeff: 66 -> but only 64 lattice points are known (nx, ny = 8)
	 */
	
	public void calcPolynomial(int degree, SimpleMatrix Xd){
		
		// number of coefficients: numCoeff
		// (hint: this is NOT the total number of multiplications!)
		numCoeff = 0; //TODO
		
		// number of correspondences: numCorresp
		numCorresp =  0; //TODO
		
		// Printout of the used parameters
		System.out.println("Polynom of degree: " + degree);
		System.out.println("Number of Coefficients: " + numCoeff);
		System.out.println("Number of Correspondences: " + numCorresp);
		
	}
	
	/**
	 * 3. Create the matrix A
	 */
	
	public void computeMatrixA(int degree, int numCorresp, int numCoeff){
		
		A = new SimpleMatrix(numCorresp, numCoeff);
		if (numCorresp <= 0 && numCoeff <= 0)
			return;
		A.zeros();
		
		// Realign the grid matrix into a vector for easier access in the next step
		XuVector = new SimpleVector(numCorresp);
		YuVector = new SimpleVector(numCorresp);
		XdVector = new SimpleVector(numCorresp);
		YdVector = new SimpleVector(numCorresp);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){
				
				XuVector.setElementValue(i*ny + j, Xu.getElement(j, i));
				YuVector.setElementValue(i*ny + j, Yu.getElement(j, i));
				XdVector.setElementValue(i*ny + j, Xd.getElement(j, i));
				YdVector.setElementValue(i*ny + j, Yd.getElement(j, i));
			}
		}
		
		// Compute matrix A (coordinates from distorted image)
		for(int r = 0; r < numCorresp; r++){
			
			int cc = 0;
			
			for(int k = 0; k <= degree; k++){
				for(int l = 0; l <= (degree-k); l++){
					
					// TODO: fill matrix A
					cc++;
					
				}
			}
		}
	}
	
	public void computeDistortionCoeff(SimpleMatrix A, SimpleVector XuVector, SimpleVector YuVector){
		
		// Compute the pseudo-inverse of A with the help of the SVD (class: DecompositionSVD)
		svd = null; // TODO
	    A_pseudoinverse = null; // TODO
	  
		// Compute the distortion coefficients (solve for known corresponding undistorted points)
		u_vec = null;// TODO
		v_vec = null;// TODO
	}
	
	/**
	 * 4. Compute the distorted grid points (xDist, yDist) which are used to sample the
	 * distorted image to get the undistorted image
	 * (xprime,yprime) is the position in the undistorted image
	 * (xDist,yDist) is the position in the distorted (observed) X-ray image.
	 */
	public Grid2D computeDistortedGrid(Grid2D distortedImage, Grid2D grid_out, int degree){
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		xDist = new Grid2D(imageWidth,imageHeight);  
		yDist = new Grid2D(imageWidth,imageHeight); 
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float val1, val2; //variables Val1 and Val2 are used for intermediate computation of xDist and yDist respectively
				
				int cc = 0;
				
				for(int k = 0; k <= degree; k++){
					for(int l = 0; l <= degree - k; l++){
						
						val1 = 0;// TODO
						val2 = 0;// TODO
						
						// TODO: fill xDist
						// TODO: fill yDist
						
						cc++;
					}
				}
			}
		}
		
		float val; // variable for intermediate computations of undistorted image
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				// hint: consider the fact that the coordinate origin is in the center of the image
				val = 0;//TODO
				//TODO: fill grid_out
			}
		}
		
		return grid_out;
		
	}
	
	
	
	/**
	 * 
	 * end of the exercise
	 */	

	
	/**
	 * standard constructor
	 */
	public ExerciseGeoU(){
		
		this(0);
	}
		
	/**
	 * parameterized constructor for the ExerciseDPI object
	 * @param caseNo: select one of three images to test your undistortion method
	 */
	public ExerciseGeoU(int caseNo){
		
		switch (caseNo) {
		case 0:
			filename = "frame32.jpg";
			break;
		case 1:
			filename = "undistorted.jpg";
			break;
		case 2:
			filename = "frame90.jpg";
			break;
		default:
			filename = "frame32.jpg";
			break;
		}
		
		String imageDataLoc = System.getProperty("user.dir") + "/data/" + "/mipda/";
	
		originalImage = ImageUtil.wrapImagePlus(IJ.openImage(imageDataLoc + filename)).getSubGrid(0);
	}
	
	public void init(float a, float b, float d) {
		
		// Normalize intensity values to [0,1]
		float max = NumericPointwiseOperators.max(originalImage);
		float min = NumericPointwiseOperators.min(originalImage);
		
		for(int i = 0; i < originalImage.getWidth(); i++){
			for(int j = 0; j < originalImage.getHeight(); j++){
				
				float scaledValue = (originalImage.getAtIndex(i, j) - min) / (max-min);
				originalImage.setAtIndex(i, j, scaledValue);
			}
		}
		
		undistortedImage = new Grid2D(originalImage.getWidth(),originalImage.getHeight()); // initialization with zeros
		
		distortedImage = generateDistortedImage(originalImage,a,b,d);	
	}
	
	/**
	 * method to generate a distorted image
	 * An artificial distortion field is generated. With this field, 
	 * a distorted image is generated from the original image.
	 * Remark: coordinates of the latest distortion simulated are saved in class member variables
	 * @param inputImage: undistorted image on which distortion is simulated
	 * @param a: elliptic extent of the distortion in x-direction
	 * @param b: elliptic extent of the distortion in y-direction
	 * @param d: strength of the distortion
	 * @return: distorted image
	 */
    
	public Grid2D generateDistortedImage(Grid2D inputImage, float a, float b, float d){

		Grid2D grid = new Grid2D(inputImage);
		int imageWidth = grid.getWidth();
		int imageHeight = grid.getHeight();
		
		// generate grids to sample coordinates X and Y of the original image
		Grid2D X = new Grid2D(imageWidth,imageHeight); // x-coordinates with respect to origin in image center, spacing = 1 [unit]
		Grid2D Y = new Grid2D(imageWidth,imageHeight); // y-coordinates with respect to origin in image center, spacing = 1 [unit]
		
		float halfWidth = imageWidth / 2.0f;
		float halfHeight = imageHeight / 2.0f;
		
		for(int i = 0; i < X.getWidth(); i++){
			for(int j = 0; j < X.getHeight(); j++){
				
				X.setAtIndex(i, j, i - halfWidth + 0.5f); // assign pixel centers in x-direction
				Y.setAtIndex(i, j, j - halfHeight + 0.5f); // assign pixel center in y-direction
			}
		}
		
		// create an artificial elliptical distortion field R (additive field)
		Grid2D R = new Grid2D(imageWidth,imageHeight);

		for(int i = 0; i < R.getWidth(); i++){
			for(int j = 0; j < R.getHeight(); j++){
				
				// distortion gets stronger with the distance from the image center
				float r = d * (float)(Math.sqrt(
						Math.pow(X.getAtIndex(i, j)/(a*halfWidth),2)
						+ Math.pow(Y.getAtIndex(i, j)/(b*halfHeight),2)));
				R.setAtIndex(i, j, r);
			}
		}
		
		// shifting the positive range to half positive/half negative range
		float maxR = NumericPointwiseOperators.max(R);
		NumericPointwiseOperators.subtractBy(R, maxR * 0.5f);

		// create the distorted image coordinates:
		// distorted image coordinates = undistorted image points + artificial distortion field

		// distorted image coordinates Xd, Yd
		Grid2D Xd = new Grid2D(X);
		Grid2D Yd = new Grid2D(Y);
		
		NumericPointwiseOperators.addBy(Xd, R);
		NumericPointwiseOperators.addBy(Yd, R);
		
		// create the distorted image:
		// re-sample the original input image at the distorted image points (Xd,Yd) 
		// to create artificial distortion
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float distortedValue = InterpolationOperators.interpolateLinear(
						inputImage,
						Xd.getAtIndex(i, j) + halfWidth - 0.5f, // remember: coordinate origin was set to image center
						Yd.getAtIndex(i, j) + halfHeight - 0.5f);
				grid.setAtIndex(i, j, distortedValue);
			}
		}

		xprime = X;
		yprime = Y;
		x = Xd;
		y = Yd;
		
		return grid;	
	}	
	
	//getters for members
	// variables which are checked (DO NOT CHANGE!)
	
	public static int get_caseNo() {
		return caseNo;
	}
	
	public Grid2D get_originalImage() {
		return originalImage;
	}
	
	public Grid2D get_distortedImage() {
		return distortedImage;
	}
	
	public Grid2D get_undistortedImage() {
		return undistortedImage;
	}
	
	public int get_nx() {
		return nx;
	}
	
	public int get_ny() {
		return ny;
	}
	
	public float get_fx() {
		return fx;
	}
	
	public float get_fy() {
		return fy;
	}
	
	public SimpleMatrix get_Xu() {
		return Xu;
	}
	
	public SimpleMatrix get_Yu() {
		return Yu;
	}
	
	public SimpleMatrix get_Xd() {
		return Xd;
	}
	
	public SimpleMatrix get_Yd() {
		return Yd;
	}
	
	public int get_numCoeff() {
		return numCoeff;
	}
	
	public int get_numCorresp() {
		return numCorresp;
	}
	
	public SimpleMatrix get_A() {
		return A;
	}
	
	public DecompositionSVD get_svd() {
		return svd;
	}
	
	public SimpleMatrix get_A_pseudoinverse() {
		return A_pseudoinverse;
	}
	
	public SimpleVector get_u_vec() {
		return u_vec;
	}
	
	public SimpleVector get_v_vec() {
		return v_vec;
	}
	
	public SimpleVector get_XuVector() {
		return XuVector;
	}
	
	public SimpleVector get_YuVector() {
		return YuVector;
	}
	
	public SimpleVector get_XdVector() {
		return XdVector;
	}
	
	public SimpleVector get_YdVector() {
		return YdVector;
	}
	
	public Grid2D get_xDist() {
		return xDist;
	}
	
	public Grid2D get_yDist() {
		return yDist;
	}
	
	public Grid2D get_xprime() {
		return xprime;
	}
	
	public Grid2D get_yprime() {
		return yprime;
	}
	
	public Grid2D get_x() {
		return x;
	}
	
	public Grid2D get_y() {
		return y;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-15 23:57:43.244
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-15 23:57:43.244
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-15 23:57:46.087
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package edu.stanford.rsl.tutorial.mipda;

import edu.stanford.rsl.conrad.data.numeric.Grid2D;
import edu.stanford.rsl.conrad.data.numeric.NumericPointwiseOperators;
import edu.stanford.rsl.conrad.utils.ImageUtil;
//import edu.stanford.rsl.conrad.utils.VisualizationUtil;
import ij.IJ;
import ij.ImageJ;
import edu.stanford.rsl.conrad.data.numeric.InterpolationOperators;
//import edu.stanford.rsl.conrad.data.numeric.NumericGridOperator;
import edu.stanford.rsl.conrad.numerics.SimpleMatrix;
import edu.stanford.rsl.conrad.numerics.SimpleOperators;
import edu.stanford.rsl.conrad.numerics.SimpleVector;
import edu.stanford.rsl.conrad.numerics.DecompositionSVD;

/**
 * Geometric Undistortion
 * Programming exercise 1 for module "Defect Pixel Interpolation"
 * of the course "Medical Image Processing for Diagnostic Applications (MIPDA)"
 * @author Frank Schebesch, Ashwini Jadhav, Anna Gebhard, Mena Abdelmalek
 *
 */

public class ExerciseGeoU {

	final static int caseNo = 1; // choose 0, 1, or 2 for different test images

	final static float a = 0.6f; // a: spread among x-direction
	final static float b = 0.3f; // b: spread among y-direction
	final static float d = 5.0f; // d: d/2 value of distortion field at level set for (X/a)^2+(Y/b)^2=1
	
	String filename; // do not edit, choose a number in the main method instead
	Grid2D originalImage; // do not edit, read from filename when instantiating the object
	Grid2D distortedImage; // do not edit, generated in the main method
	Grid2D undistortedImage; // do not edit, member variable for the output image
	
	// number of lattice points
	final int nx = 8;//TODO: define the number of lattice point: nx (Positive number and less than 20)
	final int ny = 8;//TODO: define the number of lattice point: ny (Positive number and less than 20)
	
	float fx;
	float fy;
	SimpleMatrix Xu; 
	SimpleMatrix Yu;
	SimpleMatrix Xd;
	SimpleMatrix Yd;
	int numCoeff; 
	int numCorresp; 
	SimpleMatrix A;
	DecompositionSVD svd;
	SimpleMatrix A_pseudoinverse;
	SimpleVector u_vec;
	SimpleVector v_vec;
	SimpleVector XuVector;
	SimpleVector YuVector;
	SimpleVector XdVector;
	SimpleVector YdVector;
	Grid2D xDist;  
	Grid2D yDist;
	Grid2D xprime; // x-coordinates of point correspondences in the undistorted image
	Grid2D yprime; // y-coordinates of point correspondences in the undistorted image
	Grid2D x; // x-coordinates of point correspondences in the distorted image
	Grid2D y; // y-coordinates of point correspondences in the distorted image
	
	
	/** 
	 * main method
	 * Here you can choose the image, and set the distortion parameters
	 */
	public static void main(String[] args) {
		
		new ImageJ();
		
		// generate distorted image
		ExerciseGeoU exObj = new ExerciseGeoU(caseNo);
		exObj.init(a,b,d);
		
		// TASK: go to the method doImageUndistortion(...) and complete it 
		exObj.undistortedImage = exObj.doImageUndistortion(exObj.distortedImage);
		
		exObj.originalImage.show("Original Image");
		exObj.distortedImage.show("Distorted Image");
		exObj.undistortedImage.show("Undistorted Image");
		
		Grid2D differenceImage = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.originalImage, exObj.undistortedImage);
		
		differenceImage.show("Difference Original vs. Undistorted");
		
		Grid2D distortedVSundistorted = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.undistortedImage, exObj.distortedImage);
		
		distortedVSundistorted.show("Difference Undistorted vs. Distorted");
	}
	
	public Grid2D doImageUndistortion(Grid2D distortedImage){
		
		Grid2D grid = new Grid2D(distortedImage);
		
		// check if image distortion routine has been run
		if (distortedImage == null || undistortedImage == null
				|| xprime == null || yprime == null
				|| x == null || y == null) {
			
			System.err.println("Error in doImageUndistortion(): called before initialization of members.");
			return grid;
		}
		
		
		getLatticePoints(distortedImage);// There are TODOs here 
		
		
		int degree = 5; // polynomial's degree: 2,...,10
		calcPolynomial(degree, Xd);// There are TODOs here
		
		
		
		computeMatrixA(degree, numCorresp, numCoeff);// There are TODOs here
		
		
		computeDistortionCoeff(A, XuVector, YuVector);// There are TODOs here
		
		
		grid = computeDistortedGrid(distortedImage, grid, degree);// There are TODOs here
		
		return grid;
	}
	
	
	
	/** 1. Number of lattice points (this only works for symmetric images):
	 *  nx, ny feature points: usually provided by tracking point
	 *  correspondences in the phantom during the calibration step.
	 *  Here, we use the distorted and undistorted coordinates generated
	 *  in the course of the distortion simulation.
	 */ 
	public void getLatticePoints (Grid2D distortedImage){
		
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		// step size
		// calculate the step size of the lattice points: fx and fy 
		fx = imageWidth/nx; //TODO
		fy = imageHeight/ny; //TODO
		
		// fill the distorted and undistorted lattice points 
		// with data from the given correspondences
		// matrix = number of rows (y) x number of columns (x)
		Xu = new SimpleMatrix(ny,nx);
		Yu = new SimpleMatrix(ny,nx);
		Xd = new SimpleMatrix(ny,nx);
		Yd = new SimpleMatrix(ny,nx);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){

				// sample the distorted and undistorted grid points at the lattice points
				  Xu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx), j + int(fy)));//TODO: fill matrix Xu
				  Yu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx), j + int(fy));//TODO: fill matrix Yu
				  Xd.setElementValue(i, j, fx);//TODO: fill matrix Xd
				  Yd.setElementValue(i, j, fy)//TODO: fill matrix Yd
			}
		}
	}
	
	/** 2. Polynomial of degree d
	 * Polynomial of degree d -> (d-1): extrema (e.g., d=5: 4 extrema)
	 * d=0: constant (horizontal line with y-intercept a_0 -> f(x)=a_0)
	 * d=1: oblique line with y-intercept a_0 & slope a_1 -> f(x)=a_0 + a_1 x
	 * d=2: parabola
	 * d>=2: continuous non-linear curve
	 * ...
	 * d = 10 -> NumCoeff: 66 -> but only 64 lattice points are known (nx, ny = 8)
	 */
	
	public void calcPolynomial(int degree, SimpleMatrix Xd){
		
		// number of coefficients: numCoeff
		// (hint: this is NOT the total number of multiplications!)
		numCoeff = 0; //TODO
		
		// number of correspondences: numCorresp
		numCorresp =  0; //TODO
		
		// Printout of the used parameters
		System.out.println("Polynom of degree: " + degree);
		System.out.println("Number of Coefficients: " + numCoeff);
		System.out.println("Number of Correspondences: " + numCorresp);
		
	}
	
	/**
	 * 3. Create the matrix A
	 */
	
	public void computeMatrixA(int degree, int numCorresp, int numCoeff){
		
		A = new SimpleMatrix(numCorresp, numCoeff);
		if (numCorresp <= 0 && numCoeff <= 0)
			return;
		A.zeros();
		
		// Realign the grid matrix into a vector for easier access in the next step
		XuVector = new SimpleVector(numCorresp);
		YuVector = new SimpleVector(numCorresp);
		XdVector = new SimpleVector(numCorresp);
		YdVector = new SimpleVector(numCorresp);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){
				
				XuVector.setElementValue(i*ny + j, Xu.getElement(j, i));
				YuVector.setElementValue(i*ny + j, Yu.getElement(j, i));
				XdVector.setElementValue(i*ny + j, Xd.getElement(j, i));
				YdVector.setElementValue(i*ny + j, Yd.getElement(j, i));
			}
		}
		
		// Compute matrix A (coordinates from distorted image)
		for(int r = 0; r < numCorresp; r++){
			
			int cc = 0;
			
			for(int k = 0; k <= degree; k++){
				for(int l = 0; l <= (degree-k); l++){
					
					// TODO: fill matrix A
					cc++;
					
				}
			}
		}
	}
	
	public void computeDistortionCoeff(SimpleMatrix A, SimpleVector XuVector, SimpleVector YuVector){
		
		// Compute the pseudo-inverse of A with the help of the SVD (class: DecompositionSVD)
		svd = null; // TODO
	    A_pseudoinverse = null; // TODO
	  
		// Compute the distortion coefficients (solve for known corresponding undistorted points)
		u_vec = null;// TODO
		v_vec = null;// TODO
	}
	
	/**
	 * 4. Compute the distorted grid points (xDist, yDist) which are used to sample the
	 * distorted image to get the undistorted image
	 * (xprime,yprime) is the position in the undistorted image
	 * (xDist,yDist) is the position in the distorted (observed) X-ray image.
	 */
	public Grid2D computeDistortedGrid(Grid2D distortedImage, Grid2D grid_out, int degree){
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		xDist = new Grid2D(imageWidth,imageHeight);  
		yDist = new Grid2D(imageWidth,imageHeight); 
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float val1, val2; //variables Val1 and Val2 are used for intermediate computation of xDist and yDist respectively
				
				int cc = 0;
				
				for(int k = 0; k <= degree; k++){
					for(int l = 0; l <= degree - k; l++){
						
						val1 = 0;// TODO
						val2 = 0;// TODO
						
						// TODO: fill xDist
						// TODO: fill yDist
						
						cc++;
					}
				}
			}
		}
		
		float val; // variable for intermediate computations of undistorted image
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				// hint: consider the fact that the coordinate origin is in the center of the image
				val = 0;//TODO
				//TODO: fill grid_out
			}
		}
		
		return grid_out;
		
	}
	
	
	
	/**
	 * 
	 * end of the exercise
	 */	

	
	/**
	 * standard constructor
	 */
	public ExerciseGeoU(){
		
		this(0);
	}
		
	/**
	 * parameterized constructor for the ExerciseDPI object
	 * @param caseNo: select one of three images to test your undistortion method
	 */
	public ExerciseGeoU(int caseNo){
		
		switch (caseNo) {
		case 0:
			filename = "frame32.jpg";
			break;
		case 1:
			filename = "undistorted.jpg";
			break;
		case 2:
			filename = "frame90.jpg";
			break;
		default:
			filename = "frame32.jpg";
			break;
		}
		
		String imageDataLoc = System.getProperty("user.dir") + "/data/" + "/mipda/";
	
		originalImage = ImageUtil.wrapImagePlus(IJ.openImage(imageDataLoc + filename)).getSubGrid(0);
	}
	
	public void init(float a, float b, float d) {
		
		// Normalize intensity values to [0,1]
		float max = NumericPointwiseOperators.max(originalImage);
		float min = NumericPointwiseOperators.min(originalImage);
		
		for(int i = 0; i < originalImage.getWidth(); i++){
			for(int j = 0; j < originalImage.getHeight(); j++){
				
				float scaledValue = (originalImage.getAtIndex(i, j) - min) / (max-min);
				originalImage.setAtIndex(i, j, scaledValue);
			}
		}
		
		undistortedImage = new Grid2D(originalImage.getWidth(),originalImage.getHeight()); // initialization with zeros
		
		distortedImage = generateDistortedImage(originalImage,a,b,d);	
	}
	
	/**
	 * method to generate a distorted image
	 * An artificial distortion field is generated. With this field, 
	 * a distorted image is generated from the original image.
	 * Remark: coordinates of the latest distortion simulated are saved in class member variables
	 * @param inputImage: undistorted image on which distortion is simulated
	 * @param a: elliptic extent of the distortion in x-direction
	 * @param b: elliptic extent of the distortion in y-direction
	 * @param d: strength of the distortion
	 * @return: distorted image
	 */
    
	public Grid2D generateDistortedImage(Grid2D inputImage, float a, float b, float d){

		Grid2D grid = new Grid2D(inputImage);
		int imageWidth = grid.getWidth();
		int imageHeight = grid.getHeight();
		
		// generate grids to sample coordinates X and Y of the original image
		Grid2D X = new Grid2D(imageWidth,imageHeight); // x-coordinates with respect to origin in image center, spacing = 1 [unit]
		Grid2D Y = new Grid2D(imageWidth,imageHeight); // y-coordinates with respect to origin in image center, spacing = 1 [unit]
		
		float halfWidth = imageWidth / 2.0f;
		float halfHeight = imageHeight / 2.0f;
		
		for(int i = 0; i < X.getWidth(); i++){
			for(int j = 0; j < X.getHeight(); j++){
				
				X.setAtIndex(i, j, i - halfWidth + 0.5f); // assign pixel centers in x-direction
				Y.setAtIndex(i, j, j - halfHeight + 0.5f); // assign pixel center in y-direction
			}
		}
		
		// create an artificial elliptical distortion field R (additive field)
		Grid2D R = new Grid2D(imageWidth,imageHeight);

		for(int i = 0; i < R.getWidth(); i++){
			for(int j = 0; j < R.getHeight(); j++){
				
				// distortion gets stronger with the distance from the image center
				float r = d * (float)(Math.sqrt(
						Math.pow(X.getAtIndex(i, j)/(a*halfWidth),2)
						+ Math.pow(Y.getAtIndex(i, j)/(b*halfHeight),2)));
				R.setAtIndex(i, j, r);
			}
		}
		
		// shifting the positive range to half positive/half negative range
		float maxR = NumericPointwiseOperators.max(R);
		NumericPointwiseOperators.subtractBy(R, maxR * 0.5f);

		// create the distorted image coordinates:
		// distorted image coordinates = undistorted image points + artificial distortion field

		// distorted image coordinates Xd, Yd
		Grid2D Xd = new Grid2D(X);
		Grid2D Yd = new Grid2D(Y);
		
		NumericPointwiseOperators.addBy(Xd, R);
		NumericPointwiseOperators.addBy(Yd, R);
		
		// create the distorted image:
		// re-sample the original input image at the distorted image points (Xd,Yd) 
		// to create artificial distortion
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float distortedValue = InterpolationOperators.interpolateLinear(
						inputImage,
						Xd.getAtIndex(i, j) + halfWidth - 0.5f, // remember: coordinate origin was set to image center
						Yd.getAtIndex(i, j) + halfHeight - 0.5f);
				grid.setAtIndex(i, j, distortedValue);
			}
		}

		xprime = X;
		yprime = Y;
		x = Xd;
		y = Yd;
		
		return grid;	
	}	
	
	//getters for members
	// variables which are checked (DO NOT CHANGE!)
	
	public static int get_caseNo() {
		return caseNo;
	}
	
	public Grid2D get_originalImage() {
		return originalImage;
	}
	
	public Grid2D get_distortedImage() {
		return distortedImage;
	}
	
	public Grid2D get_undistortedImage() {
		return undistortedImage;
	}
	
	public int get_nx() {
		return nx;
	}
	
	public int get_ny() {
		return ny;
	}
	
	public float get_fx() {
		return fx;
	}
	
	public float get_fy() {
		return fy;
	}
	
	public SimpleMatrix get_Xu() {
		return Xu;
	}
	
	public SimpleMatrix get_Yu() {
		return Yu;
	}
	
	public SimpleMatrix get_Xd() {
		return Xd;
	}
	
	public SimpleMatrix get_Yd() {
		return Yd;
	}
	
	public int get_numCoeff() {
		return numCoeff;
	}
	
	public int get_numCorresp() {
		return numCorresp;
	}
	
	public SimpleMatrix get_A() {
		return A;
	}
	
	public DecompositionSVD get_svd() {
		return svd;
	}
	
	public SimpleMatrix get_A_pseudoinverse() {
		return A_pseudoinverse;
	}
	
	public SimpleVector get_u_vec() {
		return u_vec;
	}
	
	public SimpleVector get_v_vec() {
		return v_vec;
	}
	
	public SimpleVector get_XuVector() {
		return XuVector;
	}
	
	public SimpleVector get_YuVector() {
		return YuVector;
	}
	
	public SimpleVector get_XdVector() {
		return XdVector;
	}
	
	public SimpleVector get_YdVector() {
		return YdVector;
	}
	
	public Grid2D get_xDist() {
		return xDist;
	}
	
	public Grid2D get_yDist() {
		return yDist;
	}
	
	public Grid2D get_xprime() {
		return xprime;
	}
	
	public Grid2D get_yprime() {
		return yprime;
	}
	
	public Grid2D get_x() {
		return x;
	}
	
	public Grid2D get_y() {
		return y;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-15 23:57:46.088
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-15 23:57:46.088
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-15 23:57:47.063
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package edu.stanford.rsl.tutorial.mipda;

import edu.stanford.rsl.conrad.data.numeric.Grid2D;
import edu.stanford.rsl.conrad.data.numeric.NumericPointwiseOperators;
import edu.stanford.rsl.conrad.utils.ImageUtil;
//import edu.stanford.rsl.conrad.utils.VisualizationUtil;
import ij.IJ;
import ij.ImageJ;
import edu.stanford.rsl.conrad.data.numeric.InterpolationOperators;
//import edu.stanford.rsl.conrad.data.numeric.NumericGridOperator;
import edu.stanford.rsl.conrad.numerics.SimpleMatrix;
import edu.stanford.rsl.conrad.numerics.SimpleOperators;
import edu.stanford.rsl.conrad.numerics.SimpleVector;
import edu.stanford.rsl.conrad.numerics.DecompositionSVD;

/**
 * Geometric Undistortion
 * Programming exercise 1 for module "Defect Pixel Interpolation"
 * of the course "Medical Image Processing for Diagnostic Applications (MIPDA)"
 * @author Frank Schebesch, Ashwini Jadhav, Anna Gebhard, Mena Abdelmalek
 *
 */

public class ExerciseGeoU {

	final static int caseNo = 1; // choose 0, 1, or 2 for different test images

	final static float a = 0.6f; // a: spread among x-direction
	final static float b = 0.3f; // b: spread among y-direction
	final static float d = 5.0f; // d: d/2 value of distortion field at level set for (X/a)^2+(Y/b)^2=1
	
	String filename; // do not edit, choose a number in the main method instead
	Grid2D originalImage; // do not edit, read from filename when instantiating the object
	Grid2D distortedImage; // do not edit, generated in the main method
	Grid2D undistortedImage; // do not edit, member variable for the output image
	
	// number of lattice points
	final int nx = 8;//TODO: define the number of lattice point: nx (Positive number and less than 20)
	final int ny = 8;//TODO: define the number of lattice point: ny (Positive number and less than 20)
	
	float fx;
	float fy;
	SimpleMatrix Xu; 
	SimpleMatrix Yu;
	SimpleMatrix Xd;
	SimpleMatrix Yd;
	int numCoeff; 
	int numCorresp; 
	SimpleMatrix A;
	DecompositionSVD svd;
	SimpleMatrix A_pseudoinverse;
	SimpleVector u_vec;
	SimpleVector v_vec;
	SimpleVector XuVector;
	SimpleVector YuVector;
	SimpleVector XdVector;
	SimpleVector YdVector;
	Grid2D xDist;  
	Grid2D yDist;
	Grid2D xprime; // x-coordinates of point correspondences in the undistorted image
	Grid2D yprime; // y-coordinates of point correspondences in the undistorted image
	Grid2D x; // x-coordinates of point correspondences in the distorted image
	Grid2D y; // y-coordinates of point correspondences in the distorted image
	
	
	/** 
	 * main method
	 * Here you can choose the image, and set the distortion parameters
	 */
	public static void main(String[] args) {
		
		new ImageJ();
		
		// generate distorted image
		ExerciseGeoU exObj = new ExerciseGeoU(caseNo);
		exObj.init(a,b,d);
		
		// TASK: go to the method doImageUndistortion(...) and complete it 
		exObj.undistortedImage = exObj.doImageUndistortion(exObj.distortedImage);
		
		exObj.originalImage.show("Original Image");
		exObj.distortedImage.show("Distorted Image");
		exObj.undistortedImage.show("Undistorted Image");
		
		Grid2D differenceImage = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.originalImage, exObj.undistortedImage);
		
		differenceImage.show("Difference Original vs. Undistorted");
		
		Grid2D distortedVSundistorted = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.undistortedImage, exObj.distortedImage);
		
		distortedVSundistorted.show("Difference Undistorted vs. Distorted");
	}
	
	public Grid2D doImageUndistortion(Grid2D distortedImage){
		
		Grid2D grid = new Grid2D(distortedImage);
		
		// check if image distortion routine has been run
		if (distortedImage == null || undistortedImage == null
				|| xprime == null || yprime == null
				|| x == null || y == null) {
			
			System.err.println("Error in doImageUndistortion(): called before initialization of members.");
			return grid;
		}
		
		
		getLatticePoints(distortedImage);// There are TODOs here 
		
		
		int degree = 5; // polynomial's degree: 2,...,10
		calcPolynomial(degree, Xd);// There are TODOs here
		
		
		
		computeMatrixA(degree, numCorresp, numCoeff);// There are TODOs here
		
		
		computeDistortionCoeff(A, XuVector, YuVector);// There are TODOs here
		
		
		grid = computeDistortedGrid(distortedImage, grid, degree);// There are TODOs here
		
		return grid;
	}
	
	
	
	/** 1. Number of lattice points (this only works for symmetric images):
	 *  nx, ny feature points: usually provided by tracking point
	 *  correspondences in the phantom during the calibration step.
	 *  Here, we use the distorted and undistorted coordinates generated
	 *  in the course of the distortion simulation.
	 */ 
	public void getLatticePoints (Grid2D distortedImage){
		
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		// step size
		// calculate the step size of the lattice points: fx and fy 
		fx = imageWidth/nx; //TODO
		fy = imageHeight/ny; //TODO
		
		// fill the distorted and undistorted lattice points 
		// with data from the given correspondences
		// matrix = number of rows (y) x number of columns (x)
		Xu = new SimpleMatrix(ny,nx);
		Yu = new SimpleMatrix(ny,nx);
		Xd = new SimpleMatrix(ny,nx);
		Yd = new SimpleMatrix(ny,nx);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){

				// sample the distorted and undistorted grid points at the lattice points
				  Xu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx), j + int(fy)));//TODO: fill matrix Xu
				  Yu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx), j + int(fy));//TODO: fill matrix Yu
				  Xd.setElementValue(i, j, fx);//TODO: fill matrix Xd
				  Yd.setElementValue(i, j, fy)//TODO: fill matrix Yd
			}
		}
	}
	
	/** 2. Polynomial of degree d
	 * Polynomial of degree d -> (d-1): extrema (e.g., d=5: 4 extrema)
	 * d=0: constant (horizontal line with y-intercept a_0 -> f(x)=a_0)
	 * d=1: oblique line with y-intercept a_0 & slope a_1 -> f(x)=a_0 + a_1 x
	 * d=2: parabola
	 * d>=2: continuous non-linear curve
	 * ...
	 * d = 10 -> NumCoeff: 66 -> but only 64 lattice points are known (nx, ny = 8)
	 */
	
	public void calcPolynomial(int degree, SimpleMatrix Xd){
		
		// number of coefficients: numCoeff
		// (hint: this is NOT the total number of multiplications!)
		numCoeff = 0; //TODO
		
		// number of correspondences: numCorresp
		numCorresp =  0; //TODO
		
		// Printout of the used parameters
		System.out.println("Polynom of degree: " + degree);
		System.out.println("Number of Coefficients: " + numCoeff);
		System.out.println("Number of Correspondences: " + numCorresp);
		
	}
	
	/**
	 * 3. Create the matrix A
	 */
	
	public void computeMatrixA(int degree, int numCorresp, int numCoeff){
		
		A = new SimpleMatrix(numCorresp, numCoeff);
		if (numCorresp <= 0 && numCoeff <= 0)
			return;
		A.zeros();
		
		// Realign the grid matrix into a vector for easier access in the next step
		XuVector = new SimpleVector(numCorresp);
		YuVector = new SimpleVector(numCorresp);
		XdVector = new SimpleVector(numCorresp);
		YdVector = new SimpleVector(numCorresp);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){
				
				XuVector.setElementValue(i*ny + j, Xu.getElement(j, i));
				YuVector.setElementValue(i*ny + j, Yu.getElement(j, i));
				XdVector.setElementValue(i*ny + j, Xd.getElement(j, i));
				YdVector.setElementValue(i*ny + j, Yd.getElement(j, i));
			}
		}
		
		// Compute matrix A (coordinates from distorted image)
		for(int r = 0; r < numCorresp; r++){
			
			int cc = 0;
			
			for(int k = 0; k <= degree; k++){
				for(int l = 0; l <= (degree-k); l++){
					
					// TODO: fill matrix A
					cc++;
					
				}
			}
		}
	}
	
	public void computeDistortionCoeff(SimpleMatrix A, SimpleVector XuVector, SimpleVector YuVector){
		
		// Compute the pseudo-inverse of A with the help of the SVD (class: DecompositionSVD)
		svd = null; // TODO
	    A_pseudoinverse = null; // TODO
	  
		// Compute the distortion coefficients (solve for known corresponding undistorted points)
		u_vec = null;// TODO
		v_vec = null;// TODO
	}
	
	/**
	 * 4. Compute the distorted grid points (xDist, yDist) which are used to sample the
	 * distorted image to get the undistorted image
	 * (xprime,yprime) is the position in the undistorted image
	 * (xDist,yDist) is the position in the distorted (observed) X-ray image.
	 */
	public Grid2D computeDistortedGrid(Grid2D distortedImage, Grid2D grid_out, int degree){
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		xDist = new Grid2D(imageWidth,imageHeight);  
		yDist = new Grid2D(imageWidth,imageHeight); 
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float val1, val2; //variables Val1 and Val2 are used for intermediate computation of xDist and yDist respectively
				
				int cc = 0;
				
				for(int k = 0; k <= degree; k++){
					for(int l = 0; l <= degree - k; l++){
						
						val1 = 0;// TODO
						val2 = 0;// TODO
						
						// TODO: fill xDist
						// TODO: fill yDist
						
						cc++;
					}
				}
			}
		}
		
		float val; // variable for intermediate computations of undistorted image
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				// hint: consider the fact that the coordinate origin is in the center of the image
				val = 0;//TODO
				//TODO: fill grid_out
			}
		}
		
		return grid_out;
		
	}
	
	
	
	/**
	 * 
	 * end of the exercise
	 */	

	
	/**
	 * standard constructor
	 */
	public ExerciseGeoU(){
		
		this(0);
	}
		
	/**
	 * parameterized constructor for the ExerciseDPI object
	 * @param caseNo: select one of three images to test your undistortion method
	 */
	public ExerciseGeoU(int caseNo){
		
		switch (caseNo) {
		case 0:
			filename = "frame32.jpg";
			break;
		case 1:
			filename = "undistorted.jpg";
			break;
		case 2:
			filename = "frame90.jpg";
			break;
		default:
			filename = "frame32.jpg";
			break;
		}
		
		String imageDataLoc = System.getProperty("user.dir") + "/data/" + "/mipda/";
	
		originalImage = ImageUtil.wrapImagePlus(IJ.openImage(imageDataLoc + filename)).getSubGrid(0);
	}
	
	public void init(float a, float b, float d) {
		
		// Normalize intensity values to [0,1]
		float max = NumericPointwiseOperators.max(originalImage);
		float min = NumericPointwiseOperators.min(originalImage);
		
		for(int i = 0; i < originalImage.getWidth(); i++){
			for(int j = 0; j < originalImage.getHeight(); j++){
				
				float scaledValue = (originalImage.getAtIndex(i, j) - min) / (max-min);
				originalImage.setAtIndex(i, j, scaledValue);
			}
		}
		
		undistortedImage = new Grid2D(originalImage.getWidth(),originalImage.getHeight()); // initialization with zeros
		
		distortedImage = generateDistortedImage(originalImage,a,b,d);	
	}
	
	/**
	 * method to generate a distorted image
	 * An artificial distortion field is generated. With this field, 
	 * a distorted image is generated from the original image.
	 * Remark: coordinates of the latest distortion simulated are saved in class member variables
	 * @param inputImage: undistorted image on which distortion is simulated
	 * @param a: elliptic extent of the distortion in x-direction
	 * @param b: elliptic extent of the distortion in y-direction
	 * @param d: strength of the distortion
	 * @return: distorted image
	 */
    
	public Grid2D generateDistortedImage(Grid2D inputImage, float a, float b, float d){

		Grid2D grid = new Grid2D(inputImage);
		int imageWidth = grid.getWidth();
		int imageHeight = grid.getHeight();
		
		// generate grids to sample coordinates X and Y of the original image
		Grid2D X = new Grid2D(imageWidth,imageHeight); // x-coordinates with respect to origin in image center, spacing = 1 [unit]
		Grid2D Y = new Grid2D(imageWidth,imageHeight); // y-coordinates with respect to origin in image center, spacing = 1 [unit]
		
		float halfWidth = imageWidth / 2.0f;
		float halfHeight = imageHeight / 2.0f;
		
		for(int i = 0; i < X.getWidth(); i++){
			for(int j = 0; j < X.getHeight(); j++){
				
				X.setAtIndex(i, j, i - halfWidth + 0.5f); // assign pixel centers in x-direction
				Y.setAtIndex(i, j, j - halfHeight + 0.5f); // assign pixel center in y-direction
			}
		}
		
		// create an artificial elliptical distortion field R (additive field)
		Grid2D R = new Grid2D(imageWidth,imageHeight);

		for(int i = 0; i < R.getWidth(); i++){
			for(int j = 0; j < R.getHeight(); j++){
				
				// distortion gets stronger with the distance from the image center
				float r = d * (float)(Math.sqrt(
						Math.pow(X.getAtIndex(i, j)/(a*halfWidth),2)
						+ Math.pow(Y.getAtIndex(i, j)/(b*halfHeight),2)));
				R.setAtIndex(i, j, r);
			}
		}
		
		// shifting the positive range to half positive/half negative range
		float maxR = NumericPointwiseOperators.max(R);
		NumericPointwiseOperators.subtractBy(R, maxR * 0.5f);

		// create the distorted image coordinates:
		// distorted image coordinates = undistorted image points + artificial distortion field

		// distorted image coordinates Xd, Yd
		Grid2D Xd = new Grid2D(X);
		Grid2D Yd = new Grid2D(Y);
		
		NumericPointwiseOperators.addBy(Xd, R);
		NumericPointwiseOperators.addBy(Yd, R);
		
		// create the distorted image:
		// re-sample the original input image at the distorted image points (Xd,Yd) 
		// to create artificial distortion
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float distortedValue = InterpolationOperators.interpolateLinear(
						inputImage,
						Xd.getAtIndex(i, j) + halfWidth - 0.5f, // remember: coordinate origin was set to image center
						Yd.getAtIndex(i, j) + halfHeight - 0.5f);
				grid.setAtIndex(i, j, distortedValue);
			}
		}

		xprime = X;
		yprime = Y;
		x = Xd;
		y = Yd;
		
		return grid;	
	}	
	
	//getters for members
	// variables which are checked (DO NOT CHANGE!)
	
	public static int get_caseNo() {
		return caseNo;
	}
	
	public Grid2D get_originalImage() {
		return originalImage;
	}
	
	public Grid2D get_distortedImage() {
		return distortedImage;
	}
	
	public Grid2D get_undistortedImage() {
		return undistortedImage;
	}
	
	public int get_nx() {
		return nx;
	}
	
	public int get_ny() {
		return ny;
	}
	
	public float get_fx() {
		return fx;
	}
	
	public float get_fy() {
		return fy;
	}
	
	public SimpleMatrix get_Xu() {
		return Xu;
	}
	
	public SimpleMatrix get_Yu() {
		return Yu;
	}
	
	public SimpleMatrix get_Xd() {
		return Xd;
	}
	
	public SimpleMatrix get_Yd() {
		return Yd;
	}
	
	public int get_numCoeff() {
		return numCoeff;
	}
	
	public int get_numCorresp() {
		return numCorresp;
	}
	
	public SimpleMatrix get_A() {
		return A;
	}
	
	public DecompositionSVD get_svd() {
		return svd;
	}
	
	public SimpleMatrix get_A_pseudoinverse() {
		return A_pseudoinverse;
	}
	
	public SimpleVector get_u_vec() {
		return u_vec;
	}
	
	public SimpleVector get_v_vec() {
		return v_vec;
	}
	
	public SimpleVector get_XuVector() {
		return XuVector;
	}
	
	public SimpleVector get_YuVector() {
		return YuVector;
	}
	
	public SimpleVector get_XdVector() {
		return XdVector;
	}
	
	public SimpleVector get_YdVector() {
		return YdVector;
	}
	
	public Grid2D get_xDist() {
		return xDist;
	}
	
	public Grid2D get_yDist() {
		return yDist;
	}
	
	public Grid2D get_xprime() {
		return xprime;
	}
	
	public Grid2D get_yprime() {
		return yprime;
	}
	
	public Grid2D get_x() {
		return x;
	}
	
	public Grid2D get_y() {
		return y;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-15 23:57:47.064
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-15 23:57:47.065
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-15 23:57:48.575
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package edu.stanford.rsl.tutorial.mipda;

import edu.stanford.rsl.conrad.data.numeric.Grid2D;
import edu.stanford.rsl.conrad.data.numeric.NumericPointwiseOperators;
import edu.stanford.rsl.conrad.utils.ImageUtil;
//import edu.stanford.rsl.conrad.utils.VisualizationUtil;
import ij.IJ;
import ij.ImageJ;
import edu.stanford.rsl.conrad.data.numeric.InterpolationOperators;
//import edu.stanford.rsl.conrad.data.numeric.NumericGridOperator;
import edu.stanford.rsl.conrad.numerics.SimpleMatrix;
import edu.stanford.rsl.conrad.numerics.SimpleOperators;
import edu.stanford.rsl.conrad.numerics.SimpleVector;
import edu.stanford.rsl.conrad.numerics.DecompositionSVD;

/**
 * Geometric Undistortion
 * Programming exercise 1 for module "Defect Pixel Interpolation"
 * of the course "Medical Image Processing for Diagnostic Applications (MIPDA)"
 * @author Frank Schebesch, Ashwini Jadhav, Anna Gebhard, Mena Abdelmalek
 *
 */

public class ExerciseGeoU {

	final static int caseNo = 1; // choose 0, 1, or 2 for different test images

	final static float a = 0.6f; // a: spread among x-direction
	final static float b = 0.3f; // b: spread among y-direction
	final static float d = 5.0f; // d: d/2 value of distortion field at level set for (X/a)^2+(Y/b)^2=1
	
	String filename; // do not edit, choose a number in the main method instead
	Grid2D originalImage; // do not edit, read from filename when instantiating the object
	Grid2D distortedImage; // do not edit, generated in the main method
	Grid2D undistortedImage; // do not edit, member variable for the output image
	
	// number of lattice points
	final int nx = 8;//TODO: define the number of lattice point: nx (Positive number and less than 20)
	final int ny = 8;//TODO: define the number of lattice point: ny (Positive number and less than 20)
	
	float fx;
	float fy;
	SimpleMatrix Xu; 
	SimpleMatrix Yu;
	SimpleMatrix Xd;
	SimpleMatrix Yd;
	int numCoeff; 
	int numCorresp; 
	SimpleMatrix A;
	DecompositionSVD svd;
	SimpleMatrix A_pseudoinverse;
	SimpleVector u_vec;
	SimpleVector v_vec;
	SimpleVector XuVector;
	SimpleVector YuVector;
	SimpleVector XdVector;
	SimpleVector YdVector;
	Grid2D xDist;  
	Grid2D yDist;
	Grid2D xprime; // x-coordinates of point correspondences in the undistorted image
	Grid2D yprime; // y-coordinates of point correspondences in the undistorted image
	Grid2D x; // x-coordinates of point correspondences in the distorted image
	Grid2D y; // y-coordinates of point correspondences in the distorted image
	
	
	/** 
	 * main method
	 * Here you can choose the image, and set the distortion parameters
	 */
	public static void main(String[] args) {
		
		new ImageJ();
		
		// generate distorted image
		ExerciseGeoU exObj = new ExerciseGeoU(caseNo);
		exObj.init(a,b,d);
		
		// TASK: go to the method doImageUndistortion(...) and complete it 
		exObj.undistortedImage = exObj.doImageUndistortion(exObj.distortedImage);
		
		exObj.originalImage.show("Original Image");
		exObj.distortedImage.show("Distorted Image");
		exObj.undistortedImage.show("Undistorted Image");
		
		Grid2D differenceImage = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.originalImage, exObj.undistortedImage);
		
		differenceImage.show("Difference Original vs. Undistorted");
		
		Grid2D distortedVSundistorted = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.undistortedImage, exObj.distortedImage);
		
		distortedVSundistorted.show("Difference Undistorted vs. Distorted");
	}
	
	public Grid2D doImageUndistortion(Grid2D distortedImage){
		
		Grid2D grid = new Grid2D(distortedImage);
		
		// check if image distortion routine has been run
		if (distortedImage == null || undistortedImage == null
				|| xprime == null || yprime == null
				|| x == null || y == null) {
			
			System.err.println("Error in doImageUndistortion(): called before initialization of members.");
			return grid;
		}
		
		
		getLatticePoints(distortedImage);// There are TODOs here 
		
		
		int degree = 5; // polynomial's degree: 2,...,10
		calcPolynomial(degree, Xd);// There are TODOs here
		
		
		
		computeMatrixA(degree, numCorresp, numCoeff);// There are TODOs here
		
		
		computeDistortionCoeff(A, XuVector, YuVector);// There are TODOs here
		
		
		grid = computeDistortedGrid(distortedImage, grid, degree);// There are TODOs here
		
		return grid;
	}
	
	
	
	/** 1. Number of lattice points (this only works for symmetric images):
	 *  nx, ny feature points: usually provided by tracking point
	 *  correspondences in the phantom during the calibration step.
	 *  Here, we use the distorted and undistorted coordinates generated
	 *  in the course of the distortion simulation.
	 */ 
	public void getLatticePoints (Grid2D distortedImage){
		
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		// step size
		// calculate the step size of the lattice points: fx and fy 
		fx = imageWidth/nx; //TODO
		fy = imageHeight/ny; //TODO
		
		// fill the distorted and undistorted lattice points 
		// with data from the given correspondences
		// matrix = number of rows (y) x number of columns (x)
		Xu = new SimpleMatrix(ny,nx);
		Yu = new SimpleMatrix(ny,nx);
		Xd = new SimpleMatrix(ny,nx);
		Yd = new SimpleMatrix(ny,nx);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){

				// sample the distorted and undistorted grid points at the lattice points
				  Xu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx), j + int(fy)));//TODO: fill matrix Xu
				  Yu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx), j + int(fy));//TODO: fill matrix Yu
				  Xd.setElementValue(i, j, fx);//TODO: fill matrix Xd
				  Yd.setElementValue(i, j, fy)//TODO: fill matrix Yd
			}
		}
	}
	
	/** 2. Polynomial of degree d
	 * Polynomial of degree d -> (d-1): extrema (e.g., d=5: 4 extrema)
	 * d=0: constant (horizontal line with y-intercept a_0 -> f(x)=a_0)
	 * d=1: oblique line with y-intercept a_0 & slope a_1 -> f(x)=a_0 + a_1 x
	 * d=2: parabola
	 * d>=2: continuous non-linear curve
	 * ...
	 * d = 10 -> NumCoeff: 66 -> but only 64 lattice points are known (nx, ny = 8)
	 */
	
	public void calcPolynomial(int degree, SimpleMatrix Xd){
		
		// number of coefficients: numCoeff
		// (hint: this is NOT the total number of multiplications!)
		numCoeff = 0; //TODO
		
		// number of correspondences: numCorresp
		numCorresp =  0; //TODO
		
		// Printout of the used parameters
		System.out.println("Polynom of degree: " + degree);
		System.out.println("Number of Coefficients: " + numCoeff);
		System.out.println("Number of Correspondences: " + numCorresp);
		
	}
	
	/**
	 * 3. Create the matrix A
	 */
	
	public void computeMatrixA(int degree, int numCorresp, int numCoeff){
		
		A = new SimpleMatrix(numCorresp, numCoeff);
		if (numCorresp <= 0 && numCoeff <= 0)
			return;
		A.zeros();
		
		// Realign the grid matrix into a vector for easier access in the next step
		XuVector = new SimpleVector(numCorresp);
		YuVector = new SimpleVector(numCorresp);
		XdVector = new SimpleVector(numCorresp);
		YdVector = new SimpleVector(numCorresp);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){
				
				XuVector.setElementValue(i*ny + j, Xu.getElement(j, i));
				YuVector.setElementValue(i*ny + j, Yu.getElement(j, i));
				XdVector.setElementValue(i*ny + j, Xd.getElement(j, i));
				YdVector.setElementValue(i*ny + j, Yd.getElement(j, i));
			}
		}
		
		// Compute matrix A (coordinates from distorted image)
		for(int r = 0; r < numCorresp; r++){
			
			int cc = 0;
			
			for(int k = 0; k <= degree; k++){
				for(int l = 0; l <= (degree-k); l++){
					
					// TODO: fill matrix A
					cc++;
					
				}
			}
		}
	}
	
	public void computeDistortionCoeff(SimpleMatrix A, SimpleVector XuVector, SimpleVector YuVector){
		
		// Compute the pseudo-inverse of A with the help of the SVD (class: DecompositionSVD)
		svd = null; // TODO
	    A_pseudoinverse = null; // TODO
	  
		// Compute the distortion coefficients (solve for known corresponding undistorted points)
		u_vec = null;// TODO
		v_vec = null;// TODO
	}
	
	/**
	 * 4. Compute the distorted grid points (xDist, yDist) which are used to sample the
	 * distorted image to get the undistorted image
	 * (xprime,yprime) is the position in the undistorted image
	 * (xDist,yDist) is the position in the distorted (observed) X-ray image.
	 */
	public Grid2D computeDistortedGrid(Grid2D distortedImage, Grid2D grid_out, int degree){
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		xDist = new Grid2D(imageWidth,imageHeight);  
		yDist = new Grid2D(imageWidth,imageHeight); 
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float val1, val2; //variables Val1 and Val2 are used for intermediate computation of xDist and yDist respectively
				
				int cc = 0;
				
				for(int k = 0; k <= degree; k++){
					for(int l = 0; l <= degree - k; l++){
						
						val1 = 0;// TODO
						val2 = 0;// TODO
						
						// TODO: fill xDist
						// TODO: fill yDist
						
						cc++;
					}
				}
			}
		}
		
		float val; // variable for intermediate computations of undistorted image
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				// hint: consider the fact that the coordinate origin is in the center of the image
				val = 0;//TODO
				//TODO: fill grid_out
			}
		}
		
		return grid_out;
		
	}
	
	
	
	/**
	 * 
	 * end of the exercise
	 */	

	
	/**
	 * standard constructor
	 */
	public ExerciseGeoU(){
		
		this(0);
	}
		
	/**
	 * parameterized constructor for the ExerciseDPI object
	 * @param caseNo: select one of three images to test your undistortion method
	 */
	public ExerciseGeoU(int caseNo){
		
		switch (caseNo) {
		case 0:
			filename = "frame32.jpg";
			break;
		case 1:
			filename = "undistorted.jpg";
			break;
		case 2:
			filename = "frame90.jpg";
			break;
		default:
			filename = "frame32.jpg";
			break;
		}
		
		String imageDataLoc = System.getProperty("user.dir") + "/data/" + "/mipda/";
	
		originalImage = ImageUtil.wrapImagePlus(IJ.openImage(imageDataLoc + filename)).getSubGrid(0);
	}
	
	public void init(float a, float b, float d) {
		
		// Normalize intensity values to [0,1]
		float max = NumericPointwiseOperators.max(originalImage);
		float min = NumericPointwiseOperators.min(originalImage);
		
		for(int i = 0; i < originalImage.getWidth(); i++){
			for(int j = 0; j < originalImage.getHeight(); j++){
				
				float scaledValue = (originalImage.getAtIndex(i, j) - min) / (max-min);
				originalImage.setAtIndex(i, j, scaledValue);
			}
		}
		
		undistortedImage = new Grid2D(originalImage.getWidth(),originalImage.getHeight()); // initialization with zeros
		
		distortedImage = generateDistortedImage(originalImage,a,b,d);	
	}
	
	/**
	 * method to generate a distorted image
	 * An artificial distortion field is generated. With this field, 
	 * a distorted image is generated from the original image.
	 * Remark: coordinates of the latest distortion simulated are saved in class member variables
	 * @param inputImage: undistorted image on which distortion is simulated
	 * @param a: elliptic extent of the distortion in x-direction
	 * @param b: elliptic extent of the distortion in y-direction
	 * @param d: strength of the distortion
	 * @return: distorted image
	 */
    
	public Grid2D generateDistortedImage(Grid2D inputImage, float a, float b, float d){

		Grid2D grid = new Grid2D(inputImage);
		int imageWidth = grid.getWidth();
		int imageHeight = grid.getHeight();
		
		// generate grids to sample coordinates X and Y of the original image
		Grid2D X = new Grid2D(imageWidth,imageHeight); // x-coordinates with respect to origin in image center, spacing = 1 [unit]
		Grid2D Y = new Grid2D(imageWidth,imageHeight); // y-coordinates with respect to origin in image center, spacing = 1 [unit]
		
		float halfWidth = imageWidth / 2.0f;
		float halfHeight = imageHeight / 2.0f;
		
		for(int i = 0; i < X.getWidth(); i++){
			for(int j = 0; j < X.getHeight(); j++){
				
				X.setAtIndex(i, j, i - halfWidth + 0.5f); // assign pixel centers in x-direction
				Y.setAtIndex(i, j, j - halfHeight + 0.5f); // assign pixel center in y-direction
			}
		}
		
		// create an artificial elliptical distortion field R (additive field)
		Grid2D R = new Grid2D(imageWidth,imageHeight);

		for(int i = 0; i < R.getWidth(); i++){
			for(int j = 0; j < R.getHeight(); j++){
				
				// distortion gets stronger with the distance from the image center
				float r = d * (float)(Math.sqrt(
						Math.pow(X.getAtIndex(i, j)/(a*halfWidth),2)
						+ Math.pow(Y.getAtIndex(i, j)/(b*halfHeight),2)));
				R.setAtIndex(i, j, r);
			}
		}
		
		// shifting the positive range to half positive/half negative range
		float maxR = NumericPointwiseOperators.max(R);
		NumericPointwiseOperators.subtractBy(R, maxR * 0.5f);

		// create the distorted image coordinates:
		// distorted image coordinates = undistorted image points + artificial distortion field

		// distorted image coordinates Xd, Yd
		Grid2D Xd = new Grid2D(X);
		Grid2D Yd = new Grid2D(Y);
		
		NumericPointwiseOperators.addBy(Xd, R);
		NumericPointwiseOperators.addBy(Yd, R);
		
		// create the distorted image:
		// re-sample the original input image at the distorted image points (Xd,Yd) 
		// to create artificial distortion
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float distortedValue = InterpolationOperators.interpolateLinear(
						inputImage,
						Xd.getAtIndex(i, j) + halfWidth - 0.5f, // remember: coordinate origin was set to image center
						Yd.getAtIndex(i, j) + halfHeight - 0.5f);
				grid.setAtIndex(i, j, distortedValue);
			}
		}

		xprime = X;
		yprime = Y;
		x = Xd;
		y = Yd;
		
		return grid;	
	}	
	
	//getters for members
	// variables which are checked (DO NOT CHANGE!)
	
	public static int get_caseNo() {
		return caseNo;
	}
	
	public Grid2D get_originalImage() {
		return originalImage;
	}
	
	public Grid2D get_distortedImage() {
		return distortedImage;
	}
	
	public Grid2D get_undistortedImage() {
		return undistortedImage;
	}
	
	public int get_nx() {
		return nx;
	}
	
	public int get_ny() {
		return ny;
	}
	
	public float get_fx() {
		return fx;
	}
	
	public float get_fy() {
		return fy;
	}
	
	public SimpleMatrix get_Xu() {
		return Xu;
	}
	
	public SimpleMatrix get_Yu() {
		return Yu;
	}
	
	public SimpleMatrix get_Xd() {
		return Xd;
	}
	
	public SimpleMatrix get_Yd() {
		return Yd;
	}
	
	public int get_numCoeff() {
		return numCoeff;
	}
	
	public int get_numCorresp() {
		return numCorresp;
	}
	
	public SimpleMatrix get_A() {
		return A;
	}
	
	public DecompositionSVD get_svd() {
		return svd;
	}
	
	public SimpleMatrix get_A_pseudoinverse() {
		return A_pseudoinverse;
	}
	
	public SimpleVector get_u_vec() {
		return u_vec;
	}
	
	public SimpleVector get_v_vec() {
		return v_vec;
	}
	
	public SimpleVector get_XuVector() {
		return XuVector;
	}
	
	public SimpleVector get_YuVector() {
		return YuVector;
	}
	
	public SimpleVector get_XdVector() {
		return XdVector;
	}
	
	public SimpleVector get_YdVector() {
		return YdVector;
	}
	
	public Grid2D get_xDist() {
		return xDist;
	}
	
	public Grid2D get_yDist() {
		return yDist;
	}
	
	public Grid2D get_xprime() {
		return xprime;
	}
	
	public Grid2D get_yprime() {
		return yprime;
	}
	
	public Grid2D get_x() {
		return x;
	}
	
	public Grid2D get_y() {
		return y;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-15 23:57:48.576
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-15 23:57:48.577
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2490)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2045)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-15 23:57:52.077
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package edu.stanford.rsl.tutorial.mipda;

import edu.stanford.rsl.conrad.data.numeric.Grid2D;
import edu.stanford.rsl.conrad.data.numeric.NumericPointwiseOperators;
import edu.stanford.rsl.conrad.utils.ImageUtil;
//import edu.stanford.rsl.conrad.utils.VisualizationUtil;
import ij.IJ;
import ij.ImageJ;
import edu.stanford.rsl.conrad.data.numeric.InterpolationOperators;
//import edu.stanford.rsl.conrad.data.numeric.NumericGridOperator;
import edu.stanford.rsl.conrad.numerics.SimpleMatrix;
import edu.stanford.rsl.conrad.numerics.SimpleOperators;
import edu.stanford.rsl.conrad.numerics.SimpleVector;
import edu.stanford.rsl.conrad.numerics.DecompositionSVD;

/**
 * Geometric Undistortion
 * Programming exercise 1 for module "Defect Pixel Interpolation"
 * of the course "Medical Image Processing for Diagnostic Applications (MIPDA)"
 * @author Frank Schebesch, Ashwini Jadhav, Anna Gebhard, Mena Abdelmalek
 *
 */

public class ExerciseGeoU {

	final static int caseNo = 1; // choose 0, 1, or 2 for different test images

	final static float a = 0.6f; // a: spread among x-direction
	final static float b = 0.3f; // b: spread among y-direction
	final static float d = 5.0f; // d: d/2 value of distortion field at level set for (X/a)^2+(Y/b)^2=1
	
	String filename; // do not edit, choose a number in the main method instead
	Grid2D originalImage; // do not edit, read from filename when instantiating the object
	Grid2D distortedImage; // do not edit, generated in the main method
	Grid2D undistortedImage; // do not edit, member variable for the output image
	
	// number of lattice points
	final int nx = 8;//TODO: define the number of lattice point: nx (Positive number and less than 20)
	final int ny = 8;//TODO: define the number of lattice point: ny (Positive number and less than 20)
	
	float fx;
	float fy;
	SimpleMatrix Xu; 
	SimpleMatrix Yu;
	SimpleMatrix Xd;
	SimpleMatrix Yd;
	int numCoeff; 
	int numCorresp; 
	SimpleMatrix A;
	DecompositionSVD svd;
	SimpleMatrix A_pseudoinverse;
	SimpleVector u_vec;
	SimpleVector v_vec;
	SimpleVector XuVector;
	SimpleVector YuVector;
	SimpleVector XdVector;
	SimpleVector YdVector;
	Grid2D xDist;  
	Grid2D yDist;
	Grid2D xprime; // x-coordinates of point correspondences in the undistorted image
	Grid2D yprime; // y-coordinates of point correspondences in the undistorted image
	Grid2D x; // x-coordinates of point correspondences in the distorted image
	Grid2D y; // y-coordinates of point correspondences in the distorted image
	
	
	/** 
	 * main method
	 * Here you can choose the image, and set the distortion parameters
	 */
	public static void main(String[] args) {
		
		new ImageJ();
		
		// generate distorted image
		ExerciseGeoU exObj = new ExerciseGeoU(caseNo);
		exObj.init(a,b,d);
		
		// TASK: go to the method doImageUndistortion(...) and complete it 
		exObj.undistortedImage = exObj.doImageUndistortion(exObj.distortedImage);
		
		exObj.originalImage.show("Original Image");
		exObj.distortedImage.show("Distorted Image");
		exObj.undistortedImage.show("Undistorted Image");
		
		Grid2D differenceImage = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.originalImage, exObj.undistortedImage);
		
		differenceImage.show("Difference Original vs. Undistorted");
		
		Grid2D distortedVSundistorted = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.undistortedImage, exObj.distortedImage);
		
		distortedVSundistorted.show("Difference Undistorted vs. Distorted");
	}
	
	public Grid2D doImageUndistortion(Grid2D distortedImage){
		
		Grid2D grid = new Grid2D(distortedImage);
		
		// check if image distortion routine has been run
		if (distortedImage == null || undistortedImage == null
				|| xprime == null || yprime == null
				|| x == null || y == null) {
			
			System.err.println("Error in doImageUndistortion(): called before initialization of members.");
			return grid;
		}
		
		
		getLatticePoints(distortedImage);// There are TODOs here 
		
		
		int degree = 5; // polynomial's degree: 2,...,10
		calcPolynomial(degree, Xd);// There are TODOs here
		
		
		
		computeMatrixA(degree, numCorresp, numCoeff);// There are TODOs here
		
		
		computeDistortionCoeff(A, XuVector, YuVector);// There are TODOs here
		
		
		grid = computeDistortedGrid(distortedImage, grid, degree);// There are TODOs here
		
		return grid;
	}
	
	
	
	/** 1. Number of lattice points (this only works for symmetric images):
	 *  nx, ny feature points: usually provided by tracking point
	 *  correspondences in the phantom during the calibration step.
	 *  Here, we use the distorted and undistorted coordinates generated
	 *  in the course of the distortion simulation.
	 */ 
	public void getLatticePoints (Grid2D distortedImage){
		
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		// step size
		// calculate the step size of the lattice points: fx and fy 
		fx = imageWidth/nx; //TODO
		fy = imageHeight/ny; //TODO
		
		// fill the distorted and undistorted lattice points 
		// with data from the given correspondences
		// matrix = number of rows (y) x number of columns (x)
		Xu = new SimpleMatrix(ny,nx);
		Yu = new SimpleMatrix(ny,nx);
		Xd = new SimpleMatrix(ny,nx);
		Yd = new SimpleMatrix(ny,nx);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){

				// sample the distorted and undistorted grid points at the lattice points
				  Xu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx), j + int(fy)))-;//TODO: fill matrix Xu
				  Yu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx), j + int(fy));//TODO: fill matrix Yu
				  Xd.setElementValue(i, j, fx);//TODO: fill matrix Xd
				  Yd.setElementValue(i, j, fy)//TODO: fill matrix Yd
			}
		}
	}
	
	/** 2. Polynomial of degree d
	 * Polynomial of degree d -> (d-1): extrema (e.g., d=5: 4 extrema)
	 * d=0: constant (horizontal line with y-intercept a_0 -> f(x)=a_0)
	 * d=1: oblique line with y-intercept a_0 & slope a_1 -> f(x)=a_0 + a_1 x
	 * d=2: parabola
	 * d>=2: continuous non-linear curve
	 * ...
	 * d = 10 -> NumCoeff: 66 -> but only 64 lattice points are known (nx, ny = 8)
	 */
	
	public void calcPolynomial(int degree, SimpleMatrix Xd){
		
		// number of coefficients: numCoeff
		// (hint: this is NOT the total number of multiplications!)
		numCoeff = 0; //TODO
		
		// number of correspondences: numCorresp
		numCorresp =  0; //TODO
		
		// Printout of the used parameters
		System.out.println("Polynom of degree: " + degree);
		System.out.println("Number of Coefficients: " + numCoeff);
		System.out.println("Number of Correspondences: " + numCorresp);
		
	}
	
	/**
	 * 3. Create the matrix A
	 */
	
	public void computeMatrixA(int degree, int numCorresp, int numCoeff){
		
		A = new SimpleMatrix(numCorresp, numCoeff);
		if (numCorresp <= 0 && numCoeff <= 0)
			return;
		A.zeros();
		
		// Realign the grid matrix into a vector for easier access in the next step
		XuVector = new SimpleVector(numCorresp);
		YuVector = new SimpleVector(numCorresp);
		XdVector = new SimpleVector(numCorresp);
		YdVector = new SimpleVector(numCorresp);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){
				
				XuVector.setElementValue(i*ny + j, Xu.getElement(j, i));
				YuVector.setElementValue(i*ny + j, Yu.getElement(j, i));
				XdVector.setElementValue(i*ny + j, Xd.getElement(j, i));
				YdVector.setElementValue(i*ny + j, Yd.getElement(j, i));
			}
		}
		
		// Compute matrix A (coordinates from distorted image)
		for(int r = 0; r < numCorresp; r++){
			
			int cc = 0;
			
			for(int k = 0; k <= degree; k++){
				for(int l = 0; l <= (degree-k); l++){
					
					// TODO: fill matrix A
					cc++;
					
				}
			}
		}
	}
	
	public void computeDistortionCoeff(SimpleMatrix A, SimpleVector XuVector, SimpleVector YuVector){
		
		// Compute the pseudo-inverse of A with the help of the SVD (class: DecompositionSVD)
		svd = null; // TODO
	    A_pseudoinverse = null; // TODO
	  
		// Compute the distortion coefficients (solve for known corresponding undistorted points)
		u_vec = null;// TODO
		v_vec = null;// TODO
	}
	
	/**
	 * 4. Compute the distorted grid points (xDist, yDist) which are used to sample the
	 * distorted image to get the undistorted image
	 * (xprime,yprime) is the position in the undistorted image
	 * (xDist,yDist) is the position in the distorted (observed) X-ray image.
	 */
	public Grid2D computeDistortedGrid(Grid2D distortedImage, Grid2D grid_out, int degree){
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		xDist = new Grid2D(imageWidth,imageHeight);  
		yDist = new Grid2D(imageWidth,imageHeight); 
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float val1, val2; //variables Val1 and Val2 are used for intermediate computation of xDist and yDist respectively
				
				int cc = 0;
				
				for(int k = 0; k <= degree; k++){
					for(int l = 0; l <= degree - k; l++){
						
						val1 = 0;// TODO
						val2 = 0;// TODO
						
						// TODO: fill xDist
						// TODO: fill yDist
						
						cc++;
					}
				}
			}
		}
		
		float val; // variable for intermediate computations of undistorted image
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				// hint: consider the fact that the coordinate origin is in the center of the image
				val = 0;//TODO
				//TODO: fill grid_out
			}
		}
		
		return grid_out;
		
	}
	
	
	
	/**
	 * 
	 * end of the exercise
	 */	

	
	/**
	 * standard constructor
	 */
	public ExerciseGeoU(){
		
		this(0);
	}
		
	/**
	 * parameterized constructor for the ExerciseDPI object
	 * @param caseNo: select one of three images to test your undistortion method
	 */
	public ExerciseGeoU(int caseNo){
		
		switch (caseNo) {
		case 0:
			filename = "frame32.jpg";
			break;
		case 1:
			filename = "undistorted.jpg";
			break;
		case 2:
			filename = "frame90.jpg";
			break;
		default:
			filename = "frame32.jpg";
			break;
		}
		
		String imageDataLoc = System.getProperty("user.dir") + "/data/" + "/mipda/";
	
		originalImage = ImageUtil.wrapImagePlus(IJ.openImage(imageDataLoc + filename)).getSubGrid(0);
	}
	
	public void init(float a, float b, float d) {
		
		// Normalize intensity values to [0,1]
		float max = NumericPointwiseOperators.max(originalImage);
		float min = NumericPointwiseOperators.min(originalImage);
		
		for(int i = 0; i < originalImage.getWidth(); i++){
			for(int j = 0; j < originalImage.getHeight(); j++){
				
				float scaledValue = (originalImage.getAtIndex(i, j) - min) / (max-min);
				originalImage.setAtIndex(i, j, scaledValue);
			}
		}
		
		undistortedImage = new Grid2D(originalImage.getWidth(),originalImage.getHeight()); // initialization with zeros
		
		distortedImage = generateDistortedImage(originalImage,a,b,d);	
	}
	
	/**
	 * method to generate a distorted image
	 * An artificial distortion field is generated. With this field, 
	 * a distorted image is generated from the original image.
	 * Remark: coordinates of the latest distortion simulated are saved in class member variables
	 * @param inputImage: undistorted image on which distortion is simulated
	 * @param a: elliptic extent of the distortion in x-direction
	 * @param b: elliptic extent of the distortion in y-direction
	 * @param d: strength of the distortion
	 * @return: distorted image
	 */
    
	public Grid2D generateDistortedImage(Grid2D inputImage, float a, float b, float d){

		Grid2D grid = new Grid2D(inputImage);
		int imageWidth = grid.getWidth();
		int imageHeight = grid.getHeight();
		
		// generate grids to sample coordinates X and Y of the original image
		Grid2D X = new Grid2D(imageWidth,imageHeight); // x-coordinates with respect to origin in image center, spacing = 1 [unit]
		Grid2D Y = new Grid2D(imageWidth,imageHeight); // y-coordinates with respect to origin in image center, spacing = 1 [unit]
		
		float halfWidth = imageWidth / 2.0f;
		float halfHeight = imageHeight / 2.0f;
		
		for(int i = 0; i < X.getWidth(); i++){
			for(int j = 0; j < X.getHeight(); j++){
				
				X.setAtIndex(i, j, i - halfWidth + 0.5f); // assign pixel centers in x-direction
				Y.setAtIndex(i, j, j - halfHeight + 0.5f); // assign pixel center in y-direction
			}
		}
		
		// create an artificial elliptical distortion field R (additive field)
		Grid2D R = new Grid2D(imageWidth,imageHeight);

		for(int i = 0; i < R.getWidth(); i++){
			for(int j = 0; j < R.getHeight(); j++){
				
				// distortion gets stronger with the distance from the image center
				float r = d * (float)(Math.sqrt(
						Math.pow(X.getAtIndex(i, j)/(a*halfWidth),2)
						+ Math.pow(Y.getAtIndex(i, j)/(b*halfHeight),2)));
				R.setAtIndex(i, j, r);
			}
		}
		
		// shifting the positive range to half positive/half negative range
		float maxR = NumericPointwiseOperators.max(R);
		NumericPointwiseOperators.subtractBy(R, maxR * 0.5f);

		// create the distorted image coordinates:
		// distorted image coordinates = undistorted image points + artificial distortion field

		// distorted image coordinates Xd, Yd
		Grid2D Xd = new Grid2D(X);
		Grid2D Yd = new Grid2D(Y);
		
		NumericPointwiseOperators.addBy(Xd, R);
		NumericPointwiseOperators.addBy(Yd, R);
		
		// create the distorted image:
		// re-sample the original input image at the distorted image points (Xd,Yd) 
		// to create artificial distortion
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float distortedValue = InterpolationOperators.interpolateLinear(
						inputImage,
						Xd.getAtIndex(i, j) + halfWidth - 0.5f, // remember: coordinate origin was set to image center
						Yd.getAtIndex(i, j) + halfHeight - 0.5f);
				grid.setAtIndex(i, j, distortedValue);
			}
		}

		xprime = X;
		yprime = Y;
		x = Xd;
		y = Yd;
		
		return grid;	
	}	
	
	//getters for members
	// variables which are checked (DO NOT CHANGE!)
	
	public static int get_caseNo() {
		return caseNo;
	}
	
	public Grid2D get_originalImage() {
		return originalImage;
	}
	
	public Grid2D get_distortedImage() {
		return distortedImage;
	}
	
	public Grid2D get_undistortedImage() {
		return undistortedImage;
	}
	
	public int get_nx() {
		return nx;
	}
	
	public int get_ny() {
		return ny;
	}
	
	public float get_fx() {
		return fx;
	}
	
	public float get_fy() {
		return fy;
	}
	
	public SimpleMatrix get_Xu() {
		return Xu;
	}
	
	public SimpleMatrix get_Yu() {
		return Yu;
	}
	
	public SimpleMatrix get_Xd() {
		return Xd;
	}
	
	public SimpleMatrix get_Yd() {
		return Yd;
	}
	
	public int get_numCoeff() {
		return numCoeff;
	}
	
	public int get_numCorresp() {
		return numCorresp;
	}
	
	public SimpleMatrix get_A() {
		return A;
	}
	
	public DecompositionSVD get_svd() {
		return svd;
	}
	
	public SimpleMatrix get_A_pseudoinverse() {
		return A_pseudoinverse;
	}
	
	public SimpleVector get_u_vec() {
		return u_vec;
	}
	
	public SimpleVector get_v_vec() {
		return v_vec;
	}
	
	public SimpleVector get_XuVector() {
		return XuVector;
	}
	
	public SimpleVector get_YuVector() {
		return YuVector;
	}
	
	public SimpleVector get_XdVector() {
		return XdVector;
	}
	
	public SimpleVector get_YdVector() {
		return YdVector;
	}
	
	public Grid2D get_xDist() {
		return xDist;
	}
	
	public Grid2D get_yDist() {
		return yDist;
	}
	
	public Grid2D get_xprime() {
		return xprime;
	}
	
	public Grid2D get_yprime() {
		return yprime;
	}
	
	public Grid2D get_x() {
		return x;
	}
	
	public Grid2D get_y() {
		return y;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-15 23:57:52.078
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-15 23:57:52.079
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-15 23:57:52.097
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package edu.stanford.rsl.tutorial.mipda;

import edu.stanford.rsl.conrad.data.numeric.Grid2D;
import edu.stanford.rsl.conrad.data.numeric.NumericPointwiseOperators;
import edu.stanford.rsl.conrad.utils.ImageUtil;
//import edu.stanford.rsl.conrad.utils.VisualizationUtil;
import ij.IJ;
import ij.ImageJ;
import edu.stanford.rsl.conrad.data.numeric.InterpolationOperators;
//import edu.stanford.rsl.conrad.data.numeric.NumericGridOperator;
import edu.stanford.rsl.conrad.numerics.SimpleMatrix;
import edu.stanford.rsl.conrad.numerics.SimpleOperators;
import edu.stanford.rsl.conrad.numerics.SimpleVector;
import edu.stanford.rsl.conrad.numerics.DecompositionSVD;

/**
 * Geometric Undistortion
 * Programming exercise 1 for module "Defect Pixel Interpolation"
 * of the course "Medical Image Processing for Diagnostic Applications (MIPDA)"
 * @author Frank Schebesch, Ashwini Jadhav, Anna Gebhard, Mena Abdelmalek
 *
 */

public class ExerciseGeoU {

	final static int caseNo = 1; // choose 0, 1, or 2 for different test images

	final static float a = 0.6f; // a: spread among x-direction
	final static float b = 0.3f; // b: spread among y-direction
	final static float d = 5.0f; // d: d/2 value of distortion field at level set for (X/a)^2+(Y/b)^2=1
	
	String filename; // do not edit, choose a number in the main method instead
	Grid2D originalImage; // do not edit, read from filename when instantiating the object
	Grid2D distortedImage; // do not edit, generated in the main method
	Grid2D undistortedImage; // do not edit, member variable for the output image
	
	// number of lattice points
	final int nx = 8;//TODO: define the number of lattice point: nx (Positive number and less than 20)
	final int ny = 8;//TODO: define the number of lattice point: ny (Positive number and less than 20)
	
	float fx;
	float fy;
	SimpleMatrix Xu; 
	SimpleMatrix Yu;
	SimpleMatrix Xd;
	SimpleMatrix Yd;
	int numCoeff; 
	int numCorresp; 
	SimpleMatrix A;
	DecompositionSVD svd;
	SimpleMatrix A_pseudoinverse;
	SimpleVector u_vec;
	SimpleVector v_vec;
	SimpleVector XuVector;
	SimpleVector YuVector;
	SimpleVector XdVector;
	SimpleVector YdVector;
	Grid2D xDist;  
	Grid2D yDist;
	Grid2D xprime; // x-coordinates of point correspondences in the undistorted image
	Grid2D yprime; // y-coordinates of point correspondences in the undistorted image
	Grid2D x; // x-coordinates of point correspondences in the distorted image
	Grid2D y; // y-coordinates of point correspondences in the distorted image
	
	
	/** 
	 * main method
	 * Here you can choose the image, and set the distortion parameters
	 */
	public static void main(String[] args) {
		
		new ImageJ();
		
		// generate distorted image
		ExerciseGeoU exObj = new ExerciseGeoU(caseNo);
		exObj.init(a,b,d);
		
		// TASK: go to the method doImageUndistortion(...) and complete it 
		exObj.undistortedImage = exObj.doImageUndistortion(exObj.distortedImage);
		
		exObj.originalImage.show("Original Image");
		exObj.distortedImage.show("Distorted Image");
		exObj.undistortedImage.show("Undistorted Image");
		
		Grid2D differenceImage = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.originalImage, exObj.undistortedImage);
		
		differenceImage.show("Difference Original vs. Undistorted");
		
		Grid2D distortedVSundistorted = (Grid2D) NumericPointwiseOperators.subtractedBy(
				exObj.undistortedImage, exObj.distortedImage);
		
		distortedVSundistorted.show("Difference Undistorted vs. Distorted");
	}
	
	public Grid2D doImageUndistortion(Grid2D distortedImage){
		
		Grid2D grid = new Grid2D(distortedImage);
		
		// check if image distortion routine has been run
		if (distortedImage == null || undistortedImage == null
				|| xprime == null || yprime == null
				|| x == null || y == null) {
			
			System.err.println("Error in doImageUndistortion(): called before initialization of members.");
			return grid;
		}
		
		
		getLatticePoints(distortedImage);// There are TODOs here 
		
		
		int degree = 5; // polynomial's degree: 2,...,10
		calcPolynomial(degree, Xd);// There are TODOs here
		
		
		
		computeMatrixA(degree, numCorresp, numCoeff);// There are TODOs here
		
		
		computeDistortionCoeff(A, XuVector, YuVector);// There are TODOs here
		
		
		grid = computeDistortedGrid(distortedImage, grid, degree);// There are TODOs here
		
		return grid;
	}
	
	
	
	/** 1. Number of lattice points (this only works for symmetric images):
	 *  nx, ny feature points: usually provided by tracking point
	 *  correspondences in the phantom during the calibration step.
	 *  Here, we use the distorted and undistorted coordinates generated
	 *  in the course of the distortion simulation.
	 */ 
	public void getLatticePoints (Grid2D distortedImage){
		
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		// step size
		// calculate the step size of the lattice points: fx and fy 
		fx = imageWidth/nx; //TODO
		fy = imageHeight/ny; //TODO
		
		// fill the distorted and undistorted lattice points 
		// with data from the given correspondences
		// matrix = number of rows (y) x number of columns (x)
		Xu = new SimpleMatrix(ny,nx);
		Yu = new SimpleMatrix(ny,nx);
		Xd = new SimpleMatrix(ny,nx);
		Yd = new SimpleMatrix(ny,nx);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){

				// sample the distorted and undistorted grid points at the lattice points
				  Xu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx), j + int(fy)))-;//TODO: fill matrix Xu
				  Yu.setElementValue(i, j, double(xprime.getAtIndex(i + int(fx), j + int(fy));//TODO: fill matrix Yu
				  Xd.setElementValue(i, j, fx);//TODO: fill matrix Xd
				  Yd.setElementValue(i, j, fy)//TODO: fill matrix Yd
			}
		}
	}
	
	/** 2. Polynomial of degree d
	 * Polynomial of degree d -> (d-1): extrema (e.g., d=5: 4 extrema)
	 * d=0: constant (horizontal line with y-intercept a_0 -> f(x)=a_0)
	 * d=1: oblique line with y-intercept a_0 & slope a_1 -> f(x)=a_0 + a_1 x
	 * d=2: parabola
	 * d>=2: continuous non-linear curve
	 * ...
	 * d = 10 -> NumCoeff: 66 -> but only 64 lattice points are known (nx, ny = 8)
	 */
	
	public void calcPolynomial(int degree, SimpleMatrix Xd){
		
		// number of coefficients: numCoeff
		// (hint: this is NOT the total number of multiplications!)
		numCoeff = 0; //TODO
		
		// number of correspondences: numCorresp
		numCorresp =  0; //TODO
		
		// Printout of the used parameters
		System.out.println("Polynom of degree: " + degree);
		System.out.println("Number of Coefficients: " + numCoeff);
		System.out.println("Number of Correspondences: " + numCorresp);
		
	}
	
	/**
	 * 3. Create the matrix A
	 */
	
	public void computeMatrixA(int degree, int numCorresp, int numCoeff){
		
		A = new SimpleMatrix(numCorresp, numCoeff);
		if (numCorresp <= 0 && numCoeff <= 0)
			return;
		A.zeros();
		
		// Realign the grid matrix into a vector for easier access in the next step
		XuVector = new SimpleVector(numCorresp);
		YuVector = new SimpleVector(numCorresp);
		XdVector = new SimpleVector(numCorresp);
		YdVector = new SimpleVector(numCorresp);
		
		for(int i = 0; i < nx; i++){
			for(int j = 0; j < ny; j++){
				
				XuVector.setElementValue(i*ny + j, Xu.getElement(j, i));
				YuVector.setElementValue(i*ny + j, Yu.getElement(j, i));
				XdVector.setElementValue(i*ny + j, Xd.getElement(j, i));
				YdVector.setElementValue(i*ny + j, Yd.getElement(j, i));
			}
		}
		
		// Compute matrix A (coordinates from distorted image)
		for(int r = 0; r < numCorresp; r++){
			
			int cc = 0;
			
			for(int k = 0; k <= degree; k++){
				for(int l = 0; l <= (degree-k); l++){
					
					// TODO: fill matrix A
					cc++;
					
				}
			}
		}
	}
	
	public void computeDistortionCoeff(SimpleMatrix A, SimpleVector XuVector, SimpleVector YuVector){
		
		// Compute the pseudo-inverse of A with the help of the SVD (class: DecompositionSVD)
		svd = null; // TODO
	    A_pseudoinverse = null; // TODO
	  
		// Compute the distortion coefficients (solve for known corresponding undistorted points)
		u_vec = null;// TODO
		v_vec = null;// TODO
	}
	
	/**
	 * 4. Compute the distorted grid points (xDist, yDist) which are used to sample the
	 * distorted image to get the undistorted image
	 * (xprime,yprime) is the position in the undistorted image
	 * (xDist,yDist) is the position in the distorted (observed) X-ray image.
	 */
	public Grid2D computeDistortedGrid(Grid2D distortedImage, Grid2D grid_out, int degree){
		
		int imageWidth = distortedImage.getWidth();
		int imageHeight = distortedImage.getHeight();
		
		xDist = new Grid2D(imageWidth,imageHeight);  
		yDist = new Grid2D(imageWidth,imageHeight); 
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float val1, val2; //variables Val1 and Val2 are used for intermediate computation of xDist and yDist respectively
				
				int cc = 0;
				
				for(int k = 0; k <= degree; k++){
					for(int l = 0; l <= degree - k; l++){
						
						val1 = 0;// TODO
						val2 = 0;// TODO
						
						// TODO: fill xDist
						// TODO: fill yDist
						
						cc++;
					}
				}
			}
		}
		
		float val; // variable for intermediate computations of undistorted image
		
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				// hint: consider the fact that the coordinate origin is in the center of the image
				val = 0;//TODO
				//TODO: fill grid_out
			}
		}
		
		return grid_out;
		
	}
	
	
	
	/**
	 * 
	 * end of the exercise
	 */	

	
	/**
	 * standard constructor
	 */
	public ExerciseGeoU(){
		
		this(0);
	}
		
	/**
	 * parameterized constructor for the ExerciseDPI object
	 * @param caseNo: select one of three images to test your undistortion method
	 */
	public ExerciseGeoU(int caseNo){
		
		switch (caseNo) {
		case 0:
			filename = "frame32.jpg";
			break;
		case 1:
			filename = "undistorted.jpg";
			break;
		case 2:
			filename = "frame90.jpg";
			break;
		default:
			filename = "frame32.jpg";
			break;
		}
		
		String imageDataLoc = System.getProperty("user.dir") + "/data/" + "/mipda/";
	
		originalImage = ImageUtil.wrapImagePlus(IJ.openImage(imageDataLoc + filename)).getSubGrid(0);
	}
	
	public void init(float a, float b, float d) {
		
		// Normalize intensity values to [0,1]
		float max = NumericPointwiseOperators.max(originalImage);
		float min = NumericPointwiseOperators.min(originalImage);
		
		for(int i = 0; i < originalImage.getWidth(); i++){
			for(int j = 0; j < originalImage.getHeight(); j++){
				
				float scaledValue = (originalImage.getAtIndex(i, j) - min) / (max-min);
				originalImage.setAtIndex(i, j, scaledValue);
			}
		}
		
		undistortedImage = new Grid2D(originalImage.getWidth(),originalImage.getHeight()); // initialization with zeros
		
		distortedImage = generateDistortedImage(originalImage,a,b,d);	
	}
	
	/**
	 * method to generate a distorted image
	 * An artificial distortion field is generated. With this field, 
	 * a distorted image is generated from the original image.
	 * Remark: coordinates of the latest distortion simulated are saved in class member variables
	 * @param inputImage: undistorted image on which distortion is simulated
	 * @param a: elliptic extent of the distortion in x-direction
	 * @param b: elliptic extent of the distortion in y-direction
	 * @param d: strength of the distortion
	 * @return: distorted image
	 */
    
	public Grid2D generateDistortedImage(Grid2D inputImage, float a, float b, float d){

		Grid2D grid = new Grid2D(inputImage);
		int imageWidth = grid.getWidth();
		int imageHeight = grid.getHeight();
		
		// generate grids to sample coordinates X and Y of the original image
		Grid2D X = new Grid2D(imageWidth,imageHeight); // x-coordinates with respect to origin in image center, spacing = 1 [unit]
		Grid2D Y = new Grid2D(imageWidth,imageHeight); // y-coordinates with respect to origin in image center, spacing = 1 [unit]
		
		float halfWidth = imageWidth / 2.0f;
		float halfHeight = imageHeight / 2.0f;
		
		for(int i = 0; i < X.getWidth(); i++){
			for(int j = 0; j < X.getHeight(); j++){
				
				X.setAtIndex(i, j, i - halfWidth + 0.5f); // assign pixel centers in x-direction
				Y.setAtIndex(i, j, j - halfHeight + 0.5f); // assign pixel center in y-direction
			}
		}
		
		// create an artificial elliptical distortion field R (additive field)
		Grid2D R = new Grid2D(imageWidth,imageHeight);

		for(int i = 0; i < R.getWidth(); i++){
			for(int j = 0; j < R.getHeight(); j++){
				
				// distortion gets stronger with the distance from the image center
				float r = d * (float)(Math.sqrt(
						Math.pow(X.getAtIndex(i, j)/(a*halfWidth),2)
						+ Math.pow(Y.getAtIndex(i, j)/(b*halfHeight),2)));
				R.setAtIndex(i, j, r);
			}
		}
		
		// shifting the positive range to half positive/half negative range
		float maxR = NumericPointwiseOperators.max(R);
		NumericPointwiseOperators.subtractBy(R, maxR * 0.5f);

		// create the distorted image coordinates:
		// distorted image coordinates = undistorted image points + artificial distortion field

		// distorted image coordinates Xd, Yd
		Grid2D Xd = new Grid2D(X);
		Grid2D Yd = new Grid2D(Y);
		
		NumericPointwiseOperators.addBy(Xd, R);
		NumericPointwiseOperators.addBy(Yd, R);
		
		// create the distorted image:
		// re-sample the original input image at the distorted image points (Xd,Yd) 
		// to create artificial distortion
		for(int i = 0; i < imageWidth; i++){
			for(int j = 0; j < imageHeight; j++){
				
				float distortedValue = InterpolationOperators.interpolateLinear(
						inputImage,
						Xd.getAtIndex(i, j) + halfWidth - 0.5f, // remember: coordinate origin was set to image center
						Yd.getAtIndex(i, j) + halfHeight - 0.5f);
				grid.setAtIndex(i, j, distortedValue);
			}
		}

		xprime = X;
		yprime = Y;
		x = Xd;
		y = Yd;
		
		return grid;	
	}	
	
	//getters for members
	// variables which are checked (DO NOT CHANGE!)
	
	public static int get_caseNo() {
		return caseNo;
	}
	
	public Grid2D get_originalImage() {
		return originalImage;
	}
	
	public Grid2D get_distortedImage() {
		return distortedImage;
	}
	
	public Grid2D get_undistortedImage() {
		return undistortedImage;
	}
	
	public int get_nx() {
		return nx;
	}
	
	public int get_ny() {
		return ny;
	}
	
	public float get_fx() {
		return fx;
	}
	
	public float get_fy() {
		return fy;
	}
	
	public SimpleMatrix get_Xu() {
		return Xu;
	}
	
	public SimpleMatrix get_Yu() {
		return Yu;
	}
	
	public SimpleMatrix get_Xd() {
		return Xd;
	}
	
	public SimpleMatrix get_Yd() {
		return Yd;
	}
	
	public int get_numCoeff() {
		return numCoeff;
	}
	
	public int get_numCorresp() {
		return numCorresp;
	}
	
	public SimpleMatrix get_A() {
		return A;
	}
	
	public DecompositionSVD get_svd() {
		return svd;
	}
	
	public SimpleMatrix get_A_pseudoinverse() {
		return A_pseudoinverse;
	}
	
	public SimpleVector get_u_vec() {
		return u_vec;
	}
	
	public SimpleVector get_v_vec() {
		return v_vec;
	}
	
	public SimpleVector get_XuVector() {
		return XuVector;
	}
	
	public SimpleVector get_YuVector() {
		return YuVector;
	}
	
	public SimpleVector get_XdVector() {
		return XdVector;
	}
	
	public SimpleVector get_YdVector() {
		return YdVector;
	}
	
	public Grid2D get_xDist() {
		return xDist;
	}
	
	public Grid2D get_yDist() {
		return yDist;
	}
	
	public Grid2D get_xprime() {
		return xprime;
	}
	
	public Grid2D get_yprime() {
		return yprime;
	}
	
	public Grid2D get_x() {
		return x;
	}
	
	public Grid2D get_y() {
		return y;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-15 23:57:52.098
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-15 23:57:52.098
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
